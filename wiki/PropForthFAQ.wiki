#summary Frequently Asked Questions
#labels v4.0,v4.5,v5.0

Newest questions are towards the top.  Older questions toward the bottom are for older versions, but may still address issues new users experience.  

= General =

* which release should I use? 

Always use the the most recent public release.  Previous releases are not supported,  as those issues are fixed in newer releases. 

* Where do I start?

 # Download the release archive zip file
 # Unzip the release to your hard drive anywhere you like
 # READ each README file you encounter in each directory AS  YOU ENCOUNTER IT
 # Find the CURRENT RELEASE DIRECTORY
 # FIND and start reading Propforth.htm This is your main reference for propforth
 # Determine which kernel you wish to use
 - PropForthDevKernel.spin is for plain propforth

 - PropForthSDKernel.spin is if you need TONS of storage for scripts, source code, data, etc.  You can use any size SD card.  Follow the directions for adding an SD card to you rig, its very simple and inexpensive.  Ask if you have questions. 

* How do I learn propforth?  I have a question about a specific word.

 # Load your kernel
 # execute the word
 # read the entries applicable to the word word in propforth.htm
 # find the example code for the word in propforth.htm, if available
 # find the example(s) in the tutorials that use the word
 # run the examples and do experiments 
 # if you still have questions, ask on the online forums
 # email me directly.  I will try to get you to write up all you notes and post them on the wiki pages, be prepared to become famous in the forth world. 

* What has changed, will my code be compatible with the new release, what words have changed?

To the user, everything should be pretty much identical from release to release Only the internal plumbing is changed since version 3.X. The user accessible words generally do not change.  _The code is optimized to to be faster, and smaller memory foot print. Words that are internal to propforth many change, but this would only affect advanced users attempting to redesign the kernel for custom applications.  Please contact the team directly with specific questions if you need to redesign the kernel_.

The last significant change was NUMBER FORMATTING.  Decimal values composed of digit 0-9 can be prefixed with a letter lowercase d to force decimal.Hex values using 0-9 and characters A-F can be prefixed with lowercase h to force hex. Radix-64 values (bear with me, I'm not really clear on this bit) using characters 0-9, A-Z, and a-y can be prefixed with lowercase letter z to force radix 64.  RADIX 64 is mainly used to encode optimized assembler routines in text files.  



= v5.3 =

Propforth v5.3 is expected to be the final version of propforth for the Prop 1. V5.3 contains the easier assembler, the assembler optimized kernel, the standard interfaces, the "standard interfaces" support, MCS (Go channels compatible) support, kernel buils automation, and automated test support.

V5.3 really ROCKS.

V5.3 is still in final packaging.  The documentation has to be reworked, as the ORGANIZATION of the docs has been adjusted. Yes, this is a pain in brain, but it must be done to be done right, and now is the time to do it right. 

 * When will v5.3 be released?

Sorry, I keep thinking we are done, and there keeps being another little thing we have to do.  After v3.x, I have decided never to release until the material is ready.  Rules is rules for a reason. 

v5.3 have been released to the team, but will not be released to the public until the team has completed testing and vetting the docs. 

= v5.2, v5.1 =

 * Where the heck are v5.1 and 5.2? 

Propforth versions 5.1 and 5.2 were internal development releases and not publicly released.  These were the experiments for Build automation and automated test execution. 

= v5.0 (Planned September 2011) =

When are going to start a separate FAQ for v5.0?

The v5.0 FAQ is at: 

http://code.google.com/p/propforth/wiki/Propforth50FAQ

= v 4.6 = 

Version 4.6 was released on 2011-07-25

The v4.6 FAQ is at: 

http://code.google.com/p/propforth/wiki/Propforth46FAQ

= v 4.5 =

Version 4.5 was released on 2011-06-14

== This FAQ is getting too long, when are you going to remover the old messages? ==

As the propforth kernel matures, the old FAQ material becomes less relevant.  A separate has been opened specific to v4.5 as an experiment.  If this is more suitable, release specific FAQ will be created.

The v4.5 FAQ is at: 

http://code.google.com/p/propforth/wiki/Propforth45FAQ

= V 4.0 =

Version for was superseded by version 4.5 on 2011-06-14

== the description says "N-slave props", why can't I get it to work? ==

The support is there, but we didn't write the examples yet. At least, we didn't make the examples "plug and play" yet.  Its a little tricky.  But figuring out is half the fun.  If you don't think that half is all that much fun, please wait till the new tutorial gets posted.  If you think the "bleeding edge" experiments are fun, please join the parallax forums and join or start a thread.  There's LOTS of fun to be had.

http://code.google.com/p/propforth/wiki/PropForth4SetupAndTest

Since the clean-up for 4.0 some things are a little different and my examples don't work the same.  So at least the documentation is a little rougher around the edges than usual. I'm up to the ROM-less demo {{{(NOROM.F)}}}  where the examples stop working for me. The docs should improve through December. 

== How does this MASTER / SLAVE arrangement work? ==

The MASTER is the prop with the EERROM image for PropForth. 
The EEPROM image contains code for establishing synchronous serial channels to other props.
One cog is consumed in establishing a synchronous serial channel. 
The MASTER has 5 cogs available.  
The MASTER can establish communication to up to 5 SLAVES.
Each SLAVE establishes a communications channel to its master, leaving seven cogs available. 
After the master boots, it tries to reset and boot any slaves that might be out there. 
If any slave responds, the master emulates EEPROM for the slave, sending the same ROM image as in the master. 
Each slave executes that same code as the master did, and can have sub-slaves.

A lone Prop has 5 cogs available (due to overhead for user I/O).  
A MASTER with 5 slaves has 5 * 7 = 35 cogs available, 5 * 28 = 140 pins available.  
A master with 5 slaves (sub-masters) and 35 sub-slave has 25 * 7 = 245 cogs available.

NOTE:  We haven't built any of these yet, we plan to post if we find any success.


== Why don't all your examples work with the current version? ==

The examples are created using the current version, but don't always get updated to the next version. Usually the person that asked the question has already got an answer and can move to the new version with no further assistance.  This doesn't help you, the new person.  However, if you ask a question about a particular example, I will re-visit it, and make it work with the current version.  Changes and updates are driven by user requests; if nobody asks, it doesn't get done. This strategy helps us limit work to topics people actually care about. 

Please ask any questions. If you are puzzles, other probably are too.

== does propforth work on the hydra? ==

Yes, propforth will run on ANY propeller chip.  However, we don't have that board so we never tested it.  An hydra - specific hardware does not have specific support.  But, it should be pretty easy to implement.  If you need help with an specific hardware, please open a discussion thread at the parallax forums.  

= How does one go about Learning PropForth? =

Read this wiki documentation, and submit comments and question son the numerous errors so I can correct them. 

Maybe start with reading the Learning PropForth page

http://code.google.com/p/propforth/wiki/LearningPropForth

= Does PropForth support ANSI escape codes on the serial terminal? =

There is a file of forth source code that adds ANSI Escape Sequence support for the serial terminal connection. ANSI Escape Sequences.f 

[http://code.google.com/p/propforth/downloads/detail?name=ANSI%20Escape%20Sequences.f&can=2&q= ANSI Escape Sequences.f ]

This is not included in the default kernel, but can be loaded as an extension. The system can then be saved using saveforth, if these are needed at power up. 


= Where is HERE defined? = 

Question: Where does word "here" define? I cannot find out it in  PropForthPart1/PropForthPart2.

There are three words that are defined and set in propforth.spin instead of PropForthpart1.f and propforthpart2.f

These are 
{{{
here
dictend
memend
}}}

These can't be easily re-defined while forth is running, it is very dangerous and things tend to go crazy.  Sal had to do it several times and had problems, so these ended up like this.  

These three words are the absolute beginning of the forth kernel.  Once the kernel began, memory access was added, the variables, then colon definitions, eventually it got to the point where ther was enough defined that the preliminary stuff could be removed, and there was enough to make a working forth kernel from forth.   

The spin tool is used to create the forth kernel from spin code.  Normally in a native forth, the forth system is used to create itself from scratch without the use of external tools (a pc and non forth compiler for example).   The decision was made NOT to do this at this time for propforth.  

Using the SPIN tool as the starting point for propforth has two main advantages:
1)  it is relatively easy to bring in or interface to spin and assembly objects
2) the spin tool takes care of any forward references (which usually require special handling during forth kernel build).

So, the definitions for here, dictend, and memend are first in the forth dictionsary.  Do "words" whcih prints out the dictionary reverse order, and these are the very last to print. 

These words are defined and values assigned in Propforth.spin at around line 165.

here is pretty much always 0D72 to start with, although it does automatically adjust itself as shown in the HiResVGA versions.

= The reboot and other (system diagnostic) messages only show up on the serial terminal, how to send them to VGA? =

The output of system diagnostic messages is controlled by (emit pointer ... check).  By chaning this the messages can be sent to any or all cog display.  Originally thes came up on all cog displays, but this was a nuisance.

= How to send a command to another cog? =

Put a counted string in the target cog's input buffer using cogx, like this:

From a terminal running cog5 to cog4 (which could be a VGA display cog)

{{{
Cog5 OK
c" 1 2 3 4 st? " 4 cogx

Cog5 OK
}}}

results in the cog4 display showing
{{{
ST: 00001 00002 00003 00004 
Cog4 OK
}}}

This is also the mechanism planned for use with the interprop high speed interface in future releases.

= how to give output from one cog to another cog? = 

This is little trickier, and it depend on what needs to be done.  Here are a couple methods. 

 - responses: make a word to update shared memory.  _com.f has examples

 - route output using the emit routine and emit pointer.  This is what is done in fast load, see code for 'fl' word for examples.

 - cogxo - don't even try this one yet.  Wait for the tutorial (when debugging is finished) 
 
= How to connect to a different cog in the serial terminal, the vga0 display, and the vga1 display? =

{{{
<cog#> >con
<cog#> >vga0
<cog#> >vga1
}}}

Example:  To display cog6 in vga0, cog5 in vga1, and cog4 in console, use:

{{{
4 >con
6 >vga0
5 >vga1
}}}

= How to start another FORTH cog? =
 
The word +cog 

{{{
+cog
}}}

starts the next available cog as a forth cog.  If there are no more available cogs, the +cog word has no affect.

= What does the BOOT message mean? =

It displays the version string and the status of the active running cogs

On power cycle or executing the "reboot" command, prop gives a message:

Propforth 3.5 standard kernel (serial driver only)

{{{
PROPELLER REBOOT Propforth v3.5 2010Oct09 20:00 0

COG5 RESET -- last status OK

COG6 RESET -- last status OK
Cog6 OK
}}}

Propforth 3.5 standard kernel with Low Res VGA (AFTER LowResVGA.f is loaded)

{{{
PROPELLER REBOOT Propforth v3.5 2010Oct09 20:00 1
COG5 RESET -- last status OK

COG1 RESET -- last status OK

COG0 RESET -- last status OK

COG6 RESET -- last status OK

COG2 RESET -- last status OK

COG3 RESET -- last status OK

COG4 RESET -- last status OK

COG5 RESET -- last status OK
Cog6 OK
}}}

Propforth 3.5 HiResVGA (BEFORE HiResVGA.f is loaded)

{{{
PROPELLER REBOOT Propforth v3.5 2010Oct09 20:00 0

COG5 RESET -- last status OK

COG6 RESET -- last status OK
Cog6 OK

COG0 RESET -- last status OK
Cog6 OK
}}}

Propforth 3.5 HiResVGA (AFTER HiResVGA.f is loaded)

{{{
PROPELLER REBOOT Propforth v3.5 2010Oct09 20:00 1
COG5 RESET -- last status OK

COG0 RESET -- last status OK

COG6 RESET -- last status OK

COG3 RESET -- last status OK

COG5 RESET -- last status OK

COG4 RESET -- last status OK
Cog6 OK

}}}

PROPELLER REBOOT Propforth v3.5 2010Oct09 20:00 1

The version string contains the release date, time and a counter.
The counter is incremented each time 
{{{
saveforth
}}}
is executed.  

** If you are trying to run any VGA and the counter at the end has not incremented from 0 to 1, you didn't correctly saveforth after you loaded xxxVGA.f

= What are the Active Cogs and what are they running? =

The command to display the active cogs on their activity is

{{{
cog?
        Forth cogs: 2-6
Running Forth Cogs: 2-6
         Spin Cogs: 0-1
}}}

The above example is for propforth 3.5 using LoResVGA.f

Explanation:

Cog0 starts running spin, and spin launches Propforth.  

Propforth runs the serial driver in COG7.  COG7 actually does all the talking between the user and the cogs.  Cog7 DISPLAYS the Cog6 or Cog4 prompt, so the user gets the impression that they are interacting directly with a cog.  The user is in fact interacting directly with the serial driver on cog7 , and indirectly with the cog displayed in the prompt. When the serial monitor is used, it replaces the serial driver, and re-uses cog7. 

After Cog0 launches propforth, spin goes to sleep. Cog0 is unused by the standard kernel, and is available for user functions.  One user function is VGA.  If the VGA option is used, cogs starting with cog0 preform the vga activity.  HiResVGA uses cogs 0, 1, and 2.  LowResVGA uses cogs 0 and 1.  VGA cogs show up as SPIN cogs, as the VGA drivers are spin assembly routines. 

The standard propforth kernel launches cogs 5 and 6 as forth cogs as seen in the boot message.  Cog0 is inactive. Cog7 runs the forth serial driver 

HiResVGA additionally launches cogs 0, 1, and 2 to run the VGA display. Cogs 0, 1 , and 2 show up as spin cogs. Cogs3 and 4 are the cogs displayed on the VGA terminal.  USe (CTL+ALT) to switch between the top half of the VGA display and the bottom of the VGA display. 

LowResVGA lauches cogs 0 and 1 to display VGA. Cogs 0 and 1 show up as spin cogs. Cogs 2 and 3 are the cogs displayed on the VGA screen page.  Use (CTL + ALT) to switch between pages.   

Note:  I don't know why HiResVGA displays cog0 and not cogs 2 and 3.  I do not know why LowResVGA displays cog4.  Possibly, its because this is new.  When the new spin files are created, they take a snapshot of the currently running forth system, and Sal may have been running diagnostics in the other cogs at the time. This explanation will be update and/or the extra cogs will be put away properly in future releases. 

= What's "JUPITER ACE" about? =

The High Resolution VGA / Prop Jupiter ACE sub-project is an extension to the default propforth kernel.  The idea is to provide a standalone forth based development system for the prop. As of version 3.4 it is compatible with the Prop Demo board pin-out for VGA and keyboard.

Jupiter ACE was a forth based PC from the olden days which stopped production in 1983. It was simply too far ahead of its time. See Jupiter ACE on Wikipedia for information.   Since one can no longer obtain a commercial product Jupiter ACE, it was easier to make one.  The PropforthHiResVGA.spin file is a Jupiter ACE - type implementation for the prop. 

Please see the [http://code.google.com/p/propforth/wiki/HiResVGAJupiterACE Propforth HiResVGA Jupiter ACE ] page

= What is this HIVE Project? =

The German Language site  http://hive-project.de/ provides complete instructions for constructing a multi-prop PC, from parts, for less than the cost of a video game.  Maybe we can't ever know what all those parts in the desktop PC are doing, but you CAN know what every single part in the Hive is doing because YOU BUILT IT YOURSELF.  Probably the single coolest thing you will do all week.

See Google Translate http://translate.googleusercontent.com/translate_c?hl=en&ie=UTF-8&sl=de&tl=en&u=http://hive-project.de/&prev=_t&rurl=translate.google.com&twu=1&usg=ALkJrhgW2ktyNMTtGgTFdWxthrSiuoAoFA  for the German language impaired.

SEE http://code.google.com/p/propforth/wiki/HivePropforthJupiterACE

*Look Here:*  8 cores per prop times 3 props = 24 cores.  Sounds like a tiny supercomputer to me.  Parallel distributed processing, anyone?

= How Do I Submit a Question? =

Sign in to your gmail account enter comments at the bottom of the page in question.  Please submit questions.  I don't know what to fix if you don't point out what's broken.

= Is there a simple Archive that contains all of the PropForth documentation? =

Yes and no.  This website that you are viewing is the archive of propforth documentation.

http://code.google.com/p/propforth/wiki/PropForth

This question was asked with the intent of requesting a single download of a zip-file archive of all these pages.  However, there does not yet exist a full, complete set of documentation, because of resource limitations.  The documentation is being added as specific requests come in, and as time allows.  That's the best we can do at the moment. 

= What is going on with the CREATE word? V3.3 and earlier =

The propforth CREATE word does NOT return any value on the stack.  Per DPANS94, CREATE is defined as creating a dictionary entry for the following label at compile time; and returning the PFA (parameter field address) for that label at execution time. Propforth does not have an explicit PFA; therefore, there is no PFA to be returned.  

This is awkward for defining arrays. Usually we want to do something like
{{{
CREATE MyLongArray 8 ALLOT

CREATE MyWordArray 6 WALLOT
}}}
to make MyLongArray contain 8 longs, and MyWordArray to contain 6 words.  Since CREATE doesn't work that way in propforth, it is recommended to use
{{{
Variable MyLongArray 8 4-  ALLOT

Variable MyWordArray 6 2- WALLOT
}}}

If other situations arise where the CREATE word is causing problems, please post the usage and workarounds.  We can determine if a change has to be made or if the workaround is livable.

For the time being, the CREATE word behavior will remain as is.

The design decision to use an inherent PFA instead of an explicit PFA was made in the interest of decreased code size and to a lesser extent faster execution speed.  Since cog RAM in the most limiting resource, the savings of the extra words per each definition was deemed worth the trade-off.  Please express your opinion if this should remain as is (inherent PFA) or change (explicit PFA at the cost of cog memory) if you have a preference one way or the other.  

= How does the WAITCNT word work? =

The WAITCNT word takes two parameters on the stack and leaves one value on the stack.

{{{ : waitcnt ( syscnt1 mydelay - syscnt2 )  ... ; }}}

Syscnt1 is the value of the system counter (cnt) ~~(ctra)~~ when the cog resumes execution; ie wait until system counter reaches syscnt1.  

Delay is the number (representing clock cycles) to add to this number.  For example, if we know the loop needs to wait 500 clock cycles between executions, the delay would be 1F4 (h).

The first time loop executes, we start with the seed value of cnt ~~ctra~~ on the stack.  Each time the wait is encountered, the delay value is automatically added to the seed value, and the number on the stack is the next value of the system counter to wait for.  If this result is on the top of the stack the next time through the loop when the 

{{{1F4 waitcnt}}}

line is encountered, the loop delay 500 cycles between executions.

As long as the loop processing time does not exceed mydelay, the cog will resume operation Delay cycles after the previous waitcnt.

*However*  if the loop execution time is greater than the delay interval, the syscnt2 value will be too small; the system counter will have already passed the value passed in as the next syscnt1, and the waitcnt word will suspend execution _until the system counter rolls over_ again.  IF  you experience and unusually LONG DELAY which is a multiple of about 53.6 seconds (using a 80MHz clock) consider this as a possible cause.  One solution is to increase mydelay until it is longer than the loop execution time. 

(thanks caskas and kuroneko) 

= How to use the SPEED.f utility? =

The speed.f utility is an example of a diagnostic to count the clock cycles for a bit of code. 

{{{  cnt COG@  }}}

puts the value of the system counter on the stack BEFORE the code in question is executed; 

{{{ cnt COG@ }}} 

is called again AFTER the code is executed.  The difference between these two values is the number of clock cycles the that occurred between.

NOTICE that if you use this method to time the waitcnt word you can get funky results due to the minimum and maximum values that can be measured.  (Which I should post here, but I haven't gotten around to doing the experiments yet.)


= How do I navigate the documentation on this site? =

Start with 

http://code.google.com/p/propforth/wiki/PropForth

and follow the links in the order presented.  If the information does not address your question, please leave a comment or post your question on the forum.  Also look through the wiki list

http://code.google.com/p/propforth/w/list

and start with the files tagged for the current version.

Please send suggestions as to ways to better organize the material, and we will do what we can. 

= What files do I want? =

 * The archive [http://code.google.com/p/propforth/downloads/detail?name=PropForth3.2%2020100710%20archive.zip PropForth3.2 20100710 archive.zip] contains the current source code file set. This is the one that most folks will want to see.

 * The earlier versions might not agree with the current documentation, so avoid these unless something is broken. 

= How do I load an entire file of source definition text into propforth? =

To load source text into the propforth command line rather than retyping everything manually each time, use the fl command.

Put *fl* at the beginning of each chunk pasted.

{{{
fl 

: my definitions .... ;
}}}

= What is the fl (fast load or file load) command? =

The fl (file load) command buffers a section of text into ~~eeprom~~ HUB RAM.  The interpreter than can compile all the definitions at its own best speed.

Please see the [http://code.google.com/p/propforth/wiki/flfastloadword flfastloadword] page in the wiki

= Why do I need to use the fl (file load) command? =

[http://code.google.com/p/propforth/wiki/flfastloadword flfastloadword]

The way serial communication is implemented there is no flow control.  Normally the interpreter is faster than the serial communications.  However, when a semi colon is encountered and a definition is committed to the dictionary, the write is slower than the serial communications. If a stream of text coming over the serial line contains more than three semicolons, the serial buffer can get over run. 

If you see the message 'UNDEFINED WORD' for a definition in a section of pasted text that previously compiled with no error, this is a likely cause. 

See [http://code.google.com/p/propforth/wiki/DownloadSourceText DownloadSourceText] for more information

= How to / comments behave?  =

In the context of the fl word (FILELOAD) the slash comments require some attention.

The \ causes everything up to and including the end of line to be ignored.

When using the fl command, care must be taken when using \ comments.

When a \ is used AFTER a line of CODE, the following line gets APPENDED. 

If there are multiple lines of code that end in \ comment (which is usually the case), all the lines get appended into one big line and the input buffer is eventually overrun. This results in UNDEFINED WORD error message for code that previously compiled with no error.

The solution is to put a BLANK LINE after all lines that have code followed by \ comment

EXAMPLE - ERROR

\ comments
\ on what the
\ code does
: MyWord ( - )
         word1 \ does this
         longerwordname2 anotherlongwordname3 wordname4 \ does more
         morelongwordnames \ does other things
...

get sent to the fl command as one big long line, which overruns the input buffer after 126 characters (pad -2, in v3.2)  

EXAMPLE - CORRECTED BY ADDING BLANK LINES after midline \ comments

\ comments
\ on what the
\ code does
: MyWord ( - )
         word1 \ does this

         longerwordname2 anotherlongwordname3 wordname4 \ does more

         morelongwordnames \ does other things

...



= In what version will PropForth use standard forth names for standard forth words?  When will this version come out? =

Standard-ish forth names are used for all implemented standard forth functions beginning in version 3.2.  If you feel a particular name is still counter-intuitive or misleading please send a comment here or on the [http://forums.parallax.com/forums/default.aspx?f=25&m=468264 Parallax Propeller forum thread ]

We are sure there are several (one stops seeing when one looks at it too long) so please bring them to our attention. 

= Do I need the files spinmaker.f to create kernel source code? =

  * Yes.  spinmaker.f generate Propforth kernel definitions from the _currently running forth image_.  After running saveforth, the spinmaker word will create the source definitions for that image, which will include any definitions you added. 

These are included in the v3.2 archive

= What does the "saveforth" word do? =
 
 * saveforth writes the current dictionary image that is running on the chip to eeprom. Each dot (period)  displayed represents one 64 byte page write to eeprom.  There are a maximum of 1024 pages of 64 bytes each.  If a word is redefined, the new definition is visible and covers up the old definition. Eventually the space this uses will be noticeable.  See the comments in [http://code.google.com/p/propforth/wiki/PropForthspin PropForth.spin] if you are interested in 128 byte page writes, but be aware that the prop demo board eeprom won't like it.  This was the bug in version 2.5

= What does the "spinmaker" word do? = 

  * The spinmaker word generates the forth portion of the [http://code.google.com/p/propforth/wiki/PropForthspin PropForth.spin] source file.  This gets rid of any old definitions and allows the propeller tool to resolve any forward references without the need for defered words.  

= Do I need the files [http://code.google.com/p/propforth/wiki/PropForthPart1 PropForthPart1.f] and [http://code.google.com/p/propforth/wiki/PropForthPart2 PropForthPart2.f]? =

  * Not necessarily. [http://code.google.com/p/propforth/wiki/PropForthPart1 PropForthPart1.f] and [http://code.google.com/p/propforth/wiki/PropForthPart2 PropForthPart2.f] will generate the original PropForth kernel definitions as found in [http://code.google.com/p/propforth/wiki/PropForthspin PropForth.spin].   

You only need these if you want to see that the definitions generated are the same as those posted, without the comments

However, if you wish to modify propforth itself, [http://code.google.com/p/propforth/wiki/PropForthPart1 PropForthPart1.f] and [http://code.google.com/p/propforth/wiki/PropForthPart2 PropForthPart2.f] contain the source code in forth.  If you wish to modify the propforth kernel using forth, these are the files to modify.

= What is the "Display Data Stack" word?  Why doesn't ".S" work? =

The standard 'display data stack' word .S is not implemented in the default kernel.  There is a plan for a 'development extensions' that will include the .s word, but it is not available at this time. 

The word "st?" displays the stack in hex formatted to 8 hex digits. 

= What is the number base word? Why doesn't "BASE" work? =

UPDATED: mcwBase has been renamed to base in version 3.2

NOTE 
{{{

10 base w! / set base to whatever base it is in; hex, decimal, octal, binary, etc 

}}}

set the base to decimal or hex using the kernel words
{{{
hex  / defined using decimal definition 16 base w!
}}}

and 

{{{
decimal  / defined using decimal definition 10 base w!
}}}

In version 2.7 and earlier, the variable that holds the number base is mcwBase. The standard forth name "BASE" will be used in version 3.0 (planned)

= Can words be defined in the Cog memory rather than the Hub memory? =

  * Yes.  The original model included the ability to define high level forth words exclusive to the Cog that would use them.  Turns out, however, to be too difficult and complex; also, cog specific words tend to be the ones optimized into assembly.   Presently, the model is high level definitions in the common hub memory, and cog specific words in assembly. An example of assembly definitions that exist only in the cog that uses them is the Logic Analyzer module. See LogicAnalyzer.f

= What is the Logic Analyzer? =

  * LogicAnalyzer.f is a reorganization of la.f.  Some of the cryptic names are being changed to descriptive names.  If you can't find the file, its due to trouble sorting out the names. If you do find the file, it still might not be sorted out.  If your the type of person that needs a logic analyzer, your probably the type that can figure out la.f; If your just fiddling (what I do) please wait a little longer for LogicAnalyzer.f to be completed.  This message will be updated once LogicAnalyzer.f is tested.

  * LogicAnalyzer.f or la.f is the source code for the software logic analyzer.  It uses 1 to 4 cogs to provide logic analyzer functionality.  The file contains assembly definitions for fucntions that reside in the cogs, not the main dictionary.  The following are the names used in the current la.f file; these are to be renamed to more descriptive names with the release of LogicAnalizer.f

  * ds0 - samples every clock, no trigger;  runs on cogs 0, 1 , 2, and 3.

  * dspin - ( pronounced "ds - pin" ) defines the trigger pin, default is pin 10 

  * ds1 - samples every 4 clocks, triggers on dspin

  * ds2 - sample every 40 clocks, triggers on dspin

  * ds - sample every 40 clocks, no trigger

  * hza - toggle a pin at a frequency, for testing.  Starts propcounter (in the cog)  to oscilate dspin 

  * hzb - toggle a pin at a frequency, for testing.  Starts propcounter (in the cog)  to oscilate dspin

= What is does the "aslice" word do? =

  * aslice is an assembly level time slicer.  The assembly time slicing happens between forth words rather than between tasks.  This is the "me-first" time slicer.

= What is does the "fslice" word do? =

  * fslice (it is actually "underscore-fslice" but this wiki interprets underscope as a command to make everything italics) is forth level time slicer.  It works in the forth round robin software multitasker with pause and next.  This is the "wait for my turn / cooperative" time slicer 

= What is the difference between fslice and aslice? =

  * The round robin multitasker "fslice" happens between tasks.  The assembly multitasker "aslice" happens between forth words.   The result is that the assembler multitasker executed a LOT more often than the round robin.  The engineer has to know whats what about all this in order  to decide what to use.  

= What is "serialdriver.f"? =

  * The serial driver contains the same code as in the default senetry routine that run on cog 7 at boot time.  Since serial communications is not very demanding, it is possible to restart cog seven as a forth cog, and have cog 7 run the serial port, and run a serial monitor and a terminal and other useful functions.  

= What is "serialmonitor.f" =

  * This is a monitor which is meant to run on cog 7 along with the serial driver. It provides interpretation of CTL-A(connect terminal to the next cog) CTL-B(connect terminal to the previous cog) and CTL-C(reset the propeller chip). In addition it also monitors debugging in the other forth cogs to report stack overflows and underflows. This functionality is time-sliced by the forth time slicer, so cog 7 can also be used as a forth cog, albeit one that will run more slowly as it is time sliced at both by the assembler slicer and the forth slicer.

NOTE: serialmonitor.f NEEDS to have aslicer.f and serialdriver.f loaded before it.

= What is the difference between the SerialMonitor and the DeluxeSerialMonitor? =

  * The DeluxeSerialMonitor has all three files in a single archive, and the files are numbered in the order that they are to be loaded.  Otherwise the files are pretty much the same as the SerialMonitor files.  I just needed a different name for the zip-packaged version. 

= How to start an arbitrary cog executing an arbitrary word? =

  *the cogX word start a cog executing a word
  See [http://code.google.com/p/propforth/wiki/CogXInstructions CogXInstructions]

= what is the long term direction for PropForth? =

 * The goal is a "standard forth".  

 * The basic kernel will be a "hardware abstraction layer" to support the basic standard forth words.  

 * A "developer environment" to aid with typical development tasks, tailored for this hardware:  source code maintenance, debugging, interface to common external functions.  Possibly as extensions, possibly included in the kernel.  

  * Compatibility with existing standard forth code where possible 