#summary Frequently Asked Questions
#labels Featured,v3.3

= How Do I Submit a Question? =

  * Sign in to your gmail account enter comments at the bottom of the page in question

= Is there a simple Archive that contains all of the PropForth documentation? =

Yes and no.  This website that you are viewing is the archive of propforth documentation.

http://code.google.com/p/propforth/wiki/PropForth

This question was asked with the intent of requesting a single download of a zip-file archive of all these pages.  However, there does not yet exist a full, complete set of documentation, because of resource limitations.  The documentation is being added as specific requests come in, and as time allows.  That's the best we can do at the moment. 

= What is going on with the CREATE word? V3.3 and earlier =

The propforth CREATE word does NOT return any value on the stack.  Per DPANS94, CREATE is defined as creating a dictionary entry for the following label at compile time; and returning the PFA (parameter field address) for that label at execution time. Propforth does not have an explicit PFA; therefore, there is no PFA to be returned.  

This is awkward for defining arrays. Usually we want to do something like
{{{
CREATE MyLongArray 8 ALLOT

CREATE MyWordArray 6 WALLOT
}}}
to make MyLongArray contain 8 longs, and MyWordArray to contain 6 words.  Since CREATE doesn't work that way in propforth, it is recommended to use
{{{
Variable MyLongArray 8 4-  ALLOT

Variable MyWordArray 6 2- WALLOT
}}}

If other situations arise where the CREATE word is causing problems, please post the usage and workarounds.  We can determine if a change has to be made or if the workaround is livable.

For the time being, the CREATE word behavior will remain as is.

The design decision to use an inherent PFA instead of an explicit PFA was made in the interest of decreased code size and to a lesser extent faster execution speed.  Since cog RAM in the most limiting resource, the savings of the extra words per each definition was deemed worth the trade-off.  Please express your opinion if this should remain as is (inherent PFA) or change (explicit PFA at the cost of cog memory) if you have a preference one way or the other.  

= How does the WAITCNT word work? =

The WAITCNT word takes two parameters on the stack and leaves one value on the stack.

{{{ : waitcnt ( syscnt1 mydelay - syscnt2 )  ... ; }}}

Syscnt1 is the value of the system counter (cnt) ~~(ctra)~~ when the cog resumes execution; ie wait until system counter reaches syscnt1.  

Delay is the number (representing clock cycles) to add to this number.  For example, if we know the loop needs to wait 500 clock cycles between executions, the delay would be 1F4 (h).

The first time loop executes, we start with the seed value of cnt ~~ctra~~ on the stack.  Each time the wait is encountered, the delay value is automatically added to the seed value, and the number on the stack is the next value of the system counter to wait for.  If this result is on the top of the stack the next time through the loop when the 

{{{1F4 waitcnt}}}

line is encountered, the loop delay 500 cycles between executions.

As long as the loop processing time does not exceed mydelay, the cog will resume operation Delay cycles after the previous waitcnt.

*However*  if the loop execution time is greater than the delay interval, the syscnt2 value will be too small; the system counter will have already passed the value passed in as the next syscnt1, and the waitcnt word will suspend execution _until the system counter rolls over_ again.  IF  you experience and unusually LONG DELAY which is a multiple of about 53.6 seconds (using a 80MHz clock) consider this as a possible cause.  One solution is to increase mydelay until it is longer than the loop execution time. 

(thanks caskas and kuroneko) 

= How to use the SPEED.f utility? =

The speed.f utility is an example of a diagnostic to count the clock cycles for a bit of code. 

{{{  cnt COG@  }}}

puts the value of the system counter on the stack BEFORE the code in question is executed; 

{{{ cnt COG@ }}} 

is called again AFTER the code is executed.  The difference between these two values is the number of clock cycles the that occurred between.

NOTICE that if you use this method to time the waitcnt word you can get funky results due to the minimum and maximum values that can be measured.  (Which I should post here, but I haven't gotten around to doing the experiments yet.)


= How do I navigate the documentation on this site? =

Start with 

http://code.google.com/p/propforth/wiki/PropForth

and follow the links in the order presented.  If the information does not address your question, please leave a comment or post your question on the forum.  Also look through the wiki list

http://code.google.com/p/propforth/w/list

and start with the files tagged for the current version.

Please send suggestions as to ways to better organize the material, and we will do what we can. 

= What files do I want? =

 * The archive [http://code.google.com/p/propforth/downloads/detail?name=PropForth3.2%2020100710%20archive.zip PropForth3.2 20100710 archive.zip] contains the current source code file set. This is the one that most folks will want to see.

 * The earlier versions might not agree with the current documentation, so avoid these unless something is broken. 

= How do I load an entire file of source definition text into propforth? =

To load source text into the propforth command line rather than retyping everything manually each time, use the fl command.

Put fl at the beginning of each chunk pasted.

{{{
fl 

: my definitions .... ;
}}}

= What is the fl (file load) command? =

The fl (file load) command buffers a section of text into ~~eeprom~~ HUB RAM.  The interpreter than can compile all the definitions at its own best speed.

= Why do I need to use the fl (file load) command? =

The way serial communication is implemented there is no flow control.  Normally the interpreter is faster than the serial communications.  However, when a semi colon is encountered and a definition is committed to the dictionary, the write is slower than the serial communications. If a stream of text coming over the serial line contains more than three semicolons, the serial buffer can get over run. 

If you see the message 'UNDEFINED WORD' for a definition in a section of pasted text that previously compiled with no error, this is a likely cause. 

See [http://code.google.com/p/propforth/wiki/DownloadSourceText DownloadSourceText] for more information

= How to / comments behave?  =

In the context of the fl word (FILELOAD) the slash comments require some attention.

The \ causes everything up to and including the end of line to be ignored.

When using the fl command, care must be taken when using \ comments.

When a \ is used AFTER a line of CODE, the following line gets APPENDED. 

If there are multiple lines of code that end in \ comment (which is usually the case), all the lines get appended into one big line and the input buffer is eventually overrun. This results in UNDEFINED WORD error message for code that previously compiled with no error.

The solution is to put a BLANK LINE after all lines that have code followed by \ comment

EXAMPLE - ERROR

\ comments
\ on what the
\ code does
: MyWord ( - )
         word1 \ does this
         longerwordname2 anotherlongwordname3 wordname4 \ does more
         morelongwordnames \ does other things
...

get sent to the fl command as one big long line, which overruns the input buffer after 126 characters (pad -2, in v3.2)  

EXAMPLE - CORRECTED BY ADDING BLANK LINES after midline \ comments

\ comments
\ on what the
\ code does
: MyWord ( - )
         word1 \ does this

         longerwordname2 anotherlongwordname3 wordname4 \ does more

         morelongwordnames \ does other things

...



= In what version will PropForth use standard forth names for standard forth words?  When will this version come out? =

Standard-ish forth names are used for all implemented standard forth functions beginning in version 3.2.  If you feel a particular name is still counter-intuitive or misleading please send a comment here or on the [http://forums.parallax.com/forums/default.aspx?f=25&m=468264 Parallax Propeller forum thread ]

We are sure there are several (one stops seeing when one looks at it too long) so please bring them to our attention. 

= Do I need the files spinmaker.f to create kernel source code? =

  * Yes.  spinmaker.f generate Propforth kernel definitions from the _currently running forth image_.  After running saveforth, the spinmaker word will create the source definitions for that image, which will include any definitions you added. 

These are included in the v3.2 archive

= What does the "saveforth" word do? =
 
 * saveforth writes the current dictionary image that is running on the chip to eeprom. Each dot (period)  displayed represents one 64 byte page write to eeprom.  There are a maximum of 1024 pages of 64 bytes each.  If a word is redefined, the new definition is visible and covers up the old definition. Eventually the space this uses will be noticeable.  See the comments in [http://code.google.com/p/propforth/wiki/PropForthspin PropForth.spin] if you are interested in 128 byte page writes, but be aware that the prop demo board eeprom won't like it.  This was the bug in version 2.5

= What does the "spinmaker" word do? = 

  * The spinmaker word generates the forth portion of the [http://code.google.com/p/propforth/wiki/PropForthspin PropForth.spin] source file.  This gets rid of any old definitions and allows the propeller tool to resolve any forward references without the need for defered words.  

= Do I need the files [http://code.google.com/p/propforth/wiki/PropForthPart1 PropForthPart1.f] and [http://code.google.com/p/propforth/wiki/PropForthPart2 PropForthPart2.f]? =

  * Not necessarily. [http://code.google.com/p/propforth/wiki/PropForthPart1 PropForthPart1.f] and [http://code.google.com/p/propforth/wiki/PropForthPart2 PropForthPart2.f] will generate the original PropForth kernel definitions as found in [http://code.google.com/p/propforth/wiki/PropForthspin PropForth.spin].   

You only need these if you want to see that the definitions generated are the same as those posted, without the comments

However, if you wish to modify propforth itself, [http://code.google.com/p/propforth/wiki/PropForthPart1 PropForthPart1.f] and [http://code.google.com/p/propforth/wiki/PropForthPart2 PropForthPart2.f] contain the source code in forth.  If you wish to modify the propforth kernel using forth, these are the files to modify.

= What is the "Display Data Stack" word?  Why doesn't ".S" work? =

The standard 'display data stack' word .S is not implemented in the default kernel.  There is a plan for a 'development extensions' that will include the .s word, but it is not available at this time. 

The word "st?" displays the stack in hex formatted to 8 hex digits. 

= What is the number base word? Why doesn't "BASE" work? =

UPDATED: mcwBase has been renamed to base in version 3.2

NOTE 
{{{

10 base w! / set base to whatever base it is in; hex, decimal, octal, binary, etc 

}}}

set the base to decimal or hex using the kernel words
{{{
hex  / defined using decimal definition 16 base w!
}}}

and 

{{{
decimal  / defined using decimal definition 10 base w!
}}}

In version 2.7 and earlier, the variable that holds the number base is mcwBase. The standard forth name "BASE" will be used in version 3.0 (planned)

= Can words be defined in the Cog memory rather than the Hub memory? =

  * Yes.  The original model included the ability to define high level forth words exclusive to the Cog that would use them.  Turns out, however, to be too difficult and complex; also, cog specific words tend to be the ones optimized into assembly.   Presently, the model is high level definitions in the common hub memory, and cog specific words in assembly. An example of assembly definitions that exist only in the cog that uses them is the Logic Analyzer module. See LogicAnalyzer.f

= What is the Logic Analyzer? =

  * LogicAnalyzer.f is a reorganization of la.f.  Some of the cryptic names are being changed to descriptive names.  If you can't find the file, its due to trouble sorting out the names. If you do find the file, it still might not be sorted out.  If your the type of person that needs a logic analyzer, your probably the type that can figure out la.f; If your just fiddling (what I do) please wait a little longer for LogicAnalyzer.f to be completed.  This message will be updated once LogicAnalyzer.f is tested.

  * LogicAnalyzer.f or la.f is the source code for the software logic analyzer.  It uses 1 to 4 cogs to provide logic analyzer functionality.  The file contains assembly definitions for fucntions that reside in the cogs, not the main dictionary.  The following are the names used in the current la.f file; these are to be renamed to more descriptive names with the release of LogicAnalizer.f

  * ds0 - samples every clock, no trigger;  runs on cogs 0, 1 , 2, and 3.

  * dspin - ( pronounced "ds - pin" ) defines the trigger pin, default is pin 10 

  * ds1 - samples every 4 clocks, triggers on dspin

  * ds2 - sample every 40 clocks, triggers on dspin

  * ds - sample every 40 clocks, no trigger

  * hza - toggle a pin at a frequency, for testing.  Starts propcounter (in the cog)  to oscilate dspin 

  * hzb - toggle a pin at a frequency, for testing.  Starts propcounter (in the cog)  to oscilate dspin

= What is does the "aslice" word do? =

  * aslice is an assembly level time slicer.  The assembly time slicing happens between forth words rather than between tasks.  This is the "me-first" time slicer.

= What is does the "fslice" word do? =

  * fslice (it is actually "underscore-fslice" but this wiki interprets underscope as a command to make everything italics) is forth level time slicer.  It works in the forth round robin software multitasker with pause and next.  This is the "wait for my turn / cooperative" time slicer 

= What is the difference between fslice and aslice? =

  * The round robin multitasker "fslice" happens between tasks.  The assembly multitasker "aslice" happens between forth words.   The result is that the assembler multitasker executed a LOT more often than the round robin.  The engineer has to know whats what about all this in order  to decide what to use.  

= What is "serialdriver.f"? =

  * The serial driver contains the same code as in the default senetry routine that run on cog 7 at boot time.  Since serial communications is not very demanding, it is possible to restart cog seven as a forth cog, and have cog 7 run the serial port, and run a serial monitor and a terminal and other useful functions.  

= What is "serialmonitor.f" =

  * This is a monitor which is meant to run on cog 7 along with the serial driver. It provides interpretation of CTL-A(connect terminal to the next cog) CTL-B(connect terminal to the previous cog) and CTL-C(reset the propeller chip). In addition it also monitors debugging in the other forth cogs to report stack overflows and underflows. This functionality is time-sliced by the forth time slicer, so cog 7 can also be used as a forth cog, albeit one that will run more slowly as it is time sliced at both by the assembler slicer and the forth slicer.

NOTE: serialmonitor.f NEEDS to have aslicer.f and serialdriver.f loaded before it.

= What is the difference between the SerialMonitor and the DeluxeSerialMonitor? =

  * The DeluxeSerialMonitor has all three files in a single archive, and the files are numbered in the order that they are to be loaded.  Otherwise the files are pretty much the same as the SerialMonitor files.  I just needed a different name for the zip-packaged version. 

= How to start an arbitrary cog executing an arbitrary word? =

  *the cogX word start a cog executing a word
  See [http://code.google.com/p/propforth/wiki/CogXInstructions CogXInstructions]

= what is the long term direction for PropForth? =

 * The goal is a "standard forth".  

 * The basic kernel will be a "hardware abstraction layer" to support the basic standard forth words.  

 * A "developer environment" to aid with typical development tasks, tailored for this hardware:  source code maintenance, debugging, interface to common external functions.  Possibly as extensions, possibly included in the kernel.  

  * Compatibility with existing standard forth code where possible 