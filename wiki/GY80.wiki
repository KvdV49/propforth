#summary GY-80 IMU.

= GY-80 Inertial Measurement unit =

The GY-80 is a very inexpensive 10DOF inertial measurement unit.

I got mine off Ebay for about $50, it was insanely cheap at the time.  Now they are going for about $14.  Be aware that these might be rejects or in some way defective.  They still work and are fun to play with, and are fine for experimentation purposes.  

There are newer parts on the market that are more capable and possibly cheaper.  Some have upgraded versions of these parts, so potentially there are drop-in replacements and the same code works.  CHECK THE DATA SHEET, as always!

= Uses =

IMU is handy for meausuring changes in speed and position (inertia).  If we know speed and direction, we can determine our position in relation to a known point, such as our starting point.  If we have no other information, we can call this "dead reckoning" or "deduced reckoning".

We can use this for Robo-Magellan, or Quad Copter navigation and control. 

NOTE:  GPS is separate from this IMU, we can add GPS later. 

= I2C =

The GY-80 uses  [I2C] bus  to talk with the microprocessor.  There are actually FOUR I2C bus parts on the GY-80. The use the same [I2C] wires and commands that we already se to talk to the EEPROM, so support is already built into the kernel for  free. Neet!

The parts are 
 * ADXL345 accelerometer
 * BMP085 barometric pressure sensor
 * HMC5883L magnetometer (Compass)
 * L3G4200D gyroscope

The accelerometer, gyroscope, and magnetometer all are 3 axis. 

 * [ADXL345]
 * [BMP085]
 * [HMC5883L]
 * [L3G4200D]

= GY80 driver =

The individual drivers are combined into a single module.

One cog tends all I2C bus devices, the foreground cog displys the sensor output as simple text.

{{{
fl

{
GY80 IMU consists of:
     ADXL345 accelorometer
     BMP085 barometer
     HMC5883L magnetometer
     L3G4200D gyroscope
}

1 wconstant build_ADXL345

\ ADXL.XYZDATA  needs 2 addittional words, 4 bytes
\ x=0 offset y=+2 offset z =+4 offset
wvariable ADXL.XYZDATA 4 allot

\ _ADXLs ( addr -- )  ALT ADDRESS pin ground (ADXL Pin 12 from datasheet) 
: _ADXLs
	_eestart hA6 _eewrite swap _eewrite or \ grounding  0xA6 for a write
	if h44 ERR then ;

\ _ADXLr   ( addr -- )  \  ALT ADDRESS pin (Pin 12)
: _ADXLr
	_ADXLs _eestart hA7 _eewrite \ grounding 0xA7 for a read 
	if h45 ERR then ;

\ _ADXLr8 ( addr - U8 )  register read
: _ADXLr8 _ADXLr -1 _eeread _eestop ;

\ don't need all the individual register addresses unless changing defaults
\ in fact, we are doing a multi-read, so we only need the FIRST data register,
\  which is dataX0 at address hex 32
: ADXL.DEVID          h00   ;
: ADXL.DATAX0         h32   ;
: ADXL.POWER_CT       h2D   ;
\ but we DO need power control (POWER_CT h2D) to turn on measurement mode

\ fetch the device ID
\ @ADXL.DEVID ( - DEV.ID)   \ device ID is 229 hex E5
: @ADXL.DEVID ADXL.DEVID _ADXLr8 ;

\ !POWER_CT ( flags - )  sets flags to configure ADXL 
: !POWER_CT       ADXL.POWER_CT      _ADXLs _eewrite _eestop  ;

\ ADXL.default \ ( - ) bit 3 sets measure mode
: ADXL.default 
               b0000_1000 !POWER_CT  \ stay awake, measure, awake      
;

\ ADXLrXYZ! ( - ) read current XYZ and store in array ADXL.XYZDATA
: ADXLrXYZ!

             ADXL.DATAX0 
             _ADXLr
           \ DATAx0 is least significant byte; DATAx1 is the most significant byte
             0 _eeread  0 _eeread 8 lshift or ADXL.XYZDATA W!
           \ DATAy0 is least significant byte; DATAy1 is the most significant byte
             0 _eeread  0 _eeread 8 lshift or ADXL.XYZDATA 2+ W!
           \ DATAz0 is least significant byte; DATAz1 is the most significant byte
             0 _eeread  -1 _eeread 8 lshift or ADXL.XYZDATA 4+ W!
             _eestop 
;

\ END of AXDL
\ **************************************************************

1 wconstant build_bmp085

wvariable bmp.data 4 allot

\ 0 - 3  \ over sample setting - 
         \ 0-low power, 1-standard, 2-high, 3-ultra high resolution
         \
wvariable _bmpOss 3 _bmpOss W!

\ _bmps   ( addr -- ) \ module address write - xEE - SEND
: _bmps   _eestart hEE _eewrite swap _eewrite or if h44 ERR then ;
\ _bmpr   ( addr -- ) \ module address read - xEF - RECEIVE
: _bmpr   _bmps _eestart hEF _eewrite if h45 ERR then ;
\ _bmpcrw ( c -- )  \  xF4 is  control register
: _bmpcrw hF4 _bmps _eewrite _eestop if h46 ERR then ;
\ _bmpr16 ( addr -- u16) 
: _bmpr16 _bmpr 0 _eeread 8 lshift -1 _eeread or _eestop ;
\ _bmpr24 ( addr -- u24)
: _bmpr24 _bmpr 0 _eeread 8 lshift 0 _eeread or 8 lshift -1 _eeread or _eestop ;
\ _bmprs16 ( addr -- n16)
: _bmprs16 _bmpr16 dup h8000 and if hFFFF0000 or then ;
\ _bmpID   ( -- chipid_version)
: _bmpID  hD0 _bmpr16 ;
: _bmpAC1 hAA _bmprs16 ;
: _bmpAC2 hAC _bmprs16 ;
: _bmpAC3 hAE _bmprs16 ;
: _bmpAC4 hB0 _bmpr16 ;
: _bmpAC5 hB2 _bmpr16 ;
: _bmpAC6 hB4 _bmpr16 ;
: _bmpB1  hB6 _bmprs16 ;
: _bmpB2  hB8 _bmprs16 ;
: _bmpMB  hBA _bmprs16 ;
: _bmpMC  hBC _bmprs16 ;
: _bmpMD  hBE _bmprs16 ;

: _bmpUT h2E _bmpcrw d_5 delms hF6 _bmpr16 ;

: _bmpB5
        \ X1 = (UT - AC6)* AC5/2exp15
	_bmpUT _bmpAC6 - _bmpAC5 h8000 */ dup
        \ X2 = MC * 2exp11 / (X1 + MD)
	_bmpMD + _bmpMC h800 rot */
        \ B5 = X1 + X2
	+
;

: bmpTemp _bmpB5 8 + h10 / ;

: _bmpUP
	h34 _bmpOss W@ 6 lshift + _bmpcrw
	_bmpOss W@ 0=
	if d_5 	else 
        _bmpOss W@ 1 =
	if d_8 	else 
        _bmpOss W@ 2 =
	if d_14 else d_26
	thens
	delms 
	hF6 _bmpr24 8 _bmpOss W@ - rshift
;

: bmpPressure
\ B6 = B5 - 4000
	_bmpB5 d_4000 -
\ X1  = (B2 * (B6*B6/2exp12))/2exp11
	dup dup h_1000  */ dup  _bmpB2 h800 */
\ ( B6 B6*B6/2exp12 X1 -- )
\ X2 = AC2*B6/2exp11
	2 ST@ _bmpAC2 h800 */
\ ( B6 B6*B6/2exp12 X1 X2 -- )
\ X3 = X1 +x2
	+
\ ( B6 B6*B6/2exp12 X3 -- )
\ B3 = ( ((AC1*4+X3)<<oss) +2) / 4
	_bmpAC1 4 * + _bmpOss W@ lshift 2+ 4 /
\ ( B6 B6*B6/2exp12 B3 -- )
\ X1 = AC3*B6/2exp13
	rot _bmpAC3 h2000 */
\ ( B6*B6/2exp12 B3 X1 -- )
\ X2 = (B1 *(B6*B6/2exp12))/2exp16
	rot _bmpB1 h_10000 */
\ ( B3 X1 X2 -- )
\ X3 = ((X1+X2)+2)/2exp2
	+ 2+ 4 /
\ (B3 X3 -- )
\ B4 = AC4 * (ulong)(X3+32768) / 2exp15
	d_32_768 + _bmpAC4 h8000 */
\ (B3 B4 -- )
\ B7 = ((ulong)UP-B3)*(50000 >> oss)
	_bmpUP rot - d_50_000 _bmpOss W@ rshift *

	dup h_8000_0000 and 0=
	if 2* swap u/
	else swap u/ 2*
	then
\ ( p -- )
\ X1 = (p/2exp8)*(p/2exp8)
	dup h100 / dup *
\ ( p X1 -- )
\ X1 = (X1 * 3038)/2exp16
	d_3038 h_1_0000 */
\ ( p X1 -- )
\ X2 = (-7357*p)/2exp16
	over d-7357 h_1_0000 */
\ ( p X1 X2 -- )
\ p = p + (X1 + X2 + 3791) / 	2exp4
	+ d_3791 + h10 / +
\ ( p -- )
;

: BMP085!  bmpTemp bmpPressure bmp.data dup 2+ rot swap L! W! ;

: BMP085@ bmp.data dup W@ swap 2+ L@ ;
            


\ bmpTemp bmpPressure

\ **************************************************************

1 wconstant build_HMC5883L

wvariable HMC5883L 4 allot

\ _HMCs ( addr -- )
: _HMCs _eestart h3C _eewrite swap _eewrite or if h3C ERR then ;
\ _HMCr ( addr -- )
: _HMCr _HMCs _eestart h3D _eewrite if h3D ERR 	then ;
\ _HMCr24 ( addr -- u24)
: _HMCr24 _HMCr 0 _eeread 8 lshift 0 _eeread or 8 lshift -1 _eeread or _eestop ;
\ _HMCr16 ( addr -- u16)
: _HMCr16 _HMCr 0 _eeread 8 lshift -1 _eeread or _eestop ;
\ _HMCr8 ( addr -- u8)
 : _HMCr8 _HMCr -1  _eeread  _eestop ;
\ _HMCID ( -- chipid_version)
: .HMCID
    ." HMC5883L ID: "  \	h0A _HMCr8  emit 	h0B _HMCr8  emit 	h0C _HMCr8  emit
	h0A _HMCr 0 _eeread  emit 0 _eeread emit -1 _eeread  emit _eestop  space cr ;
: _HMC_dump   decimal   13 0 do cr i  . i _HMCr8 . loop ; 
: _HMC_ConfA h00 _HMCs _eewrite _eestop if h46 ERR then ;
: _HMC_ConfB h01 _HMCs _eewrite _eestop if h46 ERR then ;
: _HMC_mode  h02 _HMCs _eewrite _eestop if h46 ERR then ;
\ Configuration register A 01111000 = h78 or 120
\               8 samples = 11  
\ Outputrate 75hz =           110
\  no bias offset =              00
: Fast_sample h78 _HMC_ConfA ;
\ _HMCrXZY ( addr -- Xu16 Zu16 Yu16)
: _HMCrXZY 	
       h03 _HMCr \ starting with X hi
           0 _eeread 8 lshift 0 _eeread or 
           0 _eeread 8 lshift 0 _eeread or 
           0 _eeread 8 lshift -1 _eeread or 
           _eestop 
;

: HMC5883L.config
        h00 _HMC_mode \ continuous mode
       Fast_sample
;

: MMC5883L!  \ HMC5883L
         h03 _HMCr \ starting with X hi
           0 _eeread 8 lshift 0 _eeread or 
           0 _eeread 8 lshift 0 _eeread or 
           0 _eeread 8 lshift -1 _eeread or 
           _eestop 
                   HMC5883L 4 + W!
                   HMC5883L 2+ W!
                   HMC5883L W!
;

\ **************************************************************


1 wconstant build_L3G4200D

wvariable L3G4200D 8 allot

\ _L3Gs ( addr -- )
: _L3Gs  _eestart hD2 _eewrite swap _eewrite or \ [SDO = VDD]
\	 _eestart hD0 _eewrite swap _eewrite or \ [SDO = GND]
	if h44 ERR then ;
\ _L3Gr ( addr -- )
: _L3Gr _L3Gs _eestart hD3 _eewrite  \ [SDO = VDD]
\	_L3Gs _eestart hD1 _eewrite \ [SDO = GND]
	if h45 ERR then ;
\ _L3Gw8      ( u8 Addr -- ) \ write one byte
: _L3Gw8        _L3Gs _eewrite or _eestop ;
: _L3Gr8        _L3Gr -1 _eeread _eestop ;
: _L3Gr88       _L3Gr 0 _eeread -1 _eeread _eestop ;
\ _L3Gr16    ( addr -- u16) \ int is Hi Lo
: _L3Gr16int    _L3Gr 0 _eeread 8 lshift -1 _eeread or _eestop ;
\ _L3Gr16xyz ( addr -- u16 ) \ xyz are lo hi
: _L3Gr16xyz _L3Gr 0 _eeread -1 _eeread 8 lshift or _eestop ;
\ _L3G.ID ( -- chipid_version:11010011 hD3  d211)
: _L3G.ID h0F _L3Gr8 ;
\ : L3G.WHO_AM_I      h0F    ; \ readonly = xD3 
: L3G.CTRL_REG1     h20   ; \ default = x07
: L3G.CTRL_REG2     h21   ; \ default = x0 
: L3G.CTRL_REG3     h22   ; \ default = x0
: L3G.CTRL_REG4     h23   ; \ default = x0
: L3G.CTRL_REG5     h24   ; \ default = x0
: L3G.OUT_TEMP      h26    ; \ readonly
: L3G.STATUS_REG    h27    ; \ readonly
: L3G.OUT_X_L       h28    ; \ readonly
: L3G.OUT_X_H       h29    ; \ readonly
: L3G.OUT_Y_L       h2A    ; \ readonly
: L3G.OUT_Y_H       h2B    ; \ readonly
: L3G.OUT_Z_L       h2C    ; \ readonly
: L3G.OUT_Z_H       h2D    ; \ readonly

: autoINC h80 or ;




: autoINC h80 or ;

\  temperature is 1 C per digit 
\ 0 =-40C 125 = 85c
\  60D = h3C = 20C = expected test reading in the lab = h3C (3A-3F)
\ @L3G.xyz16 ( - temperature8 status8 x16 y16 z16 FIFO_src ) \ low, high
: @L3G.xyz16 L3G.OUT_TEMP autoINC
\             hA6 
             _L3Gr 
             0 _eeread                    \ temperature 
             0 _eeread                    \ status    
             0 _eeread 0 _eeread 8 lshift or \ x
             0 _eeread 0 _eeread 8 lshift or \ y
             0 _eeread 0 _eeread 8 lshift or \ z
             0 _eeread  drop \ FIFO ctl
            -1 _eeread \ FIFO src
   \ If FIFO, not used, remove last two
;

\ _U16signed32 ( U16 -- s32) convert unsigned word to signed long
: _U16signed32 dup h8000 and if hFFFF0000 or then ;









: !L3G8 _L3Gw8 ; \  MAYBE!!!!!!!
\ this section define setting any setable registers
\ : !L3G.WHO_AM_I      h0F    ; \ readonly = xD3 
: !L3G.CTRL_REG1     h20 !L3G8   ; \ default = x07
: !L3G.CTRL_REG2     h21 !L3G8  ; \ default = x0 
: !L3G.CTRL_REG3     h22 !L3G8  ; \ default = x0
: !L3G.CTRL_REG4     h23 !L3G8  ; \ default = x0
: !L3G.CTRL_REG5     h24 !L3G8  ; \ default = x0

: L3G.CONFIGURE

  b0000_1111 !L3G.CTRL_REG1 \ min speed, power on
  b0010_0111 !L3G.CTRL_REG2 \ normal 200Hz  0.1
  b0000_0000 !L3G.CTRL_REG3 \ idsable interupts (default)
  b0000_0000 !L3G.CTRL_REG4 \ continuous, LSB lowest, CHECK FULL SCALE
  b0000_0000 !L3G.CTRL_REG5 \ boot, no FIFO, no HiPass, def INT 
;

: L3G.start
           L3G.CONFIGURE
;


: L3G4200D!
            L3G.OUT_TEMP 
            autoINC
            _L3Gr  
             0 _eeread                    \ temperature 
             0 _eeread                    \ status    
             0 _eeread 0 _eeread 8 lshift or \ x
             0 _eeread 0 _eeread 8 lshift or \ y
             0 _eeread 0 _eeread 8 lshift or \ z
             0 _eeread  drop \ FIFO ctl
            -1 _eeread \ FIFO src
          drop           \ dont need fifo 
          L3G4200D 8 + W!  \ z
          L3G4200D 6 + W!   \ y
          L3G4200D 4+ W!   \ x
          L3G4200D 2+ W!   \ stat
          L3G4200D W!      \ temp
;


: L3G4200D@
          
          L3G4200D 8 + W!   \ z
          L3G4200D 6 + W!   \ y
          L3G4200D 4+ W!   \ x
          L3G4200D 2+ W!   \ stat
          L3G4200D W!      \ temp
;



\ **************************************************************

\ do.GY80 does the driver in a background cog
: do.GY80
        4 state andnC!
        c" GY80-driver" cds W! \ text displayed by cog?
        ADXL.default
     \  BMP085
        HMC5883L.config
     \  L3G4200D.config
        begin
            ADXLrXYZ!
            BMP085!
            MMC5883L!
           L3G4200D!  
        0 until
        \ 
;

\ start.GY80 starts the  background driver cog
: start.GY80 c" do.GY80 " nfcog cogx 1000 delms cog? ;

{
\ **************************************************************
\ END of DRIVERS
\ The remainder of the code is for UI,
\ **************************************************************
}
{ 
\ **************************************************************
  ansi stuff
\ **************************************************************
}

: esc h_1B emit ;
: csi esc h_5B emit ;
: m ." m" ;    
: smallf ." f" ; 
: K ." K" ;
: semicolon ." ;" ;
: v>c h_30 + emit ;
: .digits dup h_9 > if h_0A u/mod v>c then v>c ;
: AT csi .digits semicolon .digits smallf ;
: home       csi ." 1;1f" ;
: clear      csi ." 2J" ; 
: preclear   csi ." 1J" ;
: postclear  csi ." 0J" ;
: cls home clear  ;
: clear-eol  csi h_0 .digits K ;
: clear-bol  csi h_1 .digits K ;
: clear-line csi h_2 .digits K ;

{
  terminal display section
}
: (signed) dup h8000 and if hFFFF0000 or then ;
: .ADXL
            7 5 AT ." ADXL X            Y           Z            ACCEL " 
           15 5 AT  ADXL.XYZDATA    W@ (signed) . 3 spaces \ clear-eol 
           27 5 AT  ADXL.XYZDATA 2+ W@ (signed) . 3 spaces \ clear-eol 
           39 5 AT  ADXL.XYZDATA 4+ W@ (signed) . 3 spaces \  clear-eol 
;

: .BMP085
          BMP085@ 
          2 2 AT ." BMP085 temp(C/10)        hPa "
          swap
          20 2 AT   .  3 spaces 
          33 2 AT   .  3 spaces 
;

: .MMC5883L  \ HMC5883L
       2 6 AT ."  HMC5883L x            y           z            MAG "
      15 6 AT  HMC5883L W@ (signed) . 3 spaces
      27 6 AT  HMC5883L 2+ W@ (signed) . 3 spaces
      39 6 AT  HMC5883L 4 + W@ (signed) . 3 spaces
;

: .L3G4200D
       2 3 AT  ." LL3G4200D TempC          stat  "
       2 4 AT  ." LL3G4200D x            y           z            GYRO  "
      15 4 AT  L3G4200D 4+ W@ (signed) . 3 spaces \  clear-eol 
      27 4 AT  L3G4200D 6 + W@ (signed) . 3 spaces \  clear-eol 
      39 4 AT  L3G4200D 8 + W@ (signed) . 3 spaces \  clear-eol 
      20 3 AT  L3G4200D  W@ (signed) . 3 spaces \  clear-eol 
      33 3 AT  L3G4200D 2+ W@ (signed) . 3 spaces \  clear-eol 
;



\ This is a diagnostic that displays the AXDL data in the foreground cog session
: GY80
      cls 2 8 AT start.GY80
      begin 
            .ADXL
            .BMP085
            .MMC5883L
            .L3G4200D
     fkey? if h1B = else drop 0 then until 
;

\ GY80


}}}


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages