#summary GY-80 IMU. I2C

<wiki:toc max_depth="9" />

= GY-80 Inertial Measurement unit =

The GY-80 is a very inexpensive 10DOF inertial measurement unit.

I got mine off Ebay for about $50, it was insanely cheap at the time.  Now they are going for about $14.  Be aware that these might be rejects or in some way defective.  They still work and are fun to play with, and are fine for experimentation purposes.  

There are newer parts on the market that are more capable and possibly cheaper.  Some have upgraded versions of these parts, so potentially there are drop-in replacements and the same code works.  CHECK THE DATA SHEET, as always!

= Uses =

IMU is handy for measuring changes in speed and position (inertia).  If we know speed and direction, we can determine our position in relation to a known point, such as our starting point.  If we have no other information, we can call this "dead reckoning" or "deduced reckoning".

We can use this for Robo-Magellan, or Quad Copter navigation and control. 

NOTE:  GPS is separate from this IMU, we can add GPS later. 

= GY-80 sensors =

The parts are 
 * ADXL345 accelerometer
 * BMP085 barometric pressure sensor
 * HMC5883L magnetometer (Compass)
 * L3G4200D gyroscope

The accelerometer, gyroscope, and magnetometer all are 3 axis. 

 * [ADXL345]
 * [BMP085]
 * [HMC5883L]
 * [L3G4200D]

= GY80 Application = 

The GY80 can be organized as several parts.

 * the low level drivers for the four sensors
 * the initialization of the sensors at power up
 * ANSI terminal support for the terminal (android device) character base user interface (UI)
 * The terminal interface display
 * The display support for each sensor data
 * The real time click support
 * the Data Logger
 * the Kalman filter to determine our current position and orientation in space using "dead reckoning"
 * the PID loop to orient a bot with respect to position and gravity
 * the navigator to tell the bot the sequence of position and orientation to achieve.

The program code was (is being) developed in the order presented above.  Each item was completed before moving on to the next item in the lost.  When a new item was completed, the previous items were checked, to ensure new code did not disrupt existing code.  Also new discoveries (a better way to do something) were applied to the old code, and the changes were retested in the same manner. 

The result of the method is we go over the first part a zillion time, because the first part is re-checked after any new part is integrated. Even so there is still room for improvements. Some functions could be standardized across all parts. Some functions where standardization was attempted should NOT be standardized, maybe, because the part is "just different". You are free to make any changes and offer suggestions if you are pleased with the result. 


= I2C =

The GY-80 uses  [I2C] bus  to talk with the microprocessor.  There are actually FOUR I2C bus parts on the GY-80. The use the same [I2C] wires and commands that we already use to talk to the EEPROM, so support is already built into the kernel for  free. Neet!

I2C is explained in detail elsewhere. PropForth has built-in support for the EEPROM, so I2C "just works".  But we still have to understand I2C a bit to grasp whats going on in the drivers. 

 * PropForth shifts a value out the I2C lines.  This is the address of one of the parts. 
 * The part acknowledges. (by shifting back a particular number) 
 * PropForth sends the address of one of the part's registers.  
 * The part acknowledges. 
 * PropForth sned a number code to either Reads or writes the register.  
 * The part sends or receives the data.  
 * PropForth send a No-Acknowledge (a special number) to tell the part we are done. 

That's all there is to it. 

= GY-80 driver =

The individual drivers are combined into a single module.

One cog tends all I2C bus devices, by reading their data, and dropping it into HUB RAM. (COMPLETED)

The foreground cog reads the current values from RAM, and displays the sensor output data as simple text on the display. (COMPLETED)

Other cogs can send the RAM data to SD, or process the data for example with a Kalman filter.  (IN PROGRESS)

== GY-80 driver Simple: data values displayed as numbers  ==

Just display the data values 

Forth source code for GY80 simple driver (COMPLETED)

Click the link to download the Forth source code from Google Drive 

*[https://drive.google.com/file/d/0B8d8RsrY7Rt-dmQyellLcGVrQzQ/ GY-80 driver - simple]

Cog 7 runs the terminal serial driver 
Cog 6 is the user command line
Cog 5 loaded the code, now is is idle and available
Cog 4 was the next free cog during load, and is assigned reading the I2C bus to query the sensors. 

The remaining cogs are available

The devices are being read at the speed of the I2C bus (400Khz) 

The display is being updated at 230400 baud.  I believe the display is only showing a portion of the data, because the data is updated faster than the display is receiving. 

== GY-80 driver Graph: Data values displayed as magnitude vectors on a a graph ==

Display with a retro ANSI character graphics display (COMPLETE)

Click the link to download the Forth source code from Google Drive 

*[https://drive.google.com/file/d/0B8d8RsrY7Rt-Mnp5VnpoSEFQZ2M GY-80 Graph Simple]

NOTE this version is optimized to display on Samsung Captivate Glide in landscape orientation. Change the AxisLength parameter to display in a larger terminal 

== ~~GY-80 driver Logging: write the data values to a 4Gig SD card for online analysis ==

Log to SD

IN PROGRESS

The logger includes 64 bit time stamps based on the prop 32 bit internal counters. At 80Mhz, the counter rolls over about every 57 seconds.  Using the additional 32bit long allows unique times stamps with 12.5ns resolution for about 7,133 years.  Typically we can only log events several times a second.  The result is every data logged should have a unique time stamp, no matter how many loggers we have running. (If we started logging on every Prop chip ever made, or started two identical applications at exactly the same time,  we MIGHT see records with the same time stamp.  This seems unlikely, and we have not observed any collision yet).  


== ~~GY-80 driver Logger with Graphics  ==


Log to SD also display the graph on terminal screen (including Android over Bluetooth)


INCOMPLETE

Ran out of Hub memory due to too many diagnostics, etc. 

I still plan to try a grapphic dispplay while logging.  I might weed out some extraneous functions.  Or I might have to remove the Altimeter function from the BMP085.


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages