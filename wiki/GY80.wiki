#summary GY-80 IMU. I2C

<wiki:toc max_depth="9" />

= GY-80 Inertial Measurement unit =

The GY-80 is a very inexpensive 10DOF inertial measurement unit.

I got mine off Ebay for about $50, it was insanely cheap at the time.  Now they are going for about $14.  Be aware that these might be rejects or in some way defective.  They still work and are fun to play with, and are fine for experimentation purposes.  

There are newer parts on the market that are more capable and possibly cheaper.  Some have upgraded versions of these parts, so potentially there are drop-in replacements and the same code works.  CHECK THE DATA SHEET, as always!

= Uses =

IMU is handy for measuring changes in speed and position (inertia).  If we know speed and direction, we can determine our position in relation to a known point, such as our starting point.  If we have no other information, we can call this "dead reckoning" or "deduced reckoning".

We can use this for Robo-Magellan, or Quad Copter navigation and control. 

NOTE:  GPS is separate from this IMU, we can add GPS later. 

= GY-80 sensors =

The parts are 
 * ADXL345 accelerometer
 * BMP085 barometric pressure sensor
 * HMC5883L magnetometer (Compass)
 * L3G4200D gyroscope

The accelerometer, gyroscope, and magnetometer all are 3 axis. 

 * [ADXL345]
 * [BMP085]
 * [HMC5883L]
 * [L3G4200D]

= GY80 Application = 

The GY80 can be organized as several parts.

 * the low level drivers for the four sensors
 * the initialization of the sensors at power up
 * ANSI terminal support for the terminal (android device) character base user interface (UI)
 * The terminal interface display
 * The display support for each sensor data
 * The real time click support
 * the Data Logger
 * the Kalman filter to determine our current position and orientation in space using "dead reckoning"
 * the PID loop to orient a bot with respect to position and gravity
 * the navigator to tell the bot the sequence of position and orientation to achieve.

The program code was (is being) developed in the order presented above.  Each item was completed before moving on to the next item in the lost.  When a new item was completed, the previous items were checked, to ensure new code did not disrupt existing code.  Also new discoveries (a better way to do something) were applied to the old code, and the changes were retested in the same manner. 

The result of the method is we go over the first part a zillion time, because the first part is re-checked after any new part is integrated. Even so there is still room for improvements. Some functions could be standardized across all parts. Some functions where standardization was attempted should NOT be standardized, maybe, because the part is "just different". You are free to make any changes and offer suggestions if you are pleased with the result. 


= I2C =

The GY-80 uses  [I2C] bus  to talk with the microprocessor.  There are actually FOUR I2C bus parts on the GY-80. The use the same [I2C] wires and commands that we already use to talk to the EEPROM, so support is already built into the kernel for  free. Neet!

I2C is explained in detail elsewhere. PropForth has built-in support for the EEPROM, so I2C "just works".  But we still have to understand I2C a bit to grasp whats going on in the drivers. 

 * PropForth shifts a value out the I2C lines.  This is the address of one of the parts. 
 * The part acknowledges. (by shifting back a particular number) 
 * PropForth sends the address of one of the part's registers.  
 * The part acknowledges. 
 * PropForth sned a number code to either Reads or writes the register.  
 * The part sends or receives the data.  
 * PropForth send a No-Acknowledge (a special number) to tell the part we are done. 

That's all there is to it. 

= GY-80 driver =

The individual drivers are combined into a single module.

One cog tends all I2C bus devices, by reading their data, and dropping it into HUB RAM. (COMPLETED)

The foreground cog reads the current values from RAM, and displays the sensor output data as simple text on the display. (COMPLETED)

Other cogs can send the RAM data to SD, or process the data for example with a Kalman filter.  (IN PROGRESS)

== GY-80 driver Simple: data values displayed as numbers  ==

Just display the data values 

Forth source code for GY80 simple driver (COMPLETED)

Click the link to download the Forth source code from Google Drive 

*[https://drive.google.com/file/d/0B8d8RsrY7Rt-dmQyellLcGVrQzQ/ GY-80 driver - simple]

Cog 7 runs the terminal serial driver 
Cog 6 is the user command line
Cog 5 loaded the code, now is is idle and available
Cog 4 was the next free cog during load, and is assigned reading the I2C bus to query the sensors. 

The remaining cogs are available

The devices are being read at the speed of the I2C bus (400Khz) 

The display is being updated at 230400 baud.  I believe the display is only showing a portion of the data, because the data is updated faster than the display is receiving. 

== GY-80 driver Graph: Data values displayed as magnitude vectors on a a graph ==

Display with a retro ANSI character graphics display (COMPLETE)

Click the link to download the Forth source code from Google Drive 

*[https://drive.google.com/file/d/0B8d8RsrY7Rt-Mnp5VnpoSEFQZ2M GY-80 Graph Simple]

NOTE this version is optimized to display on Samsung Captivate Glide in landscape orientation. Change the AxisLength parameter to display in a larger terminal 

== GY-80 logger with and without  graphic display - FANCY ==

https://drive.google.com/file/d/0B8d8RsrY7Rt-VTJIOElVM3lHblU/edit?usp=sharing

PROPFORTH GY-80 IMU drivers and datalogger

This is phase 1 of the Propforth IMU project.

INSTRUCTIONS

 * Hardware:
 * - Quickstart or other Prop board (Parallax P8X32A)
 * - SD card - I'm using pins 16-21 as on Spinneret (default)
 * - GY-80 - connected on EEPROM pins SDA and SCL
 * (optional) HC05 blue tooth serial cable replacement (for Android as interface)
 * Software - SD kernel
Load propforthSD kernel (.spin) using PropTool etc as usual
 * Start the  terminal emulator program in the usual manner (described elsewhere) 
 * COPY/PASTE the following source code files into the terminal window in the usual manner (described elsewhere)  
 * The file:

      `00-sdfsInitScript.f`

only needs be pasted in once, this initializes and setsup the SD card.
If you wish to delete the SD card contents (e.g. to start over clean)
reboot and paste this file into the terminal again. 

 * These files may be copy/pasted into the terminal in their entirety:

      `11-DoubleMath.f`

      `12-time.f`

 * This file creates all the driver files for the GY-80

       `13- GY80-load D Application 20140608-1331 logger Graph FINAL.f`

NOTICE that the file has many comment lines with 

{{{
\ fl
}}}

and that these come before each driver file definition. This is so you can re load individual drive files,
without having to erase the cared and start over every time you try a change. 
BEGIN the copy operation with the "`fl`" (do not include the comment designator "`\`" )
and paste the modified code into the termnal window as  usual.

 * - This file creates logboot.f on the SD card

       `15-loggerBootDailyFiles-GY-80-20140612-0001 LOGGER signed FASTER4- FINAL.f`

 * - This file creates graphboot.f on the SD card

      `17-loggerBootDailyFiles-GY-80-20140614-1445 GRAPH-signed.f`

NOTICE - you only need one or the other of logboot.f or graphboot.f

*`logboot.f` loads the drivers for GY-80 (`BMP085, ADXL345, L3G4, HCM5883`) and for TIME (doublemath.f and time.f)
`logboot.f` does NOT include altimeter support

*`graphboot.f` loads the drivers for GY-80 (`BMP085, ADXL345, L3G4, HCM5883`) and for the character based data graphing routines
`graphboot.f` does NOT include time support

(Sorry, there was't enough room for both without optimization in assembler, that is a later step)

 * Load and run the application:

select either of the following:

===*for logboot.f*===

`reboot` - to clear the system

`fload logboot.f`   - to autoload all the drivers in the correct order

`GY-80` - starts the non graphic numberic terminal display.  exit with the ESC key or reboot

`mountusr ls`  - mount the user data particion, and list the files

`fread IMU2012-01-01` - display the contents of the default log file

`2014 12 17 13 59 00 setLocalTime`   -  set the time to December 17 2014, 1:59 PM; this creates a new logfile

`fread IMU2014-12-17` - display the contents of the 

===*for graphboot.f*===

`reboot` - to clear the system

`fload graphboot.f`   - to autoload all the drivers in the correct order

`GY-80` - starts the terminal graphic display.  exit with the ESC key or reboot

`mountusr ls`  - mount the user data particion, and list the files

`fread IMUnoTIMExxxx` - display the contents of the loag file


=== GY-80 driver Logging: write the data values to a 4Gig SD card for offline analysis ===

Log to SD

https://drive.google.com/file/d/0B8d8RsrY7Rt-VTJIOElVM3lHblU/edit?usp=sharing

The logger includes 64 bit time stamps based on the prop 32 bit internal counters. At 80Mhz, the counter rolls over about every 57 seconds.  Using the additional 32bit long allows unique times stamps with 12.5ns resolution for about 7,133 years.  Typically we can only log events several times a second.  The result is every data logged should have a unique time stamp, no matter how many loggers we have running. (If we started logging on every Prop chip ever made, or started two identical applications at exactly the same time,  we MIGHT see records with the same time stamp.  This seems unlikely, and we have not observed any collision yet).  


=== GY-80 driver Logger with Graphics ===


Log to SD also display the graph on terminal screen (including Android over Bluetooth)

https://drive.google.com/file/d/0B8d8RsrY7Rt-VTJIOElVM3lHblU/edit?usp=sharing

Ran out of Hub memory due to too many diagnostics, etc. 

Ended up removing the TIME SUPPORT and adding back the altimeter.


<end>