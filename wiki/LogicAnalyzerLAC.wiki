#summary LAC is the software logic analyzer in propforth
#labels v5.5,Quickstart,LAC,logicanalyzer


<wiki:toc max_depth="9" />


= Logic Analyzer  =

This a a supplement for `PropForth-V5.5-20130317.zip/V5.5/doc/PROPFORTH.HTM` section 5 !LogicAnalyzer

Logic Analyzer reports the pin states, hi or low, for a specific time after a specific event.  This handy for real time control, where timing is critical. A logic analyzer is like very fancy expensive oscilloscope.  LAC is a little cheaper, and can be just as effective.

LAC is a software program that uses one or more cogs to report the state of the prop pins form a given time for a certain duration.  

The sampling period can be triggered by pin transition, or by an operator event. 

The forth script lac.f is located at `PropForth-V5.5-20130317.zip/V5.5/CurrentRelease/Extensions/lac.f`

= Setup =

Summary: Load the propforth kernel, load the lac.f extension.

== PC - Windos XP ==

Install and launch the Proptool

Connect the Quickstart to the PC with a USB cable

After the device is registered, Use F7 to ensure the USB COM port is found.

== Load a kernel ==

use the prop tool to open

`PropForth-V5.5-20130317.zip/V5.5/CurrentRelease\CurrentRelease\PropForth\` 
`DevKernel.spin`

Use F11 to compile and load the kernel into EEPROM

== Load lac.f ==

in your text editor, open
`PropForth-V5.5-20130317.zip/V5.5/CurrentRelease/Extensions/lac.f`

highlight the entire contents of the file `(CTL^A)`

copy it `(CTL^C)`

paste it into the teraterm window with the propforth command line (right mouse)

== save image to EEprom ==

Use saveforth to save the current dictionary image (which now inclides LAC) to EEprom

{{{
Prop0 Cog6 ok
saveforth
}}}

response will be
{{{
.............................................................................................................................................
Prop0 Cog6 ok
}}}

When the prop is power cycled or rebooted, the LAC definitions will still be present.

== To Remove LAC ==

To get rid of LAC, use forget build_LogicAnalyzer and do saveforth again, or simple reburn devkernel.spin using proptool.   For now, leave lac in EEprom, as we will reboot several times during the investigation. 

= Using LAC =

Read `PropForth-V5.5-20130317.zip/V5.5/doc/PROPFORTH.HTM` section 5 !LogicAnalyzer

 == LAC Parameter control ==

NOTE:  You can issue invalid command sequences to LAC.  There is no particular error checking on command input, it will perform what ever command(s) you issue. This makes it very powerful, but also easy to screw up.  It is the operators responsibility to issue correct commands.  If something goes wrong or starts acting strange, just reboot.  Typically, we reboot quite often during the investigation and development phase,  don't be afraid to reboot often. 

  === Trigger Pin      -q    +Q: 0 ===

LAC will look at this pin (can be 0 to 31) for a transition.  The transition will start the sampling process. 

Pressing `q` will decrement the pin number

Pressing `Q` will increment the pin number

This field has limits of 0 and 31.   It also can display `NONE` after the SPACE key is pressed. 

If the trigger pin displays as NONE and will not increment or decrement, restart lac. (LAC has to be small to fit in with an application, changing this would increase dicationary foot print, and would cost a lot of memory space)

  ===  Trigger Edge -w +W SPACE ===

This is for rising edge, fall edge, or NONE. 

`w`  lower-case w selects falling edge. Start collecting the sample when the pin transitions from HIGH to low.  Used when a pin is changing at some frequency


`W` upper-case W selects  rising edge.  Start collecting the sample when the pin transitions from LOW to high.  Used when a pin is changing at some frequency

SPACE selects NONE.  Just start collecting the sample when the ENTER key is pressed.  Used when the pin is changing from a manual or other external non frequency event. 

If trigger edge displays NONE and will not change to the rising or falling glyph,  restart lac.

  === Trigger Frequency         eE :  ===

Before a trigger pin is sampled  or when no trigger pin is designated, the trigger frequency display is blank. 

LAC attempts to determine the frequency of the input pin by detecting it for 250 milliseconds. This detects frequency below 1/250ms or 1/0.250 seconds.  So, `e` is for detecting signal below 4 Hz.

When `E~ upper case E is selected, it looks at the pin for about a second.  This is used for detecting 1 Hz or below.  If signal changes slower than 1 time persecond, LAC treats it as if the trigger frequency were set to NONE. 

`Trigger Frequency         eE : NO TRIGGER FOUND`

Selecting `e` set the interval back to 250ms (the default). 

If the trigger frequency displays NONE and will not change to the rising or falling glyph,  restart lac.  Also, the specified input pin might not be toggling fast enough for lac to register a frequency. Check that you are looking at the correct pin, and you've started it toggling. Also check the way you control the frequency. I find that often the problem is I didn't set this part up correctly. 

   === Sample Interval -asdfg +ASDFG: 500.0 nS             40 clock cycles === 

OK, this one is a bit complex.

The samples are taken every so many cycles. 

a - decrement the cycles by 1
s - decrement the cycles by 10
d - decrement the cycles by 100
f - decrement the cycles by 1000
g - decrement the cycles by 10,000

G - increment the cycles by 10,000
F - increment the cycles by 1,000
D - increment the cycles by 100
S - increment the cycles by 10
A - increment the cycles by 1

If the sample is specified as 1 (one clock cycle, sample every clock cycle) lac has to shift into extreme  mode and do things differently:  It begins to use cogs 2, 3, 4 and 5 to collect the sample, and save these in cog memory.  If you (accidentally) hit any of the unshifted (lower-case) keys asdfg, you have a good change of forcing lac to shift to this mode.   This can really mess up lac if the other parameters are set for longer samples, etc.   BE CAREFUL.  If the display says 1 clock cycle, and you don't want one cycle, you need to reset and start over.  Until you get used to this, you might have to restart a few times.  (Don't even ASK me how I know). 

We can also set the sample interval very long. Each column in the sample display is one long (two words) that contains the state of the pins at integer multiples of the sample interval clock cycles. Each horizontal demarcation has 16 samples, there are eight (8) demarcations in the sample display.  So there are 16 * 8 samples or 128 samples displayed.  At 40,000 cycles, it takes almost a full second to collect the sample (on a stock crystal running at 80Mhz).  

If you set the clock cycles higher than 40,000,; and hit the enter key a bunch of times, you will have to wait oa long time for the samples to be collected and the display to update.  It looks like the screen has frozen, but its not, it just doing like you asked. 

Mess around with this and get a feel for the impact of the various keys and settings. 

  === Sample < ENTER > ===

The ENTER key triggers sampling.  

That is, when the enter key is pressed, lac looks at the trigger pin and waits how the transition event, if specified; or begins sampling immediately if NONE is specified.  One sampling cycle consists of the trigger event, then one sample every N clock cycles as specified in sample interval.  This continues until the display is populated, or the buffer (all unallocated memory) is used up (Check if this is still the case?). 

 === Quit < ESC > ===

Hit the ESCAPE key to exitt LAC. LAC will terminate immediately if it is not sampling.  If lac is in the process of sampling, for example a very long sample interval, and/or multuiple enter key presses in the keyboard input buffer, it not terminal until the sampling is complete.  This can take a very long time if you set it up correctly (or incorrectly depending on your intent). 

Mess with this until you get a feel for when it quits quickly and when you have to wait. 


    ===  Sample Display  -zxcv  +ZXCV :      clock cycles of    193  ===

What could this mean? 

LAC samples the pins states, and stores these as LONG values in HUB ram (or COG RAM if set to 1 cycle).  So it dumps the sampes into unused memory until it runs out of memory, until it runs out of memory, or another sampling event begins. LAC only displays 128 samples on the display; otherwise the display would have to deal with scrolling left and right, and/or other complex and messing things.  So it just displays 128 samples, which is what we decided it could throw onto the display with no extra coding.  

The keys zxcv and ZXCV control which samples we are looking at. 

To look at the samples AFTER the first 128, 

z - begin display one sample later (to the right)
x - begin display ten samples later (to the right)
c - begin display one hundred samples later (to the right)
v - begin display one thousand samples later (to the right)

V -  begin display one thousand samples earlier (to the left)
C -  begin display one hundred samples earlier (to the left)
X -  begin display ten samples earlier (to the left)
Z -  begin display one sample earlier (to the left)

So the window display shifts left or right through the sample set. 

NOTICE that with just LAC loaded, there are 193 samples total. 

193 samples total minus 128 samples displayed  equals 65 samples not displayed.  So the most the display can shift is 65 samples. 

    ====  Question ====

With devkernel.spin loaded, and lac.f loaded and save to EEprom with saveforth, I run `free`

{{{
Prop0 Cog6 ok
free
11030 bytes free - 176 cog longs free
Prop0 Cog6 ok

}}}

I think that 11030 bytes divided by 4 equals 2757 longs free.  So I should have 2757 samples.  Why are there only 193?  

Is it because this is all it can do before the next sample time? 

   ==== Investigate ==== 

  * Change the clock cycles sample interval.  
  * Change the trigger from pin to NONE.  
  * Change the frequency of the trigger  pin toggle.

 === The Logic Analyzer Display ====

Along top of the display are eight column headers.  These are integer multiples of the sample interval clock cycles, in (prefix)seconds. The column headers automagically display prefixes for the seconds in nano seconds, microseconds, and milliseconds. (That's kind of cool, how does he do that?)

Along the left side of the display are listed the I/O PIN numbers 31 down to 0.  

The column headers are repeated every four I/O pin lines, and have a white space line above and a white space line below the interval headers.  (Can we remove the whitespace?  Can we change the number of times the column headers are displayed? I would want to t troy remopving the whitesapce, and only display the colume headers three times, once at the top, once in the middle, and once at the bottom. Then I would change my mind.) 

Each column in the sample display is one long (two words) that contains the state of the pins at integer multiples of the sample interval clock cycles. Each horizontal demarcation has 16 samples, there are eight (8) demarcations in the sample display.  So there are `16 * 8 samples or 128 ` samples displayed. 


  === Adjust the LAC display format ===

My screen is too  small to display all the LAC lines on one screen. The font can be reduced, but then the characters are too small to read comfortably (my eyes are getting bad).  An option is to reduce the whitespace on the LAC display.

This involves editing  and reloading the LAC source code.  Be sure to RE-BURN THE EEprom if you did SAVEFORTH, or you might get confused when you changes disappear. 

 ==== LAC Parameter Header ====

By default, the LAC top header display one parameter per line.  After we get used to this, we can try cramming multiple parameters on one line. 

The function `crcl` clears to the end of line and prints a carriage return for hear formatting.  Find this and you can adjust the hear display. 

LAC.f Line 558 is the function  `_lac_h` which displays the lac header.

This comment removes the blank line bfore the first parameter line.  I copy the original line, comment it out, and edit the copy.  

{{{  
\	hm crcl
	hm 
}}}

This comment puts Trigger Pin and Trigger Edge on th. same line.  Again, I copied the original line, commented out the oringinal line, and editied the copy.  Here I replaced `crcl` with `space`.

{{{  
\\	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then crcl
	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then space
}}}

This saved me two lines, its a start. Play with the formatting of the remaining header items. 

 ==== LAC intermediate column headers ====

lac.f line 636 is the main function.

lines 655 and 662 (after I've been editing) put the column marker line in the display.  I commented out both out these

{{{
\				_lacv       \ white space
}}}

Lines 664 and 671 (after I've been editing) control the number of I/O lines that are displayed under each intermediate colum header line.  Every four lines cost too much space so I tried 8.  Eight lines is a little more than an eyeful in one glance, but it save a bunch of space and its not too bad once you get used to it. 

{{{
\\				i h4 bounds
				i h8 bounds
				do
					h1F i - dup <# # # #> .cstr
					_la_current W@ swap _la_displayPin
					crcl
				loop
\\			h4 +loop
			h8 +loop
}}}

After making the changes, save the source file (with a new name if you want to retain the original).  I saved it as `lac-whitespace.f`.

  ==== the reformatted display ====

Now my lac display looks like this:

{{{
    Trigger Pin      -q    +Q: 0     Trigger Edge   -w +W SPACE: __--
Trigger Frequency         eE :                 
Sample Interval -asdfg +ASDFG: 500.0 nS             40 clock cycles
         Sample     <ENTER>
         Quit         <ESC>
Sample Display  -zxcv  +ZXCV :                 clock cycles of             193 
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
31--------------------------------------------------------------------------------------------------------------------------------
30--------------------------------------------------------------------------------------------------------------------------------
29--------------------------------------------------------------------------------------------------------------------------------
28--------------------------------------------------------------------------------------------------------------------------------
27________________________________________________________________________________________________________________________________
26________________________________________________________________________________________________________________________________
25________________________________________________________________________________________________________________________________
24________________________________________________________________________________________________________________________________
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
23________________________________________________________________________________________________________________________________
22________________________________________________________________________________________________________________________________
21________________________________________________________________________________________________________________________________
20________________________________________________________________________________________________________________________________
19________________________________________________________________________________________________________________________________
18________________________________________________________________________________________________________________________________
17________________________________________________________________________________________________________________________________
16________________________________________________________________________________________________________________________________
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
15________________________________________________________________________________________________________________________________
14________________________________________________________________________________________________________________________________
13________________________________________________________________________________________________________________________________
12________________________________________________________________________________________________________________________________
11________________________________________________________________________________________________________________________________
10________________________________________________________________________________________________________________________________
09________________________________________________________________________________________________________________________________
08________________________________________________________________________________________________________________________________
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
07________________________________________________________________________________________________________________________________
06________________________________________________________________________________________________________________________________
05________________________________________________________________________________________________________________________________
04________________________________________________________________________________________________________________________________
03________________________________________________________________________________________________________________________________
02________________________________________________________________________________________________________________________________
01________________________________________________________________________________________________________________________________
00________________________________________________________________________________________________________________________________

}}}

Much more to my liking.  It fits on the minicom terminal display screen without scrolling off the edges, and the font can be big enough to be readable.  A little work, but at least I don't have to buy a new monitor just yet.

= The Examples in `PropForth.htm` Section 5 =

At this point, we have :
 # `Devkernel.spin` loaded on the quickstart
 # `lac.f` (or our modified version) loaded via pasting  the source code into the terminal. 
 # 'lac' (the the routine defined in `lac.f`) is saved to EEprom via `saveforth`, so it will still be available after `reboot` or powercycle
 # !PropForth.htm  open in a browser window.

 == The first example ==

Now load the example code from sectin 5:

{{{
\ pinIncrementer( n1 ) increment 8 pins starting at pin n1
: pinIncrement
  hFF over lshift dira COG!
  0 begin
    1+ 2dup swap lshift outa COG!
  0 until
;

c" 0 pinIncrement" 0 cogx

lac

}}}

 === trace throught the example ===

What is `pinIncrement` really doing? Lets look at the stack as each function executes.

*start* \  this is what the stck looks like when the routine is first called
  * Stack0: 0 \starting pin# to toggle

*hFF* \   hFF is a literal in hexadecimal (h is the prefix)
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle

*over* \   copies the value BELOW the top of stack (and puts it on the top of the stack)
  * Stack2: 0 \Stack0 copied to the Top Of Stack (TOS)
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle

*lshift* \  shift 255 left 0 bits. Has no effect, but if the toggle pin were 8, it would shift 255 left 8, and the result would be a bit mask starting as pin 8.
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle


*dira*  \  this is the LOCATION of the register that specifies pin inputs and out puts.  1's are outputs, 0's are inputs.
  * stack2: $dira (address of dira)
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle

*COG!* \  this stores a value at the location given.  In this case the location is dira, and the value is FF, the firs 8 pins are ONES
  * Stack0: 0 \starting pin# to toggle

*0*  \  seed valut for the begin loop that's next
  * Stack1: 0 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*begin*  \  start a unbounded loop. The LAC loop runs with no predetermined end
  * Stack1: 0 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle
    
*1+*  \  add one to the loop seed value. This is what does the incrementing (toggling) for the pinIncrement function.
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*2dup*  \  
  * Stack3: 1 \ begin loop seed value copy
  * Stack2: 0 \starting pin# to toggle copy
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*swap*  \  switch the positions of the top two stack values
  * Stack3: 0 \ starting pin# to toggle copy
  * Stack2: 1 \ begin loop seed value copy
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*lshift* \  here, we shift counted number to the start pin number 
  * Stack2: 1 \ toggle value for setting the bit patterns
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*outa*  \  this is the LOCATION of the register that specifies pin  output states.  1's are highs, 0's are lows. Pin must also be configured as outputs by the dira register (we did this before the loop started)
  * Stack3: $outa1 \ address of the out resister
  * Stack2: 1 \ toggle value for setting the bit patterns
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*COG!* \   this stores a value at the location given.  In this case the location is outa, and the value is [the output bit pattern]. 
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*0*  \  The is the end flag for  loop (the end of the loop that started with `begin`.  Zero means "don't end", always have zero here means "never end",

*until*  \  end of the loop.  Since zero is always going to be seen by until here,  the loop goes forever. The routine jumps back to the begin word, and the next time through it increments the `1` to `2` and so on...

*;*  / The semicolon ends the definition starts by colon `:` and names pinIncrement. 

*c" 0 pinIncrement" 0 cogx*  \ This is a one line script. `C"` take a string of characters (in this case `0 pinIncrement` ) ending with the second `"`) and send it to the cog number (in this case zero).  cogx make s the cog execute the string just as if it were typed into the command line for that cog.   This is really a cool, powerful function of propforth.  So this line starts the pinIncrement function on cog0 and starts the specified I/O lines toggling. 

*lac*  \ The start the logic analyzer on THIS cog (cog6), this makes the output of LAC show up on the terminal (which is connected to cog6). 

 === Intro to POV with Quickstart ===

If you are using the Quickstart, Here a modification to pinIncrement that might be helpful.

TheQuickstart has LEDs on pins 16 - 23. We can use the exact same program, just use differnet starting pin (16).  Paste in the following:

{{{
\ pinIncrementer( n1 ) increment 8 pins starting at pin n1
: pinIncrement
  hFF over lshift dira COG!
  0 begin
    1+ 2dup swap lshift outa COG!
  0 until
;

c" 16 pinIncrement" 0 cogx

lac

}}}

Notice that the LEDs light up immediately.  

Hold the quickstart near the USB connector.  LED P16 should be farthest away from you, and LED P23 should be closest to you.  

Wave the quickstart side to side rapidly.

Notice that the LED 16 makes a solid line in you fikled o vision, and LED pin 23 makes a long dashed line. The LEDs in between make progressivle horter lines the farther away from you. Neat!

This is what the logic analyzer is displaying.  LAC displays a snapshot of ONE LOOP of the `pinIncrement` loop.  WOW!

 === another pinIncrement, slower ===

{{{
\ pinIncrementer( n1 ) increment 8 pins starting at pin n1
: pinIncrement
  hFF over lshift dira COG!
  0 begin
    1+ 2dup swap lshift outa COG!

\\ 1000
\\ 250 
   25 
\\ 1
 delms
 
  0 until
;

c" 16 pinIncrement" 0 cogx

lac

}}}


----------

= UNDER CONSTRUCTION FROM HERE =

Do the examples:







The following assumes you have already completed the examples in section 5

== load an application (Quickstart touch demo) ==

  * In teraterm, run the `reboot` word to return to the original kernel state.
  * Download the Quickstart Touch button demo 
  * http://propforth.googlecode.com/files/QuickstartTouchDemo20120611-1540.txt
  * Open it in your text editor
  * highlight the entire contents of `QuickstartTouchDemo20120611-1540.txt`
  * copy th4 highlighted text with `(ctl^C)`
  * paste it into teraterm 
  * do saveforth (to write the the touch button demo to EEprom)

NOTE: After your programs are loaded, you can do a saveforth to save the current dictionary image to eeprom. This way, the same image will persist after reboots and power cycling.   

NOTE:  You can load lac first, or you can load quickstart demo first. you can do saveforth after loading either to write the current image to EEPROM.

== load lac.f after application ==

Make sure the quickstart touch demo is present and running. 

Load LAC into propforth as described above.

== set triggers ==

set the trigger as the transition of one ot the buttons (pin 0-7) or for one of the LEDs (pins 16-23)

First try button pins, then try LED pins, etc

== set the sampling ==

by default, LAC will sample xxxx bye at frequency xxxx

The touch demo runs at xxx refreshes (line xx in touch demo)

Set the sampling such that the touch and release event can be captured, for example nnnn

== execute application ==

Since the touch demo is set to run on reboot or power cycle, the demo should already be running. 

touching the button that you have set as trigger (or that triggers the LED you have set as trigger) should cause LAC to capture a sample

== monitor application ==

Notice that the buttons and LEDs are refreshed at a rate of 22 ms (line xx in touch demo)

Touching the trigger pin should capture a sample. In addition, the states of all other pins are displayed.  You should be able to see the transitions of any pins touched during sampling.  Experiment with change the sample window till you can capture various samples ass you touch different buttons.

= ok =

= TRIGGER with < ENTER > =

By default, LAC triggers when you press the enter key

Run LAC

hit enter, and see the display get drawn.  If it scrolls of the bottom, adjust you window size. The output has a line for each I/O line, a command header, and intermediate headers for the I/O lines display. .   

The display window needs at least 63 lines to full display with out scrolling.

OPTIONALLY we can edit the LAC code to remove some intermediate headers to reduce the out put display size.  (do this later.

Touch various quckstart pads to light LEDs.

Hit enter to see the LAC i/o lines dispay change to reflect the states of the pads (on pin 0-7) and the LEDS (on pin 16-23)

== change sample frequency to a LONG interval ==

The default sample frequency is 40 clocks per cycle. When triggered, LAC samples at this rate until the buffer (free memory) is filled. 

Change the sample frequency using the `ASDFG` keys (caps) to increase the sample time delta (by 1, 10, 100, 1000, 10000 cycles, respectively); and using the asdfg keys (lowercase) to decrease the sample time delta (by 1, 10, 100, 1000, 10000 cycles, respectively)

touch pads and resample to see changes

Notice is you set the sample rate to 40,000 cycles (G,G,G,G) this is about the highest it can go. It takes a long time (almost 2 seconds) to sample and display.  You can LIGHTLY lay your finger across several pad on the quickstart, some some of the LEDs flicker dimly. The sample will show the I/O lines toggling for the flickering LEDs. 

=== change the sample frequency to a short interval ===

The shortest sampling period we do with the default configuration is 40 cycles. 

NOTICE that you can set the sample frequency down to 1 cycle. BY DEFAULT, the lowest we can go is 40 cycles, this uses 1 cog to do the sample, and save the data to free hub memory.  It can't function reliably any faster in this configuration.

By changing the configuration in LAC, we have TWO more options:

  * use more cogs to sample faster, capture to HUB memory
  * use a single cog and sample VERY FAST, capture to COG memory.  The cog memory captures are much smaller.  But in this case we tend to be looking at very fast events, so this is enough.  (If its not use the other method, of course)

Setting the different capture configuration is beyond the scope of this exercise, check the LAC source code for details.

= TRIGGER  from PIN STATE TRANSITION =

We can change the default so a pin state transition causes the sampling to trigger.

Lets make the sampling trigger when we touch button pad 4.



- End 20130321 -