#summary LAC is the software logic analyzer in propforth
#labels v5.5,Quickstart,LAC,logicanalyzer


<wiki:toc max_depth="9" />


= Logic Analyzer  =

This a a supplement for `PropForth-V5.5-20130317.zip/V5.5/doc/PROPFORTH.HTM` section 5 !LogicAnalyzer

Logic Analyzer reports the pin states, hi or low, for a specific time after a specific event.  This handy for real time control, where timing is critical. A logic analyzer is like very fancy expensive oscilloscope.  LAC is a little cheaper, and can be just as effective.

LAC is a software program that uses one or more cogs to report the state of the prop pins form a given time for a certain duration.  

The sampling period can be triggered by pin transition, or by an operator event. 

The forth script lac.f is located at `PropForth-V5.5-20130317.zip/V5.5/CurrentRelease/Extensions/lac.f`

= Setup =

Summary: Load the propforth kernel, load the lac.f extension.

== PC - Windos XP ==

Install and launch the Proptool

Connect the Quickstart to the PC with a USB cable

After the device is registered, Use F7 to ensure the USB COM port is found.

== Load a kernel ==

use the prop tool to open

`PropForth-V5.5-20130317.zip/V5.5/CurrentRelease\CurrentRelease\PropForth\` 
`DevKernel.spin`

Use F11 to compile and load the kernel into EEPROM

== Load lac.f ==

in your text editor, open
`PropForth-V5.5-20130317.zip/V5.5/CurrentRelease/Extensions/lac.f`

highlight the entire contents of the file `(CTL^A)`

copy it `(CTL^C)`

paste it into the teraterm window with the propforth command line (right mouse)

== save image to EEprom ==

Use saveforth to save the current dictionary image (which now inclides LAC) to EEprom

{{{
Prop0 Cog6 ok
saveforth
}}}

response will be
{{{
.............................................................................................................................................
Prop0 Cog6 ok
}}}

When the prop is power cycled or rebooted, the LAC definitions will still be present.

== To Remove LAC ==

To get rid of LAC, use forget build_LogicAnalyzer and do saveforth again, or simple reburn devkernel.spin using proptool.   For now, leave lac in EEprom, as we will reboot several times during the investigation. 

= Using LAC =

Read `PropForth-V5.5-20130317.zip/V5.5/doc/PROPFORTH.HTM` section 5 !LogicAnalyzer

 == LAC commands ==

NOTE:  You can issue invalid command sequences to LAC.  There is no particular error checking on command input, it will perform what ever command(s) you issue. This makes it very powerful, but also easy to screw up.  It is the operators responsibility to issue correct commands.  If something goes wrong or starts acting strange, just reboot.  Typically, we reboot quite often during the investigation and development phase,  don't be afraid to reboot often. 

  === Trigger Pin      -q    +Q: 0 ===

LAC will look at this pin (can be 0 to 31) for a transition.  The transition will start the sampling process. 

Pressing `q` will decrement the pin number

Pressing `Q` will increment the pin number

This field has limits of 0 and 31.   It also can display `NONE` after the SPACE key is pressed. 

If the trigger pin displays as NONE and will not increment or decrement, restart lac. (LAC has to be small to fit in with an application, changing this would increase dicationary foot print, and would cost a lot of memory space)

  ===  Trigger Edge -w +W SPACE ===

This is for rising edge, fall edge, or NONE. 

`w`  lower-case w selects falling edge. Start collecting the sample when the pin transitions from HIGH to low.  Used when a pin is changing at some frequency


`W` upper-case W selects  rising edge.  Start collecting the sample when the pin transitions from LOW to high.  Used when a pin is changing at some frequency

SPACE selects NONE.  Just start collecting the sample when the ENTER key is pressed.  Used when the pin is changing from a manual or other external non frequency event. 

If trigger edge displays NONE and will not change to the rising or falling glyph,  restart lac.

  === Trigger Frequency         eE :  ===

Before a trigger pin is sampled  or when no trigger pin is designated, the trigger frequency display is blank. 

LAC attempts to determine the frequency of the input pin by detecting it for 250 milliseconds. This detects frequency below 1/250ms or 1/0.250 seconds.  So, `e` is for detecting signal below 4 Hz.

When `E~ upper case E is selected, it looks at the pin for about a second.  This is used for detecting 1 Hz or below.  If signal changes slower than 1 time persecond, LAC treats it as if the trigger frequency were set to NONE. 

`Trigger Frequency         eE : NO TRIGGER FOUND`

Selecting `e` set the interval back to 250ms (the default). 

If the trigger frequency displays NONE and will not change to the rising or falling glyph,  restart lac.  Also, the specified input pin might not be toggling fast enough for lac to register a frequency. Check that you are looking at the correct pin, and you've started it toggling. Also check the way you control the frequency. I find that often the problem is I didn't set this part up correctly. 

   === Sample Interval -asdfg +ASDFG: 500.0 nS             40 clock cycles === 

OK, this one is a bit complex.

The samples are taken every so many cycles. 

a - decrement the cycles by 1
s - decrement the cycles by 10
d - decrement the cycles by 100
f - decrement the cycles by 1000
g - decrement the cycles by 10,000

G - increment the cycles by 10,000
F - increment the cycles by 1,000
D - increment the cycles by 100
S - increment the cycles by 10
A - increment the cycles by 1

If the sample is specified as 1 (one clock cycle, sample every clock cycle) lac has to shift into extreme  mode and do things differently:  It begins to use cogs 2, 3, 4 and 5 to collect the sample, and save these in cog memory.  If you (accidentally) hit any of the unshifted (lower-case) keys asdfg, you have a good change of forcing lac to shift to this mode.   This can really mess up lac if the other parameters are set for longer samples, etc.   BE CAREFUL.  If the display says 1 clock cycle, and you don't want one cycle, you need to reset and start over.  Until you get used to this, you might have to restart a few times.  (Don't even ASK me how I know). 

We can also set the sample interval very long. Each column in the sample display is one long (two words) that contains the state of the pins at integer multiples of the sample interval clock cycles. Each horizontal demarcation has 16 samples, there are eight (8) demarcations in the sample display.  So there are 16 * 8 samples or 128 samples displayed.  At 40,000 cycles, it takes almost a full second to collect the sample (on a stock crystal running at 80Mhz).  

If you set the clock cycles higher than 40,000,; and hit the enter key a bunch of times, you will have to wait oa long time for the samples to be collected and the display to update.  It looks like the screen has frozen, but its not, it just doing like you asked. 

Mess around with this and get a feel for the impact of the various keys and settings. 

  === Sample < ENTER > ===

The ENTER key triggers sampling.  

That is, when the enter key is pressed, lac looks at the trigger pin and waits how the transition event, if specified; or begins sampling immediately if NONE is specified.  One sampling cycle consists of the trigger event, then one sample every N clock cycles as specified in sample interval.  This continues until the display is populated, or the buffer (all unallocated memory) is used up (Check if this is still the case?). 

 === Quit < ESC > ===

Hit the ESCAPE key to exitt LAC. LAC will terminate immediately if it is not sampling.  If lac is in the process of sampling, for example a very long sample interval, and/or multuiple enter key presses in the keyboard input buffer, it not terminal until the sampling is complete.  This can take a very long time if you set it up correctly (or incorrectly depending on your intent). 

Mess with this until you get a feel for when it quits quickly and when you have to wait. 


    ===  Sample Display  -zxcv  +ZXCV :      clock cycles of    193  ===

What could this mean? 

LAC samples the pins states, and stores these as LONG values in HUB ram (or COG RAM if set to 1 cycle).  So it dumps the sampes into unused memory until it runs out of memory, until it runs out of memory, or another sampling event begins. LAC only displays 128 samples on the display; otherwise the display would have to deal with scrolling left and right, and/or other complex and messing things.  So it just displays 128 samples, which is what we decided it could throw onto the display with no extra coding.  

The keys zxcv and ZXCV control which samples we are looking at. 

To look at the samples AFTER the first 128, 

z - begin display one sample later (to the right)
x - begin display ten samples later (to the right)
c - begin display one hundred samples later (to the right)
v - begin display one thousand samples later (to the right)

V -  begin display one thousand samples earlier (to the left)
C -  begin display one hundred samples earlier (to the left)
X -  begin display ten samples earlier (to the left)
Z -  begin display one sample earlier (to the left)

So the window display shifts left or right through the sample set. 

NOTICE that with just LAC loaded, there are 193 samples total. 

193 samples total minus 128 samples displayed  equals 65 samples not displayed.  So the most the display can shift is 65 samples. 

    ====  Question ====

With devkernel.spin loaded, and lac.f loaded and save to EEprom with saveforth, I run `free`

{{{
Prop0 Cog6 ok
free
11030 bytes free - 176 cog longs free
Prop0 Cog6 ok

}}}

I think that 11030 bytes divided by 4 equals 2757 longs free.  So I should have 2757 samples.  Why are there only 193?  

Is it because this is all it can do before the next sample? 

   ==== Investigate ==== 
  Change the clock cycles sample interval.  Change the trigger from pin to NONE.  Change the frequency of the trigger  pin toggle.

 === The Logic Analyzer Display ====

Along top of the display are eight column headers.  These are integer multiples of the sample interval clock cycles, in (prefix)seconds. The column headers automagically display prefixes for the seconds in nano seconds, microseconds, and milliseconds. (That's kind of cool, how does he do that?)

Along the left side of the display are listed the I/O PIN numbers 31 down to 0.  

The column headers are repeated every four I/O pin lines, and have a white space line above and a white space line below the interval headers.  (Can we remove the whitespace?  Can we change the number of times the column headers are displayed? I would want to t troy remopving the whitesapce, and only display the colume headers three times, once at the top, once in the middle, and once at the bottom. Then I would change my mind.) 

Each column in the sample display is one long (two words) that contains the state of the pins at integer multiples of the sample interval clock cycles. Each horizontal demarcation has 16 samples, there are eight (8) demarcations in the sample display.  So there are `16 * 8 samples or 128 ` samples displayed. 


  === Adjust the LAC display format ===

My screen is too  small to display all the LAC lines on one screen. The font can be reduced, but then the characters are too small to read comfortably (my eyes are getting bad).  An option is to reduce the whitespace on the LAC display.

This involves editing  and reloading the LAC source code.  Be sure to RE-BURN THE EEprom if you did SAVEFORTH, or you might get confused when you changes disappear. 

 ==== LAC Parameter Header ====

By default, the LAC top header display one parameter per line.  After we get used to this, we can try cramming multiple parameters on one line. 

LAC.f Line 558 is the function  `_lac_h` which displays the lac header.

This comment removes the blank line bfore the first parameter line
{{{  
\	hm crcl
	hm 
}}}

This comment puts Trigger Pin and Trigger Edge on teh same line
{{{  
\\	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then crcl
	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then space
}}}



 ==== LAC intermediate column headers ====

----------

= UNDER CONSTRUCTION FROM HERE =

Do the examples:







The following assumes you have already completed the examples in section 5

== load an application (Quickstart touch demo) ==

  * In teraterm, run the `reboot` word to return to the original kernel state.
  * Download the Quickstart Touch button demo 
  * http://propforth.googlecode.com/files/QuickstartTouchDemo20120611-1540.txt
  * Open it in your text editor
  * highlight the entire contents of `QuickstartTouchDemo20120611-1540.txt`
  * copy th4 highlighted text with `(ctl^C)`
  * paste it into teraterm 
  * do saveforth (to write the the touch button demo to EEprom)

NOTE: After your programs are loaded, you can do a saveforth to save the current dictionary image to eeprom. This way, the same image will persist after reboots and power cycling.   

NOTE:  You can load lac first, or you can load quickstart demo first. you can do saveforth after loading either to write the current image to EEPROM.

== load lac.f after application ==

Make sure the quickstart touch demo is present and running. 

Load LAC into propforth as described above.

== set triggers ==

set the trigger as the transition of one ot the buttons (pin 0-7) or for one of the LEDs (pins 16-23)

First try button pins, then try LED pins, etc

== set the sampling ==

by default, LAC will sample xxxx bye at frequency xxxx

The touch demo runs at xxx refreshes (line xx in touch demo)

Set the sampling such that the touch and release event can be captured, for example nnnn

== execute application ==

Since the touch demo is set to run on reboot or power cycle, the demo should already be running. 

touching the button that you have set as trigger (or that triggers the LED you have set as trigger) should cause LAC to capture a sample

== monitor application ==

Notice that the buttons and LEDs are refreshed at a rate of 22 ms (line xx in touch demo)

Touching the trigger pin should capture a sample. In addition, the states of all other pins are displayed.  You should be able to see the transitions of any pins touched during sampling.  Experiment with change the sample window till you can capture various samples ass you touch different buttons.

= ok =

= TRIGGER with < ENTER > =

By default, LAC triggers when you press the enter key

Run LAC

hit enter, and see the display get drawn.  If it scrolls of the bottom, adjust you window size. The output has a line for each I/O line, a command header, and intermediate headers for the I/O lines display. .   

The display window needs at least 63 lines to full display with out scrolling.

OPTIONALLY we can edit the LAC code to remove some intermediate headers to reduce the out put display size.  (do this later.

Touch various quckstart pads to light LEDs.

Hit enter to see the LAC i/o lines dispay change to reflect the states of the pads (on pin 0-7) and the LEDS (on pin 16-23)

== change sample frequency to a LONG interval ==

The default sample frequency is 40 clocks per cycle. When triggered, LAC samples at this rate until the buffer (free memory) is filled. 

Change the sample frequency using the `ASDFG` keys (caps) to increase the sample time delta (by 1, 10, 100, 1000, 10000 cycles, respectively); and using the asdfg keys (lowercase) to decrease the sample time delta (by 1, 10, 100, 1000, 10000 cycles, respectively)

touch pads and resample to see changes

Notice is you set the sample rate to 40,000 cycles (G,G,G,G) this is about the highest it can go. It takes a long time (almost 2 seconds) to sample and display.  You can LIGHTLY lay your finger across several pad on the quickstart, some some of the LEDs flicker dimly. The sample will show the I/O lines toggling for the flickering LEDs. 

=== change the sample frequency to a short interval ===

The shortest sampling period we do with the default configuration is 40 cycles. 

NOTICE that you can set the sample frequency down to 1 cycle. BY DEFAULT, the lowest we can go is 40 cycles, this uses 1 cog to do the sample, and save the data to free hub memory.  It can't function reliably any faster in this configuration.

By changing the configuration in LAC, we have TWO more options:

  * use more cogs to sample faster, capture to HUB memory
  * use a single cog and sample VERY FAST, capture to COG memory.  The cog memory captures are much smaller.  But in this case we tend to be looking at very fast events, so this is enough.  (If its not use the other method, of course)

Setting the different capture configuration is beyond the scope of this exercise, check the LAC source code for details.

= TRIGGER  from PIN STATE TRANSITION =

We can change the default so a pin state transition causes the sampling to trigger.

Lets make the sampling trigger when we touch button pad 4.



- End 20130321 -