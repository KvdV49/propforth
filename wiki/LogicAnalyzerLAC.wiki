#summary LAC is the software logic analyzer in propforth
#labels v5.5,Quickstart,LAC,logicanalyzer


<wiki:toc max_depth="9" />


= Logic Analyzer  =

This a a supplement for `PropForth-V5.5-20130317.zip/V5.5/doc/PROPFORTH.HTM` section 5 !LogicAnalyzer

Logic Analyzer reports the pin states, hi or low, for a specific time after a specific event.  This handy for real time control, where timing is critical. A logic analyzer is like very fancy expensive oscilloscope.  LAC is a little cheaper, and can be just as effective.

LAC is a software program that uses one or more cogs to report the state of the prop pins form a given time for a certain duration.  

The sampling period can be triggered by pin transition, or by an operator event. 

The forth script lac.f is located at `PropForth-V5.5-20130317.zip/V5.5/CurrentRelease/Extensions/lac.f`

= Setup =

Summary: Load the propforth kernel, load the lac.f extension.

== PC - Windos XP ==

Install and launch the Proptool

Connect the Quickstart to the PC with a USB cable

After the device is registered, Use F7 to ensure the USB COM port is found.

== Load a kernel ==

use the prop tool to open

`PropForth-V5.5-20130317.zip/V5.5/CurrentRelease\CurrentRelease\PropForth\` 
`DevKernel.spin`

Use F11 to compile and load the kernel into EEPROM

== Load lac.f ==

in your text editor, open
`PropForth-V5.5-20130317.zip/V5.5/CurrentRelease/Extensions/lac.f`

highlight the entire contents of the file `(CTL^A)`

copy it `(CTL^C)`

paste it into the teraterm window with the propforth command line (right mouse)

== save image to EEprom ==

Use saveforth to save the current dictionary image (which now inclides LAC) to EEprom

{{{
Prop0 Cog6 ok
saveforth
}}}

response will be
{{{
.............................................................................................................................................
Prop0 Cog6 ok
}}}

When the prop is power cycled or rebooted, the LAC definitions will still be present.

== To Remove LAC ==

To get rid of LAC, use forget build_LogicAnalyzer and do saveforth again, or simple reburn devkernel.spin using proptool.   For now, leave lac in EEprom, as we will reboot several times during the investigation. 

= Using LAC =

Read `PropForth-V5.5-20130317.zip/V5.5/doc/PROPFORTH.HTM` section 5 !LogicAnalyzer

 == LAC Parameter control ==

NOTE:  You can issue invalid command sequences to LAC.  There is no particular error checking on command input, it will perform what ever command(s) you issue. This makes it very powerful, but also easy to screw up.  It is the operators responsibility to issue correct commands.  If something goes wrong or starts acting strange, just reboot.  Typically, we reboot quite often during the investigation and development phase,  don't be afraid to reboot often. 

  === Trigger Pin      -q    +Q: 0 ===

LAC will look at this pin (can be 0 to 31) for a transition.  The transition will start the sampling process. 

Pressing `q` will decrement the pin number

Pressing `Q` will increment the pin number

This field has limits of 0 and 31.   It also can display `NONE` after the SPACE key is pressed. 

If the trigger pin displays as NONE and will not increment or decrement, restart lac. (LAC has to be small to fit in with an application, changing this would increase dicationary foot print, and would cost a lot of memory space)

  ===  Trigger Edge -w +W SPACE ===

This is for rising edge, fall edge, or NONE. 

`w`  lower-case w selects falling edge. Start collecting the sample when the pin transitions from HIGH to low.  Used when a pin is changing at some frequency


`W` upper-case W selects  rising edge.  Start collecting the sample when the pin transitions from LOW to high.  Used when a pin is changing at some frequency

SPACE selects NONE.  Just start collecting the sample when the ENTER key is pressed.  Used when the pin is changing from a manual or other external non frequency event. 

If trigger edge displays NONE and will not change to the rising or falling glyph,  restart lac.

  === Trigger Frequency         eE :  ===

Before a trigger pin is sampled  or when no trigger pin is designated, the trigger frequency display is blank. 

LAC attempts to determine the frequency of the input pin by detecting it for 250 milliseconds. This detects frequency below 1/250ms or 1/0.250 seconds.  So, `e` is for detecting signal below 4 Hz.

When `E~ upper case E is selected, it looks at the pin for about a second.  This is used for detecting 1 Hz or below.  If signal changes slower than 1 time persecond, LAC treats it as if the trigger frequency were set to NONE. 

`Trigger Frequency         eE : NO TRIGGER FOUND`

Selecting `e` set the interval back to 250ms (the default). 

If the trigger frequency displays NONE and will not change to the rising or falling glyph,  restart lac.  Also, the specified input pin might not be toggling fast enough for lac to register a frequency. Check that you are looking at the correct pin, and you've started it toggling. Also check the way you control the frequency. I find that often the problem is I didn't set this part up correctly. 

   === Sample Interval -asdfg +ASDFG: 500.0 nS             40 clock cycles === 

OK, this one is a bit complex.

The samples are taken every so many cycles. 

a - decrement the cycles by 1
s - decrement the cycles by 10
d - decrement the cycles by 100
f - decrement the cycles by 1000
g - decrement the cycles by 10,000

G - increment the cycles by 10,000
F - increment the cycles by 1,000
D - increment the cycles by 100
S - increment the cycles by 10
A - increment the cycles by 1

If the sample is specified as 1 (one clock cycle, sample every clock cycle) lac has to shift into extreme  mode and do things differently:  It begins to use cogs 2, 3, 4 and 5 to collect the sample, and save these in cog memory.  If you (accidentally) hit any of the unshifted (lower-case) keys asdfg, you have a good change of forcing lac to shift to this mode.   This can really mess up lac if the other parameters are set for longer samples, etc.   BE CAREFUL.  If the display says 1 clock cycle, and you don't want one cycle, you need to reset and start over.  Until you get used to this, you might have to restart a few times.  (Don't even ASK me how I know). 

We can also set the sample interval very long. Each column in the sample display is one long (two words) that contains the state of the pins at integer multiples of the sample interval clock cycles. Each horizontal demarcation has 16 samples, there are eight (8) demarcations in the sample display.  So there are 16 * 8 samples or 128 samples displayed.  At 40,000 cycles, it takes almost a full second to collect the sample (on a stock crystal running at 80Mhz).  

If you set the clock cycles higher than 40,000,; and hit the enter key a bunch of times, you will have to wait oa long time for the samples to be collected and the display to update.  It looks like the screen has frozen, but its not, it just doing like you asked. 

Mess around with this and get a feel for the impact of the various keys and settings. 

  === Sample < ENTER > ===

The ENTER key triggers sampling.  

That is, when the enter key is pressed, lac looks at the trigger pin and waits how the transition event, if specified; or begins sampling immediately if NONE is specified.  One sampling cycle consists of the trigger event, then one sample every N clock cycles as specified in sample interval.  This continues until the display is populated, or the buffer (all unallocated memory) is used up (Check if this is still the case?). 

 === Quit < ESC > ===

Hit the ESCAPE key to exitt LAC. LAC will terminate immediately if it is not sampling.  If lac is in the process of sampling, for example a very long sample interval, and/or multuiple enter key presses in the keyboard input buffer, it not terminal until the sampling is complete.  This can take a very long time if you set it up correctly (or incorrectly depending on your intent). 

Mess with this until you get a feel for when it quits quickly and when you have to wait. 


    ===  Sample Display  -zxcv  +ZXCV :      clock cycles of    193  ===

What could this mean? 

LAC samples the pins states, and stores these as LONG values in HUB ram (or COG RAM if set to 1 cycle).  So it dumps the sampes into unused memory until it runs out of memory, until it runs out of memory, or another sampling event begins. LAC only displays 128 samples on the display; otherwise the display would have to deal with scrolling left and right, and/or other complex and messing things.  So it just displays 128 samples, which is what we decided it could throw onto the display with no extra coding.  

The keys zxcv and ZXCV control which samples we are looking at. 

To look at the samples AFTER the first 128, 

z - begin display one sample later (to the right)
x - begin display ten samples later (to the right)
c - begin display one hundred samples later (to the right)
v - begin display one thousand samples later (to the right)

V -  begin display one thousand samples earlier (to the left)
C -  begin display one hundred samples earlier (to the left)
X -  begin display ten samples earlier (to the left)
Z -  begin display one sample earlier (to the left)

So the window display shifts left or right through the sample set. 

NOTICE that with just LAC loaded, there are 193 samples total. 

193 samples total minus 128 samples displayed  equals 65 samples not displayed.  So the most the display can shift is 65 samples. 

    ====  Question ====

With devkernel.spin loaded, and lac.f loaded and save to EEprom with saveforth, I run `free`

{{{
Prop0 Cog6 ok
free
11030 bytes free - 176 cog longs free
Prop0 Cog6 ok

}}}

I think that 11030 bytes divided by 4 equals 2757 longs free.  So I should have 2757 samples.  Why are there only 193?  

Is it because this is all it can do before the next sample time? 

   ==== Investigate ==== 

  * Change the clock cycles sample interval.  
  * Change the trigger from pin to NONE.  
  * Change the frequency of the trigger  pin toggle.

 === The Logic Analyzer Display ====

Along top of the display are eight column headers.  These are integer multiples of the sample interval clock cycles, in (prefix)seconds. The column headers automagically display prefixes for the seconds in nano seconds, microseconds, and milliseconds. (That's kind of cool, how does he do that?)

Along the left side of the display are listed the I/O PIN numbers 31 down to 0.  

The column headers are repeated every four I/O pin lines, and have a white space line above and a white space line below the interval headers.  (Can we remove the whitespace?  Can we change the number of times the column headers are displayed? I would want to t troy remopving the whitesapce, and only display the colume headers three times, once at the top, once in the middle, and once at the bottom. Then I would change my mind.) 

Each column in the sample display is one long (two words) that contains the state of the pins at integer multiples of the sample interval clock cycles. Each horizontal demarcation has 16 samples, there are eight (8) demarcations in the sample display.  So there are `16 * 8 samples or 128 ` samples displayed. 


  === Adjust the LAC display format ===

My screen is too  small to display all the LAC lines on one screen. The font can be reduced, but then the characters are too small to read comfortably (my eyes are getting bad).  An option is to reduce the whitespace on the LAC display.

This involves editing  and reloading the LAC source code.  Be sure to RE-BURN THE EEprom if you did SAVEFORTH, or you might get confused when you changes disappear. 

 ==== LAC Parameter Header ====

By default, the LAC top header display one parameter per line.  After we get used to this, we can try cramming multiple parameters on one line. 

The function `crcl` clears to the end of line and prints a carriage return for hear formatting.  Find this and you can adjust the hear display. 

LAC.f Line 558 is the function  `_lac_h` which displays the lac header.

This comment removes the blank line bfore the first parameter line.  I copy the original line, comment it out, and edit the copy.  

{{{  
\	hm crcl
	hm 
}}}

This comment puts Trigger Pin and Trigger Edge on th. same line.  Again, I copied the original line, commented out the oringinal line, and editied the copy.  Here I replaced `crcl` with `space`.

{{{  
\\	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then crcl
	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then space
}}}

This saved me two lines, its a start. Play with the formatting of the remaining header items. 

 ==== LAC intermediate column headers ====

lac.f line 636 is the main function.

lines 655 and 662 (after I've been editing) put the column marker line in the display.  I commented out both out these

{{{
\				_lacv       \ white space
}}}

Lines 664 and 671 (after I've been editing) control the number of I/O lines that are displayed under each intermediate colum header line.  Every four lines cost too much space so I tried 8.  Eight lines is a little more than an eyeful in one glance, but it save a bunch of space and its not too bad once you get used to it. 

{{{
\\				i h4 bounds
				i h8 bounds
				do
					h1F i - dup <# # # #> .cstr
					_la_current W@ swap _la_displayPin
					crcl
				loop
\\			h4 +loop
			h8 +loop
}}}

After making the changes, save the source file (with a new name if you want to retain the original).  I saved it as `lac-whitespace.f`.

  ==== the reformatted display ====

Now my lac display looks like this:

{{{
    Trigger Pin      -q    +Q: 0     Trigger Edge   -w +W SPACE: __--
Trigger Frequency         eE :                 
Sample Interval -asdfg +ASDFG: 500.0 nS             40 clock cycles
         Sample     <ENTER>
         Quit         <ESC>
Sample Display  -zxcv  +ZXCV :                 clock cycles of             193 
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
31--------------------------------------------------------------------------------------------------------------------------------
30--------------------------------------------------------------------------------------------------------------------------------
29--------------------------------------------------------------------------------------------------------------------------------
28--------------------------------------------------------------------------------------------------------------------------------
27________________________________________________________________________________________________________________________________
26________________________________________________________________________________________________________________________________
25________________________________________________________________________________________________________________________________
24________________________________________________________________________________________________________________________________
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
23________________________________________________________________________________________________________________________________
22________________________________________________________________________________________________________________________________
21________________________________________________________________________________________________________________________________
20________________________________________________________________________________________________________________________________
19________________________________________________________________________________________________________________________________
18________________________________________________________________________________________________________________________________
17________________________________________________________________________________________________________________________________
16________________________________________________________________________________________________________________________________
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
15________________________________________________________________________________________________________________________________
14________________________________________________________________________________________________________________________________
13________________________________________________________________________________________________________________________________
12________________________________________________________________________________________________________________________________
11________________________________________________________________________________________________________________________________
10________________________________________________________________________________________________________________________________
09________________________________________________________________________________________________________________________________
08________________________________________________________________________________________________________________________________
         008.0 uS|       016.0 uS|       024.0 uS|       032.0 uS|       040.0 uS|       048.0 uS|       056.0 uS|       064.0 uS|
07________________________________________________________________________________________________________________________________
06________________________________________________________________________________________________________________________________
05________________________________________________________________________________________________________________________________
04________________________________________________________________________________________________________________________________
03________________________________________________________________________________________________________________________________
02________________________________________________________________________________________________________________________________
01________________________________________________________________________________________________________________________________
00________________________________________________________________________________________________________________________________

}}}

Much more to my liking.  It fits on the minicom terminal display screen without scrolling off the edges, and the font can be big enough to be readable.  A little work, but at least I don't have to buy a new monitor just yet.

= The Examples in `PropForth.htm` Section 5 =

At this point, we have :
 # `Devkernel.spin` loaded on the quickstart
 # `lac.f` (or our modified version) loaded via pasting  the source code into the terminal. 
 # 'lac' (the the routine defined in `lac.f`) is saved to EEprom via `saveforth`, so it will still be available after `reboot` or powercycle
 # !PropForth.htm  open in a browser window.

 == The first example ==

Now load the example code from section 5:

{{{
\ pinIncrementer( n1 ) increment 8 pins starting at pin n1
: pinIncrement
  hFF over lshift dira COG!
  0 begin
    1+ 2dup swap lshift outa COG!
  0 until
;

c" 0 pinIncrement" 0 cogx

lac

}}}

 === trace throught the example ===

What is `pinIncrement` really doing? Lets look at the stack as each function executes.

*: pinIncrement* \ the colon starts the definition.  colon takes a string, and uses that for the definition dictionary ID.  The definition continues until  the interpreter sees semi colon.  Colon and semicolon only run at compile time (when the definition is input). When the definition is called, the body (previously compiled into the dictionary by colon) executes. 

Step through the body of function !pinIncrement:

*start* \  this is what the stack looks like when the routine is first called
  * Stack0: 0 \starting pin# to toggle

*hFF* \   hFF is a literal in hexadecimal (h is the prefix)
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle

*over* \   copies the value BELOW the top of stack (and puts it on the top of the stack)
  * Stack2: 0 \Stack0 copied to the Top Of Stack (TOS)
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle

*lshift* \  shift 255 left 0 bits. Has no effect, but if the toggle pin were 8, it would shift 255 left 8, and the result would be a bit mask starting as pin 8.
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle


*dira*  \  this is the LOCATION of the register that specifies pin inputs and out puts.  1's are outputs, 0's are inputs.
  * stack2: $dira (address of dira)
  * stack1: FF \ hFF is 255 decimal
  * Stack0: 0 \starting pin# to toggle

*COG!* \  this stores a value at the location given.  In this case the location is dira, and the value is FF, the firs 8 pins are ONES
  * Stack0: 0 \starting pin# to toggle

*0*  \  seed value for the begin loop that's next
  * Stack1: 0 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*begin*  \  start a unbounded loop. The LAC loop runs with no predetermined end
  * Stack1: 0 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle
    
*1+*  \  add one to the loop seed value. This is what does the incrementing (toggling) for the pinIncrement function.
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*2dup*  \  
  * Stack3: 1 \ begin loop seed value copy
  * Stack2: 0 \starting pin# to toggle copy
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*swap*  \  switch the positions of the top two stack values
  * Stack3: 0 \ starting pin# to toggle copy
  * Stack2: 1 \ begin loop seed value copy
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*lshift* \  here, we shift counted number to the start pin number 
  * Stack2: 1 \ toggle value for setting the bit patterns
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*outa*  \  this is the LOCATION of the register that specifies pin  output states.  1's are highs, 0's are lows. Pin must also be configured as outputs by the dira register (we did this before the loop started)
  * Stack3: $outa1 \ address of the out resister
  * Stack2: 1 \ toggle value for setting the bit patterns
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*COG!* \   this stores a value at the location given.  In this case the location is outa, and the value is [the output bit pattern]. 
  * Stack1: 1 \ begin loop seed value
  * Stack0: 0 \starting pin# to toggle

*0*  \  The is the end flag for  loop (the end of the loop that started with `begin`.  Zero means "don't end", always have zero here means "never end",

*until*  \  end of the loop.  Since zero is always going to be seen by until here,  the loop goes forever. The routine jumps back to the begin word, and the next time through it increments the `1` to `2` and so on...

*;*  / The semicolon ends the definition starts by colon `:` and names pinIncrement. 

*c" 0 pinIncrement" 0 cogx*  \ This is a one line script. `C"` take a string of characters (in this case `0 pinIncrement` ) ending with the second `"`) and send it to the cog number (in this case zero).  cogx make s the cog execute the string just as if it were typed into the command line for that cog.   This is really a cool, powerful function of propforth.  So this line starts the pinIncrement function on cog0 and starts the specified I/O lines toggling. 

*lac*  \ The start the logic analyzer on THIS cog (cog6), this makes the output of LAC show up on the terminal (which is connected to cog6). 

 === Intro to POV with Quickstart ===

If you are using the Quickstart, Here a modification to pinIncrement that might be helpful.

The Quickstart has LEDs on pins 16 - 23. We can use the exact same program, just use different starting pin (16).  Paste in the following:

{{{
\ pinIncrementer( n1 ) increment 8 pins starting at pin n1
: pinIncrement
  hFF over lshift dira COG!
  0 begin
    1+ 2dup swap lshift outa COG!
  0 until
;

c" 16 pinIncrement" 0 cogx

lac

}}}

Notice that the LEDs light up immediately.  

Hold the quickstart near the USB connector.  LED P16 should be farthest away from you, and LED P23 should be closest to you.  

Wave the quickstart side to side rapidly.

Notice that the LED 16 makes a solid line in you field of vision, and LED pin 23 makes a long dashed line. The LEDs in between make progressively shorter lines the farther away from you. Neat!

The pattern of the LEDs in the air is the same patterh as the logic analyzer display.  LAC displays a snapshot of ONE LOOP of the `pinIncrement` loop.  WOW!

Now hit < ENTER > to sample and refresh the lac terminal display.  Notice that the when the trigger pin is set to 0 (the default), it can't lock to any of the LED pins.   Try changing the trigger pin from 0 the 16 and refresh.  Also try pin 23.

 === how do get a good snapshot of pinIncrement? ===


Ok, we've experiments with the various timings.  How to get the clearest display of the pin tranistions?

My suggestion is we want to see all the pin transitions.  

 ==== All transistion on one screen ====

If the trigger pin changes SLOWEST, the transition from the other pins will line up.  This would be pin 7 in the original example, or pin 23 using the LED example.

Setting the sample interval to 3,400 cycles captures the top half of the cycle for pin 23, one full cycle for pin 22, and so on.  Use upper and lower case z x c znd v key to shift the sample window left and right. 

with trigger pin 23 and sample interval 40 cycles (and the sample window start is bvlank meaning the first sample in the buffer), we see One transistion on pin 16.   The sample is too small and too fast. (that's pretty nifty in itself!).  The transistion occures at sample 85, or 043.0 uS.  So LAC tells us that the begin loop of pinIncrement takes 043.0 uS to execute.  Execellent!

Increase transitions stepwise at increasing size interval. Uppercase A increases the sample cycles by one cycle. Remember to hit < ENTER > to resample after changing the interval. Notice that the transition appears to move to the left, but the column header times also increase. Notice pins 17 to 20 start to change hi and low, but show no transistions yet. 

At sample interval 54 cycles, one full full cycles of pin 16 is displayed. One full cycles of pin 16 takes two samples less than 086.4 uS.  Hey! This agrees with our last observation! It works! Maybe.   Lets check more....

Increase the sample interval to 108 cycles. I went by 10's then 1's refreshing each step.  At interval 108, pin 16 displays two full cycles, and a tad  more. 

Increase the sample interval to 400. I went by 100's, then 10's then 1's refreshing each step.  At interval 400, pin 16 displays seven full cycles, and maybe half of one more. 

Increase the sample interval to 430.  At interval 430, pin 16 displays eight full cycles, and maybe one sample  more. 

So its beginning to look like that begin loop is slightly longer than 43.0 uS.

Increase the sample interval to 534.  At interval 534, pin 16 displays ten full cycles.  This takes 854.4 uS. So one cycle would be 85.44 uS,  and one transistion might be 42.72 uS, 

There are 128 samples display on the LAC screen.  If we want pin 16 to display one transition per sample....  that would be `42.72 uS * 128 samples` or 5,468.16 uS  displayed. So bump up the cycles until the right most column header is 5468.16. Unfortunately, the display switches to milliseconds. The best we can get is 5.5 mS. Lets try it using clocks cycles instead of seconds....

 Let's see... one transition is 42.72 uS was figured from 534 clock cycles displaying ten cycles.  So maybe 53.4 cycles should be one sample? `53.4 * 128 = 6835.2` so lets try 6835 or 6836 cycles....


==== 6835 ====

6835 cycles display a solid line?  Aha! I bet my math is off by a factor of two.  Pin 17 looks more like what we want.   Lets try 3417 or 3418....

==== 3417 ====

3417 cycles sample time display pin 16 as alternating one dash and one underscore each sample. I think  its pretty close now. With 3419 there is still one additional sample transition to low at the very end. And you might notice that are one or two samples on pin 17 display that display as ONE dash or underscore instead of two (in the last 16 samples).  Bump this down until the final transition on pin 16 is the opposite of the first transition

==== 3392 to 3418 ====

So it turns out that 3392 to 3418 cycles displays what we would expect, and interger number of cycles with one transistion per sample on pin 16. So I guess the transition are about every 3405 clock cycles. At 80 megahertz, this means if can capture a sample 23,494.8 times a second.  (somebody check my math?)

As we look farther out into the sample set, we can notice if an error accumulates.  Looking at the samples starting at 1280, we can see that the display is not lined up correctly. Adjusting the cycles to 3393 cleans it up.  Now I think that the look takes 3393 cycles to do exactly 128 samples. Looking at sample 2560 confirms this. 

 ==== All transition using all samples ====

So what else can we do with this?  Lets stretch the sample over the entire available sample space. 

LAC says my quickstart has 2746 total samples. Lets see if we can set LAC so the one cycle of pin 23 extends the full 2746 samples. 

Recall the the lac sample display shows 128 ( `8 columns of 16 samples` ) 

LAC reports 2746 total samples (the number of free longs in HUB memory that LAC can use for storage). 2746 samples / 128 samples per screen = 21.45 screens of sample data.  


Sample interval of 3393 cycles interval displays one full cycle of pin 22, and a half cycle of pin 23.  So I think to fill the full memory with 0n cycle of pin 22 would be a smaple interval os 21.45 time more clock cycles, or 72790.xxx

Well, that makes a mess.  The sample rate is so slow, that the data displays more or less random looking tranisitions. Maybve we nee to stick to integer numbers? 

Try Sample interval 33930 clock cycles. Still looks funny. I see! I'm making the sample interval LONGER, I'm going the wrong direction!  It should b getting SMALLER!  Instead of 3393, I should try 339.

And I crashed the program with nonsense paramters.  No worries, reboot, reloaqd pinIncrement and run it on pin 16

At 339, pin 23 see its first transistion at sample 1281. 

At 34, pin should see its first transition around sample 2462.  

But notice:   When the sample interval is below 41 clock cycles, there are only 193 samples taken.   If the window is still looking at later samples (above sample 193) the result is undefined.  It looks like its all zeros (no transitions). 

Lets try 41 and 67

At 41, we don't see a transistion on pins 22 or 23. Nor as 67. 

At 137 we get a transition on 22, but not 23 yet.  

At 272 (33.9 time 8 ), there's a transition on pin 23 at sample 1597, but not a full cycle.

At 542 (33.9 times 16),  The first full cycle of pin 23 ends at sample 1600. 

OK, now I'm completely sick of calculations for sampling. But at least I have an idea what s going on. 

 == another pinIncrement, slower ==

Try adding the delays below.  Uncomment a value and the delms (or use any values).  Then adjust lac cycle sample period to match.  One millisecond needs about 20,000 cycles per sample. 

{{{
\ pinIncrementer( n1 ) increment 8 pins starting at pin n1
: pinIncrement
  hFF over lshift dira COG!
  0 begin
    1+ 2dup swap lshift outa COG!

\ \ 1000
\ \  250 
\ \   25 
\ \ 1
\ \  delms
 
  0 until
;

c" 16 pinIncrement" 0 cogx

lac

}}}

Adding delay to the program is actually the opposite (inverse?) of LAC.  LAC captures a snapshot of the application state during execution, at full speed.   Adding a delay slow the execution itself down.  This could impact the rest of the system, for example when the events outside the program occur at a speed that cannot be controlled by software. 

----------

= LAC with an application =

The following assumes familiarity with the examples in !PropForth.htm section 5

Now that we've done the examples and played with the parameters, we should have an idea whats going on with LAC.  Now we can try using the tool to examine an applications.

== load an application (Quickstart touch demo) ==

  * In teraterm, run the `reboot` word to return to the original kernel state.
  * Download the Quickstart Touch button demo 
  * http://propforth.googlecode.com/files/QuickstartTouchDemo20120611-1540.txt
  * Open it in your text editor
  * ~~highlight the entire contents of `QuickstartTouchDemo20120611-1540.txt`~~
  * highlight the contents of `QuickstartTouchDemo20120611-1540.txt` EXCEPT FOR the last line that says REBOOT.  We DON'T want to reboot until both LAC and !QSTouchDemo are loaded and saved. 
  * copy the highlighted text with `(ctl^C)`
  * paste it into teraterm 
  * do saveforth (to write the the touch button demo to EEprom) 

NOTE 1: After your programs are loaded, you can do a saveforth to save the current dictionary image to eeprom. This way, the same image will persist after reboots and power cycling.   

NOTE 2:  You can load lac first, or you can load quickstart demo first. you can do saveforth after loading either to write the current image to EEPROM. Just done have the QS demo running when you load lac or do the saveforth. 

Note 3: LAC uses the current cog (cog6 by default) when sample interval is 40 cycles or greater.  When sample interval is 1 cycle (every cycle) LAC uses 4 cogs to do the sampling (Cogs 2, 3, 4, 5). If your application uses these cogs, there may be problems with sample interval below 40 cycles, and will definitely  require some attention to sample at 1 cycle. The QSTouchDemo uses cogs 3 & 4, maybe these should be moved to  cogs 0 and 1?  Reboot often while sorting this out. 

== load lac.f after application ==

Make sure the quickstart touch demo is present and running. 

Load LAC into propforth as described above.

do Saveforth again if you haven't already so both lac and the touch demo are saved in EEprom. 

==  REBOOT ==

After you powercycle or type the REBOOT command, the quickstart touch demo should respond by lighting the LEDS when the button pads are touched. If not, re-burn the devkernel to EEprom, reload the demo WITHOUT the reboot word at the end of the script file, reload lac, do saveforth, and reboot again.  

== set triggers ==

set the trigger as the transition of one of the buttons (pin 0-7) or for one of the LEDs (pins 16-23)

First try button pins, then try LED pins, etc

== execute application ==

Since the touch demo is set to run on reboot or power cycle, the demo should already be running. 

touching the button that you have set as trigger (or that triggers the LED you have set as trigger) should cause LAC to capture a sample

== monitor application ==

~~Notice that the buttons and LEDs are refreshed at a rate of 22 ms (line 29 in touch demo)~~

Notice that the buttons and LEDs are refreshed at full speed of the processor, and the LEDs are held lit for 22 ms (line 29 in touch demo) each pass of the loop. 

Touching the trigger pin should capture a sample. In addition, the states of all other pins are displayed.  You should be able to see the transitions of any pins touched during sampling.  Experiment with change the sample window till you can capture various samples ass you touch different buttons.

Why don't we see the button pin transition from High to Low when touched?  Nor the LED transition from low to high when it's button is touched?  The transition  event is very quick (tens of uS) while the LED on time is relatively very long (tens of milliseconds).  So for some reason, its no hitting the pin transition.  It hitting the LED on period instead, since this happens most of the time. 

= TRIGGER with < ENTER > =

By default, LAC triggers when you press the enter key

Run LAC

hit enter, and see the display get drawn.  If it scrolls of the bottom, adjust you window size. The output has a line for each I/O line, a command header, and intermediate headers for the I/O lines display. .   

The display window needs at least 63 lines to full display with out scrolling.

OPTIONALLY we can edit the LAC code to remove some intermediate headers to reduce the out put display size.  (do this later. -edit- this is now in the first part of this page.  We should determine if the modified code is more appropriate post it, or keep the original. There should on be one version posted on this wiki.)

Touch various quckstart pads to light LEDs.

Hit enter to see the LAC i/o lines dispay change to reflect the states of the pads (on pin 0-7) and the LEDS (on pin 16-23)

== set the sampling ==


by default, LAC will sample every 40 clocks about 192 samples.  About once every 50 nanoseconds, I think. 

The touch demo runs at about 100 refreshes per second. Line 29 has a delay of 11 milliseconds, this dominates the loop time. 

When LAC samples, it usually catches the button line pulled low and the LED line brought high.   

Can we set the sampling such that the touch and release event can be captured?

We might be able to trigger off the pin transition.  But the pin states are being updated a hundred time a second, so its kind ot tough to catch. 

== change sample frequency to a LONG interval ==

The default sample frequency is 40 clocks per cycle. When triggered, LAC samples at this rate until the buffer (free memory) is filled. 

Change the sample frequency using the `ASDFG` keys (caps) to increase the sample time delta (by 1, 10, 100, 1000, 10000 cycles, respectively); and using the asdfg keys (lowercase) to decrease the sample time delta (by 1, 10, 100, 1000, 10000 cycles, respectively)

touch pads and resample to see changes

Notice is you set the sample rate to 40,000 cycles (G,G,G,G) this is about the highest it can go. It takes a long time (almost 2 seconds) to sample and display.  You can LIGHTLY lay your finger across several pad on the quickstart, some some of the LEDs flicker dimly. The sample will show the I/O lines toggling for the flickering LEDs. 

== change the sample frequency to a short interval ==

The shortest sampling period we do with the default configuration is 40 cycles. 

NOTICE that you can set the sample frequency down to 1 cycle. BY DEFAULT, the lowest we can go is 40 cycles, this uses 1 cog to do the sample, and save the data to free hub memory.  It can't function reliably any faster in this configuration.

By changing the configuration in LAC, we have TWO more options:

  * use more cogs to sample faster, capture to HUB memory
  * use a single cog and sample VERY FAST, capture to COG memory.  The cog memory captures are much smaller.  But in this case we tend to be looking at very fast events, so this is enough.  (If its not use the other method, of course)

Setting the different capture configuration is beyond the scope of this exercise, check the LAC source code for details.

== TRIGGER  from PIN STATE TRANSITION ==

We can change the default so a pin state transition causes the sampling to trigger.

Lets make the sampling trigger when we touch button pad 4.

=  A different version of the Quickstart demo =

If anybody find a better way to do this polease let me know. 

I finally came to the conclusion that two cogs running the scan and LED tasks was just too fast to catchthe transition events.  So, I'm going t5o just change the program.

The following its both LAC and the quickstart demo, modified, in one listing. 

LAC is modified to display the data in less screen real estate. 

Quickstart demo is modified to run the button scan AND the LED lighting in a single loop on a single cog, so we can see the button scan transition event first followed by the LED state transition. 

Also, the touch button demo is loaed first, and LAC is loaded and saved after.  By default, the demop does saveforth and does a reboot, this cuases the demo to run; having a the demo run while we are still loaded the LAC code is not so good.  Also LAC works free memory, loading QST demo second changes the used memory start point, this seems to cause problems. 

Anyway the following worked for me:



{{{
\ 20130327 Braino
fl

: QST                \ ( - )  no stack parameters
\ LED section
      16             \ pin 16 is first of 8 LEDS
      8 0 do dup pinout 1+ loop drop \ set them to output
      begin
           ina COG@  \ get the current pins states
           invert    \ This makes them off till touched, 
                     \ comment out the invert to see "on till touched"  
           h_FF and  \ filter for only buttons pins 0-7
           16 lshift \ shift bits 0-7 left 16 places (to 16-23)
           outa COG! \ set these as output states
           
\  A delay here light the LEDs dimly, also need one AFTER LED is lit
\           11 delms   \ finger tip needs to be moist, and press harder
\             1 delms    \ finger tip needs to be moist, and press a little harder with 1 ms
           
\ scan section
       h_FF outa COG!         \ prep first 8 pins Hi (1's) 3.3V
       h_FF dira COG!         \ make first 8 pins outputs  (1's)
                              \ so now pins are "Charged"
       h_FF invert dira COG!  \ make first 8 pins inputs
                              \ if pad is touched, it will discharge to low 

\ a delay here leaves the LEDs in the ON state for this long, minimum 
\       1 delms \ 25 50 100 10  let it stay in this state for some milliseconds 
       11 delms \ 25 50 100 10  let it stay in this state for some milliseconds 
\     111 delms \ 25 50 100 10  let it stay in this state for some milliseconds 

                \ long enough to be seen, not long enough to flicker
  0 until       \ do this forever
; 

: onreset1 onreset QST ; \ run LED demo on cog3 upon reset after onreset routine

\  Now load LAC

\  20130325 modified to reduce whitespace
\
1 wconstant build_LogicAnalyzer
\
\
\ define this constant if the console code is needed
\
\
{
\ demo run on cog6


\ example1
\ 40 cycles clkfreq 40 2* /

c" 0 1000000 setHza 1  500000 setHzb" 0 cogx
c" 2  250000 setHza 3  125000 setHzb" 1 cogx
lac

\ example2
\ 41 cycles clkfreq 41 2* /
c" 0 975610 setHza 1 487805 setHzb" 0 cogx
c" 2 243902 setHza 3 121951 setHzb" 1 cogx
lac

\ example3
\ 50 cycles clkfreq 50 2* /

c" 0 800000 setHza 1 400000 setHzb" 0 cogx
c" 2 200000 setHza 3 100000 setHzb" 1 cogx
lac



\
\
\ if laconsole is not defined
\ example1
\ 40 cycles clkfreq 40 2* /

c" 0 1000000 setHza 1  500000 setHzb" 0 cogx
c" 2  250000 setHza 3  125000 setHzb" 1 cogx
80 0 la_sample+Trigger
40 0 la_sample+Trigger
20 0 la_sample+Trigger
4 0 la_sample+Trigger
1 0 la_sample+Trigger

\ example2
\ 41 cycles clkfreq 41 2* /
c" 0 975610 setHza 1 487805 setHzb" 0 cogx
c" 2 243902 setHza 3 121951 setHzb" 1 cogx
82 0 la_sample+Trigger
41 0 la_sample-Trigger
20 0 la_sample-Trigger
4 0 la_sample-Trigger
1 0 la_sample-Trigger

\ example3
\ 50 cycles clkfreq 50 2* /

c" 0 800000 setHza 1 400000 setHzb" 0 cogx
c" 2 200000 setHza 3 100000 setHzb" 1 cogx
50 la_sampleNoTrigger
25 la_sampleNoTrigger
4 la_sampleNoTrigger
1 la_sampleNoTrigger

}
\ a cog special register
[ifndef ctra
h1F8	wconstant ctra
]

\ a cog special register
[ifndef ctrb
h1F9	wconstant ctrb 
]

\ a cog special register
[ifndef frqa
h1FA	wconstant frqa 
]

\ a cog special register
[ifndef frqb
h1FB	wconstant frqb 
]

\ a cog special register
[ifndef phsa
h1FC	wconstant phsa 
]

\ a cog special register
[ifndef phsb
h1FD	wconstant phsb 
]

[ifndef $C_a_dovarl
    h4D wconstant $C_a_dovarl
]

\
\ pinout ( n1 -- ) set pin # n1 to an output
[ifndef pinout
: pinout
	>m dira COG@ or dira COG!
;
]

\
\ variable ( -- ) skip blanks parse the next word and create a variable, allocate a long, 4 bytes
[ifndef variable
: variable
	lockdict create $C_a_dovarl w, 0 l, forthentry freedict
;
]

\
\ abs ( n1 -- abs_n1 ) absolute value of n1
[ifndef abs
: abs
	_xasm1>1 h151 _cnip
;
]

\
\ waitcnt ( n1 n2 -- n1 ) \ wait until n1, add n2 to n1
[ifndef waitcnt
: waitcnt
	_xasm2>1 h1F1 _cnip
;
]
\
\
\ 2* ( n1 -- n1<<1 ) n2 is shifted logically left 1 bit
[ifndef 2*
: 2* _xasm2>1IMM h0001 _cnip h05F _cnip ; 
]
\
\
\ key? ( -- t/f) true if there is a key ready for input
[ifndef key?
: key?
	io W@ h100 and 0=
;
]

\ u*/mod ( u1 u2 u3 -- u4 u5 ) u5 = (u1*u2)/u3, u4 is the remainder. Uses a 64bit intermediate result.
[ifndef u*/mod
: u*/mod rot2 um* rot um/mod ; 
]

\ u*/ ( u1 u2 u3 -- u4 ) u4 = (u1*u2)/u3 Uses a 64bit intermediate result.
[ifndef u*/
: u*/ rot2 um* rot um/mod nip ; 
]

\ _cfo ( n1 -- n2 ) n1 - desired frequency, n2 freq a 
[ifndef _cfo
: _cfo clkfreq 1- min 0 swap clkfreq um/mod swap clkfreq 2/ >= abs + ; 
]

\ setHza ( n1 n2 -- ) n1 is the pin, n2 is the freq, uses ctra
\ set the pin oscillating at the specified frequency
[ifndef setHza
: setHza _cfo frqa COG! dup pinout h10000000 + ctra COG! ; 
]

\ qHzb ( n1 n2 -- n3 ) n1 - the pin, n2 - the # of msec to sample, n3 the frequency
[ifndef qHzb
: qHzb
	swap h28000000 + 1 frqb COG! ctrb COG!
	h3000 min clkfreq over h3E8 u*/ h310 - phsb COG@ swap cnt COG@ + 0 waitcnt
	phsb COG@ nip swap - h3E8 rot u*/ ; 
]

\ setHzb ( n1 n2 -- ) n1 is the pin, n2 is the freq, uses ctrb
\ set the pin oscillating at the specified frequency
[ifndef setHzb
: setHzb _cfo frqb COG! dup pinout h10000000 + ctrb COG! ; 
]

\ crcl ( -- ) cr and clear the line (for an ansi terminal)
[ifndef crcl
: crcl ." ~h0D~h1B~h5B~h4B" ; 
]

\ hm ( -- ) ansi home
[ifndef hm
: hm ." ~h1B~h5B~h48" ; 
]

\ hmclr ( -- ) ansi home and clear screen
[ifndef hmclr
: hmclr ." ~h1B~h5B~h48~h1B~h5B~h4A" ; 
]


\
\ #C ( c1 -- ) prepend the character c1 to the number currently being formatted
[ifndef #C
: #C
	-1 >out W+! pad>out C!
	
;
]

\
\ _nf ( n1 -- cstr ) formats n1 to a fixed format 16 wide, leading spaces variable, one trailing space
[ifndef _nf
: _nf
	<# bl #C # # # h2C #C # # # h2C #C # # #  h2C #C # # # #>
	dup C@++ bounds
	do
		i C@ dup isdigit swap todigit 0<> and  
		if
			leave
			
		else
			bl i C!
		then
	loop
;
]

\
\ .num ( n1 -- ) print n1 as a fixed format number
[ifndef .num
: .num
	_nf .cstr
;
]

[ifndef freeDictStart
\ freeDictStart ( -- addr ) the start address of the unused dictionary, long aligned
: freeDictStart
	here W@ alignl
;
]

[ifndef freeDictEnd
\ freeDictEnd ( -- addr ) the end address of the unused dictionary, long aligned
: freeDictEnd
	dictend W@ h3 andn
;
]

[ifndef zeroFreeDict
\ zeroFreeDict ( -- ) zeros out all the unused dictionary
: zeroFreeDict
	freeDictEnd freeDictStart
	do
		0 i L!
	h4 +loop
;
]


\ This block is low level code which sets up and manipulates the assembler necessary 

\ variable definitions and addresses for assembler routines

\
\ _la_asample41+ ( baseaddr numsamples samplecycle triggerbefore triggerafter triggermask -- numsamples)
\ _la_asample18+ ( baseaddr numsamples samplecycle triggerbefore triggerafter triggermask -- numsamples)
\ _la_asample4 ( baseaddr numsamples samplecycle triggerbefore triggerafter triggermask -- numsamples)
\ _la_sample1 ( baseaddr startcount -- numsamples )
\

lockdict create _la_asample41+ forthentry
$C_a_lxasm w, h12A  h113  1- tuck - h9 lshift or here W@ alignl cnt COG@ dup h10 rshift xor h3 andn xor h10 lshift or l,
z2WiQBB l, z1SyLI[ l, z2WiQ3B l, z1SyLI[ l, z2WiPuB l, z1SyLI[ l, z2WiPmB l, z1SyLI[ l,
z2WiPeB l, z1SyLI[ l, z2WiPZB l, z2WiPRD l, z3jFPuH l, z3jFQ3H l, z2WiQFl l, z2WiQ7k l,
z20iQ3E l, z8FQBC l, z3riQ3E l, z2WiQFl l, z20yPW4 l, z3[yPf[ l, z1SV01X l,
freedict

lockdict create _la_asample18+ forthentry
$C_a_lxasm w, h131  h113  1- tuck - h9 lshift or here W@ alignl cnt COG@ dup h10 rshift xor h3 andn xor h10 lshift or l,
z2WiQBB l, z1SyLI[ l, z2WiQ3B l, z1SyLI[ l, z2WiPuB l, z1SyLI[ l, z2WiPmB l, z1SyLI[ l,
z1SyLI[ l, z2WiPZB l, z2WyPij l, z24yPfi l, z2WiPRD l, z3jFPuH l, z3jFQ3H l, z2Wi\yl l,
z2WiQ7k l, z20iQ3E l, z3riQ3E l, z2Wi]7l l, z20i[m2 l, z3[yPf\ l, z2WiPeB l, z8F\uC l,
z20i\J2 l, z20yPW4 l, z3[yPfd l, z1SV01X l, 0 l, 0 l,
freedict

lockdict create _la_asample4 forthentry
$C_a_lxasm w, h135  h113  1- tuck - h9 lshift or here W@ alignl cnt COG@ dup h10 rshift xor h3 andn xor h10 lshift or l,
z2WiQBB l, z1SyLI[ l, z2WiQ3B l, z1SyLI[ l, z2WiPuB l, z1SyLI[ l, z1SyLI[ l, z1SyLI[ l,
z2WiPZB l, z2WyPij l, z24yPb1 l, z1Ki\3D l, z24yPfn l, z2WiPRD l, z2Wi][j l, z1Ky][n l,
z20i[B2 l, z20i[J2 l, z20y[G1 l, z3[yPfX l, z1Gy]Cd l, z2Wi04k l, z1SV04l l, z2WiPeB l,
z8F]ZC l, z20i\R2 l, z20yPW4 l, z3[yPfe l, z1SV01X l, z2Wi07l l, z1SV000 l, z3jFPuH l,
z3jFQ3H l, 0 l,
freedict

lockdict create _la_asample1 forthentry
$C_a_lxasm w, h12E  h113  1- tuck - h9 lshift or here W@ alignl cnt COG@ dup h10 rshift xor h3 andn xor h10 lshift or l,
z2WiQBB l, z1SyLI[ l, z2WiPZB l, z2WyPij l, z24yPb1 l, z1Ki[JD l, z24yPfg l, z2WiPRD l,
z2Wi\fd l, z1Ky\fg l, z20iZR2 l, z20iZZ2 l, z20yZW1 l, z3[yPfR l, z1Gy\S[ l, z2Wi04e l,
z1SV04f l, z2WiPeB l, z8F\eC l, z20i[e2 l, z20yPWG l, z3[yPf\ l, z1SV01X l, z2Wi07l l,
z1SV000 l, z3ryQ80 l, 0 l,
freedict


\ this variable which is used to synch the 4 cogs which are doing interleaved sampling
variable _la_s1time

wvariable _la_s1addr

\ this variable value is the first of 4 sequential cogs used to sample every clock cycle, default to this cog 2

wvariable _la_s1cog 2 _la_s1cog W!
wvariable _la_s1size

\ _la_is1 ( -- ) this is the interleaved routine used by 4 cogs to sample very clock cycle
: _la_is1
	_la_s1addr W@ cogid _la_s1cog W@ - 2* 2* +
	_la_s1time L@ cogid _la_s1cog W@ - +
	_la_asample1
	2* 2* _la_s1size W!
;

\ _la_sample1 ( baseaddr numsamples samplecycle triggerbefore triggerafter triggermask -- numsamples)
: _la_sample1
	3drop 2drop
	_la_s1addr W!
	_la_s1cog W@ dup cogreset
	1+ dup cogreset
	1+ dup cogreset
	1+ cogreset
	zeroFreeDict
	h10 delms
	clkfreq cnt COG@ + _la_s1time L!
	c" _la_is1"
	dup _la_s1cog W@ cogx
	dup _la_s1cog W@ 1+ cogx
	dup _la_s1cog W@ 2+ cogx
	_la_s1cog W@ h3 + cogx
	_la_s1time L@ h8000 + 0 waitcnt drop
	_la_s1size W@
;

\ _la_sample ( baseaddr numsamples samplecycle triggerbefore triggerafter triggermask -- numSamples )
: _la_sample
	h4 ST@ h310 >=
	if
		h3 ST@ h29 >=
		if
			_la_asample41+
		else

			h3 ST@ h12 >=
			if
				_la_asample18+
			else

				h3 ST@ h4 =
				if
					_la_asample4
				else
	
					h3 ST@ 1 =
					if
						_la_sample1
					else

						3drop 3drop 0
					then
				then
			then
		then
	else
		3drop 3drop 0
	then
;

variable _la_mask -1 _la_mask L!


\ _la_displayPin ( n1 n2 -- ) show 128 samples starting at position n1 for pin n2
: _la_displayPin
	>m dup _la_mask L@ and
	if
		swap 2* 2* freeDictStart + h200 bounds
		do
			i L@ over and if h2D else h5F then emit
		h4 +loop
	else
		drop
		h80 0
		do
			h58 emit
		loop
	then
	drop
;


wvariable _la_current 0 _la_current W!
wvariable _la_end h80 _la_end W!

variable _la_trigger 0 _la_trigger L!
variable _la_triggerEdge 1 _la_triggerEdge L!
variable _la_lastTriggerEdge 1 _la_lastTriggerEdge L!

variable _la_triggerFrequency 0 _la_triggerFrequency L!

variable _la_sampleInterval h28 _la_sampleInterval L!
variable _la_lastSampleInterval h28 _la_lastSampleInterval L!

variable _la_L10nc
\ _la_L10nc 10,000,000 / (clkfreq/1000) - the number of nS per clock count x 10
h989680 clkfreq h3E8 u/ u/ _la_L10nc L!

\ _la_L1 ( n1 -- ) emit n1 as decimal ###.#
: _la_L1
	hA u/mod swap <# # drop h2E #C # # # #> .cstr
;

\ _la_LST ( n1 -- ) emit n1 in (x)Seconds format
: _la_LST
	_la_L10nc L@ u* dup h2710 <
	if
		_la_L1 ."  nS"
	else
		h3E8 u/ dup h2710 <
		if
			_la_L1 ."  uS"
		else
			h3E8 u/ dup h2710 <
			if
				_la_L1 ."  mS"
			else
				drop
	thens
;

\
\ _lacv ( -- ) print out vertical lines every 16 position leaving 2 spaces at the beginning
: _lacv
	h11 spaces h7C emit
	h7 0
	do
		hF spaces h7C emit
	loop
	cr
;

\
\ _la_interval ( n1 -- ) adjust the sample interval by n1
: _la_interval
	_la_sampleInterval L@
	dup _la_lastSampleInterval L!
	over +
	_la_sampleInterval L!
	0<
	if
		_la_sampleInterval L@ h12 <
		if
			_la_sampleInterval L@ h4 <
			if
				1
				_la_triggerEdge L@ _la_lastTriggerEdge L!
				0 _la_triggerEdge L!
			else
				h4
			then
			_la_sampleInterval L!
		then
	else
		_la_sampleInterval L@ h12 <
		if
			_la_sampleInterval L@ h4 <
			if
				h4
				0 _la_triggerEdge L!
			else
				h12
			then
			_la_sampleInterval L!
		then
	then
	_la_lastSampleInterval L@ 1 =
	_la_sampleInterval L@ 1 <> and
	if
		_la_lastTriggerEdge L@ _la_triggerEdge L!
	then

;

\
\ _la_dStart ( flag flag n1 -- 0 -1 ) adjust the starting diplay position
: _la_dStart
	_la_current W@ + 0 max
	_la_end W@ h80 - 0 max min
	_la_current W!
	2drop 0 -1
;

\
\ _la_pin ( n1 -- ) adjust the trigger pin
: _la_pin
	_la_trigger L@ + 0 max h1F min
	_la_triggerEdge L@ 0= _la_sampleInterval 1 =  or
	if
		0 _la_triggerFrequency L!
	else
		dup hF0 qHzb _la_triggerFrequency L!
	then
	_la_trigger L!
;

\ _la_k1 ( key flag -- key flag ) process key input
: _la_k1
	over h7A = if
		-1 _la_dStart
	else over h78 = if
		h-A _la_dStart
	else over h63 = if
		h-64 _la_dStart
	else over h76 = if
		h-3E8 _la_dStart
	else over h5A = if
		1 _la_dStart
	else over h58 = if
		hA _la_dStart
	else over h43 = if
		h64 _la_dStart
	else over h56 = if
		h3E8 _la_dStart
	else over h61 = if
		-1 _la_interval
	else over h73 = if
		h-A _la_interval
	else over h64 = if
		h-64 _la_interval
	else over h66 = if
		h-3E8 _la_interval
	else over h67 = if
		h-2710 _la_interval
	else over h41 = if
		1 _la_interval
	else over h53 = if
		hA _la_interval
	else over h44 = if
		h64 _la_interval
	else over h46 = if
		h3E8 _la_interval
	else over h47 = if
		h2710 _la_interval
	thens
;

\
\ _la_h ( -- ) display header   \ 20130325 DAW whitespace
: _la_h
\	hm crcl
	hm 
	."  Sample  <ENTER>" space space 
	."  Quit    <ESC>" space space 

\\	."     Trigger Pin      -q    +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then crcl
	."  Trigger Pin -q +Q: " _la_triggerEdge W@ 0= if ." NONE" else  _la_trigger L@ . then space
\ \\\	."    Trigger Edge   -w +W SPACE: " _la_triggerEdge L@ 0=
\ \\\		if ." NONE" else  _la_triggerEdge L@ 0< if ." --__" else  ." __--" else  then then crcl
	."  Trigger Edge -w +W SPACE: " _la_triggerEdge L@ 0=
		if ." NONE" else  _la_triggerEdge L@ 0< if ." --__" else  ." __--" else  then then space 
	." Trigger Frequency  eE : "
	_la_triggerEdge L@ if _la_triggerFrequency L@ .num else ." NO TRIGGER FOUND" then crcl
		
\ \\\\	." Sample Interval -asdfg +ASDFG: " _la_sampleInterval L@ dup _la_LST  .num ." clock cycles" crcl
	." Sample Interval -asdfg +ASDFG: " _la_sampleInterval L@ dup _la_LST ."  ==  "   . ." clock cycles" crcl

\ \\	."          Sample     <ENTER>" crcl
\ \\	."          Quit         <ESC>" crcl

\ \\\\	." Sample Display  -zxcv  +ZXCV : " _la_current W@ .num ." clock cycles of " _la_end W@ .num crcl

	." Sample Display  -zxcv  +ZXCV -- Displaying samples : " 
        _la_current W@ dup . 
        ." to " 
        128 + . 
        ." of " 
        _la_end W@ . 
        ."  Samples Total  "  crcl

;


\ _la_k ( -- key flag ) process key input
: _la_k
\ ( key 0 -- )
	key 0
	over h71 = if
		-1 _la_pin
	else over h51 = if
		1 _la_pin
	else over h65 = if
		_la_trigger L@ h3E8 qHzb _la_triggerFrequency L!
	else over h45 = if
		_la_trigger L@ h7D0 qHzb _la_triggerFrequency L!
	else over h20 = if
		0 _la_triggerEdge L!
		0 _la_trigger L!
		0 _la_triggerFrequency L!
	else over h77 = if
		-1 _la_triggerEdge L!
		0 _la_pin
	else over h57 = if
		1 _la_triggerEdge L!
		0 _la_pin
	else over hD = if
		_la_sampleInterval L@ 1 =
		if
			hmclr
		then
\ _la_sample ( baseaddr numsamples samplecycle triggerbefore triggerafter triggermask -- numSamples )
			zeroFreeDict
			freeDictStart
			freeDictEnd over - 2/ 2/
			_la_sampleInterval L@

			_la_triggerFrequency L@
			if
				_la_triggerEdge L@ 0>
				if
					0
					_la_trigger L@ >m
					dup
				else
					_la_trigger L@ >m
					0
					over
				then
			else
				0 0 0
			then
			_la_sample
			_la_end W! 
\		then

		2drop 0 -1
	else over h1B = if
		2drop -1 -1
	thens
	_la_k1
;

\
\ lac ( -- )
: lac
	0 _la_pin
	zeroFreeDict
	hmclr _la_h

	begin
		0
		begin
			drop key?
			if
				_la_k _la_h
			else
				0 0
			then
		until
		dup 0=
		if
			h20 0
			do
\				_lacv       \ white space
				space space
				_la_current W@ h10 + h80 bounds
				do
					h7 spaces _la_current W@ _la_sampleInterval L@ i u* + _la_LST h7C emit 
				h10 +loop
				cr
\				_lacv       \ white space

\\				i h4 bounds
				i h8 bounds
\\				i d16 bounds
				do
					h1F i - dup <# # # #> .cstr
					_la_current W@ swap _la_displayPin
					crcl
				loop
\\			h4 +loop
			h8 +loop
\\			d16 +loop
			hm
		then

	until
	hmclr
;



\ la_displaySamples ( n1 n2 -- ) display samples starting at position n1 for 8 pins starting at pin n2
: la_displaySamples
	dup h8 + swap
	do
		i <# # # #> .cstr
		dup i _la_displayPin
		cr
	loop drop
;

\ la_sampleNoTrigger ( n1 -- ) sample every n1 clocks and display 128 samples starting from position 0
: la_sampleNoTrigger
	>r
	freeDictStart freeDictEnd over - 2/ 2/
	r>
	0 0 0 _la_sample drop
 	0 0  la_displaySamples
 	0 h8  la_displaySamples
 	0 h10 la_displaySamples
 	0 h18 la_displaySamples
;

\ la_sample+Trigger ( n1 n2 -- ) sample every n1 clock +ve edge and display 128 samples starting from position 0,
\ trigger on pin n2
: la_sample+Trigger
	>r >r
	freeDictStart freeDictEnd over - 2/ 2/
	r>
 	0 r> >m dup _la_sample drop
 	0 0  la_displaySamples
 	0 h8  la_displaySamples
 	0 h10 la_displaySamples
 	0 h18 la_displaySamples
;

\ la_sample-Trigger ( n1 n2 -- ) sample every n1 clock -ve edge and display 128 samples starting from position 0,
\ trigger on la_triggerPin
: la_sample-Trigger
	>r >r
	freeDictStart freeDictEnd over - 2/ 2/
	r>
 	r> >m 0 over _la_sample drop
 	0 0  la_displaySamples
 	0 h8  la_displaySamples
 	0 h10 la_displaySamples
 	0 h18 la_displaySamples
;

\  commented source code removed


\ now save and reset

saveforth


reboot

\  be sure to include the final line terminator ( a carrage return)

}}}

Set the sample to 41 clocks to caputure 2754 samples

Trigger from the pin on the button you wish to touch, 

collect a sample

I saw the LED transition about 640ns after the button transistion, usuallly after sample 1600




- End 20130403 -