#summary Low Level Support for Prop Arrays - COMMS
#labels v3.6,Phase-Design,parallel,draft,V4.0ALPHA

Also see the single prop example:

http://code.google.com/p/propforth/wiki/HiSpeedSerialOneProp

= Introduction - COMMS =

As of PropForth 3.6 Beta, there exists support for high speed serial communications between props. This permits the eight cogs in a single prop to communicate with cogs in up to eight slave cogs.  Each slave may also be a sub-master to up to seven sub-slaves. Sub-masters and sub-slaves may be continued as needed.

This capability may provide the basis for a micro-controller array "supercomputer". If you have a very broad idea of "supercomputer", maybe super-controller is more accurate.

EDIT - The team have decided that using "high speed inter-prop communications using Beau's method and adding a application protocol layer" in reference to this topic makes discussions cumbersome.  That's still what it is about, but we are going to use COMMS to refer to this topic. 

= Draft =

== PropForth 3.6 Beta Inter Prop High Speed Serial Communications ==

Notes from conference call only - documentation DRAFT

As of ProForth 3.6 the inter prop high-speed serial communications (COMMS) seems to be working

Notice this is a draft, code has not been posted until the tutorial makes sense

= com.f =

Forth source code file com.f contains the core for inter-prop communications

It doesn't actually start anything.

This file contain examples for experiments

Set up 2 props using pins 14 and 15 

Put a 200 to 400 ohm resistor between each of the two pin to pin connections between props

Use a low ohm value to keeps the signal edges sharp. 

This experiment used 360 ohm because the were handy in the box. 

= comnorom.f =

Forth source code file comnorom.f contains inter-prop communications for the slave portion of the setup.  This add support to the com functions so that ROM-less slave may be loaded from the master.

First load com.f, them load comnorom.f, them saveforth.

Following connections are required for these experiments:

MASTER    Slave   Reset
Pin 28    Pin 29  12-12

[check this]

MASTER transmit - SLAVE receive  - pin 29 - via a 220 ohm resistor
MASTER receive  - SLAVE transmit - pin 28 - via a 220 ohm resistor

Master's master channel (output) connects to slave's master (input).  Needs 200-300 ohm resister in line 

Slave's slave channel (output) connect to master's slave (input).  Needs 200-300 ohm resister in line 

10k pull up on port 29 decimal [SLAVE receive]

(per Page 17 of the printed prop manual.  Master is emulating slave's eeprom; then using this line for COMMS channel)


------

search for definition of word {{{ree}}}

{{{ree}}} - Assembler and pins; 2 strings Master and Slave
    - variable for Master

onboot - redefined to stop other cogs.  

       - Sets cog 6 (and cog 7 for serial)

       - look for a master for master

Here's the magic:

Master sends a frequency on master's channel pin 

Slave sends a different frequency on slave's channel pin

master-init cog4 last (?)

slave-init (?)

on reset5 - master or slave cog5

  - master on remote rom, reset, 

  - a_ree an assembler routine,  does rom emulation

  - shadow master 
  
NOTE: fl (fastload) is on MASTER only.  always need to manually load this definition of fl for the time being

[the code for the verions of fast load fl that must be manually loaded is at the bottom of the file]

[ or is it the code of curly backets?]

{ - curly backet means commented out in the context of fastload 

MUST BE LOADED ON MASTER

do a saveforth

= com.f again =

== Line 641 ==

Test com channel ahead- 

cmd>ch   "command to channel"
fl>ch  "fastload to channel"

cmd>ch

C" xxxx" N1 cstr

channel address cha   N1=0, 1, 2, 3, 4, chanel1    cstr is c" xxxxx"

cha 0 fl>ch to remote

a_mastercom

== line 194 == 

=== structure master ===

== 214 ==

04-14 same as inbyte

14-24 buffer

24-34 cog emit pointer

      set to 0 just throw the data away (when no terminal)
      
      Channels send (one side) and receive (other side) constant 96 bit packets always

      watches checksum to notice errors

      chnoiser line 839 for injecting noise during test to verify the mechanism can 
detect noise errors
      
  Channel reciev speed

    about 4megabits persecond

    protocol comsumes about 1/3 of bandwidth? 

    (((clock speed)/2)/8) = ??? no , the math is not correct
    
  This method can be used on a single chip

     define Master on Channel A

     and Slave on Channel B
     
     Start 2 cogs.
     
  End of notes 