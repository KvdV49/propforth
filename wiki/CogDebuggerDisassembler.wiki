#summary Debugger and Disassembler for Propeller
#labels debugger,disassembler,v2.7

= cogdbg =

NOTE: this needs the assemler timeslicer to be loaded first!

The debugger and disassembler is an extension to propforth.

The debugger steps through forth definitions above a specified memory address.

The disassembler converts (machine code) bytes at a given address into assembler opcodes.  If the address given is NOT valid machine code, the disassembler will function regardless, and display what those bytes represent when considered as machine code.  

The disassembler does not care if the machine code was generated from forth, spin, or manually constructed by a programmer.

The cryptic names are scheduled to be revised in future release.  

= Prepare Deluxe Serial Monitor =

These instructions assume that Deluxe Serial Monitor has been loaded as described in

DeluxeSerialMonitor

and the image habeen save to eeprom

_Cog5 ok_

*reboot

_Cog7 ok_

_PropForth v2.7 2010MAY26 14:50 2_

_Cog5 ok_


= Loading the debugger and disassembler into propforth =

 * use CTL+A to communicate with Cog5 if not already

_Cog5 ok_

 * Open cogdbg.f / CogDebuggerDisassembler.f using a text editor

 * Paste the entire contents, including the blank lines and  FL at the begining to the blank lines at the end, into Teraterm

The last definition to compile should be dterm, which spans several lines

_
: dterm   . . .
        then drop ;
_

*Cog5 ok

The debugger is now loaded

= test verify the debugger =

* Load the example routine to be debugged

From the top of the comments section of cogdbg.f / CogDebuggerDisassembler.f, copy the definitions for "underscore"t and fib into teraterm

NOTICE the above word identifier has "underscore" in it where the character underscore should be due to the formatting method of code.google.com.

{{{
: _t dup rot u* swap 1- ;

: fib 2 max dup 1- begin _t dup 0= until drop ;
}}}

Verify forth is running in some cogs, Cog 5 and Cog 6 are used in this example

*cog?

_Forth cogs: 5 - 6_

_Cog5 ok_

CTL+A to Cog 6

_>6_

< hit a return here to display the prompt >


_Cog6 ok_

Type in 

*10 fib .

And verify the output:

_77758000_

Type in 

{{{
' dterm 5 dterm
}}}

The preceding means: Begin debugging for definitions above the address of dterm; do it on COG 5

_Cog5 ok_


NOTICE: The propforth interface (the serial driver on cog7) is STILL talking to cog6, and cog6 is looking at Cog5.  

_CTL-d exit CTL-n forth single step CTL-o forth/asm continue_

Type in:

*cogdbg

*5 don fib doff

This puts the number 5 on the cog 5 stack, starts the debugger on the word fib, runs the word fib, and turns the debugger off again.

NOTICE: the stack display for the debugger is backwards in v2.7 (New values are displayed on the left instead of the right).  This a bug is to be fixed in v3.0 or later.

  _tregs: 00000017 000055CA 000055CA 00000062 000017BE 00000A9A_

  _ST: 00000005 00000A94_

  _RS: 2B0A:17B0 execute 2BFC:2AD8 interpretpad 3C4A:2BBE interpret_

_>{55CE 006A 13C0} 0002_

  _{55D2 13F0 13EC} max_

  _{55D4 0032 13A2} dup_

  _{55D6 1B36 1B32} 1-_

  _{55D8 55BC 55B8} "underscore"t_

  _{55DA 0032 13A2} dup_

  _{55DC 1AEC 1AE8} 0=_

  _{55DE 00D8 147E} 0branch FFF8 {55D8}_

  _{55E2 0011 1398} drop_


CTL+n steps through the word (assebler tokens) or into the word (forth tokens)

CTL+o executes to the end (of the word highest level word).

CTL+d leave the debugger and go back to the original cog (cog 6 in this case)

NOTICE: Commands STEP-OVER-WORD and STEP-OUT-OF-WORD have not been implemented at this time.

Type CTL+n to step to the next token:

   _tregs: 0000006A 000055CA 000055CA 00000062 000017BE 00000A9A_

   _ST: 00000002 00000005 00000A94_

   _RS: 2B0A:17B0 execute 2BFC:2AD8 interpretpad 3C4A:2BBE interpret_

   _{55CE 006A 13C0} 0002_

_> {55D2 13F0 13EC} max_

   _{55D4 0032 13A2} dup_

   _{55D6 1B36 1B32} 1-_

   _{55D8 55BC 55B8} "underscore"t_

   _{55DA 0032 13A2} dup_

   _{55DC 1AEC 1AE8} 0=_

   _{55DE 00D8 147E} 0branch FFF8 {55D8}_

   _{55E2 0011 1398} drop_

   _{55E4 0073 13B0} ;_

Type CTL+o to execute to the end of the calling word


   _tregs: 00000011 00000001 00000000 00000078 000055DE 00000A9A_

   _ST: 00000078 00000A94_

   _RS: 2B0A:17B0 execute 2BFC:2AD8 interpretpad 3C4A:2BBE interpret_

   _{55CE 006A 13C0} 0002_

   _{55D2 13F0 13EC} max_

  _{55D4 0032 13A2} dup_

  _{55D6 1B36 1B32} 1-_

  _{55D8 55BC 55B8} "underscore"t_

  _{55DA 0032 13A2} dup_

  _{55DC 1AEC 1AE8} 0=_

  _{55DE 00D8 147E} 0branch FFF8 {55D8}_

  _{55E2 0011 1398} drop_

_> {55E4 0073 13B0} ;_

  _0058 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0059 00004660 IF_NEVER    WRBYTE 23 , 60_

  _005A 00004660 IF_NEVER    WRBYTE 23 , 60_

  _005B 00004660 IF_NEVER    WRBYTE 23 , 60_

  _005C 00004660 IF_NEVER    WRBYTE 23 , 60_

  _005D 00004660 IF_NEVER    WRBYTE 23 , 60_

  _005E 00004660 IF_NEVER    WRBYTE 23 , 60_

  _005F 00004660 IF_NEVER    WRBYTE 23 , 60_

_> 0060 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0061 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0062 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0063 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0064 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0065 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0066 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0067 00004660 IF_NEVER    WRBYTE 23 , 60_

  _0068 00004660 IF_NEVER    WRBYTE 23 , 60_

_Cog5 ok_

_Cog5 ok_

*st?

_ST: 00000A94 00000078_

To exit the disassembler, use CTL+D

_Cog5 ok_

_Cog6 ok_


= decompile fib =

To run the decompiler on the word "fib":

_Cog5 ok_

*decompile fib

The decompiler displays from the dictionary entry to the terminating semi colon:

  _{addr pfa  nfa }_

  _{     55CE 55CA} fib_

  _{55CE 006A 13C0} 0002_

  _{55D2 13F0 13EC} max_

  _{55D4 0032 13A2} dup_

  _{55D6 1B36 1B32} 1-_

  _{55D8 55BC 55B8} "underscore"t_

  _{55DA 0032 13A2} dup_

  _{55DC 1AEC 1AE8} 0=_

  _{55DE 00D8 147E} 0branch FFF8 {55D8}_

  _{55E2 0011 1398} drop_

  _{55E4 0073 13B0} ;_


Notice in the above the 0branch assembler instruction FFF8 is at location 147E and its parameter field is at 00D8.  Remember, assembler addresses below 512 (decimal) are  COG LOCAL Assembler routines.

Do a memory dump of the 16 bytes at location 147E:

*147E 10 dump

_147E 0010:_

_147E: 07 30 62 72 61 6E 63 68 D8 00 7E 14 06 28 6C 6F    0branch ~  (lo_

_Cog6 ok_

Disassemble COG address D8 to see the cog-local machine code disassembled:

*d8 dis

_00D8 5CFDF0F0 IF_ALWAYS   JMP F8 , # F0 wr_

_Cog6 ok_

Typing dis again steps through the routine each time:

*dis

_00D9 867E1200 IF_ALWAYS   SUB 109 , # 0 wz_

_Cog6 ok_

*dis

_00DA 5C68001B IF_Z        JMP 0 , # 1B_

_Cog6 ok_

*dis

_00DB 5C7C006C IF_ALWAYS   JMP 0 , # 6C

_Cog6 ok_

*dis

_00DC 5CC1F0F8 IF_NEVER    JMP F8 , # F8 wr

_Cog6 ok


*dis

_00DD 083E07F0 IF_ALWAYS   WRLONG 103 , 1F0

_Cog6 ok

Disassemble starting at address 0 (in this cog's memory space):

*0 dis

_0000 5C7C0075 IF_ALWAYS   JMP 0 , # 75_

_Cog6 ok_

Notice that this code is a jump to location 75(H)

Disassemble from 75:

*75 dis

_0075 5CC1F0F8 IF_NEVER    JMP F8 , # F8 wr_

_Cog6 ok_

Notice that this instruction is a jump to location F8

This is where the ASSEMBLY TIMESLICED routines get hooked in

*dis

_0076 5CC200FF IF_NEVER    JMP 100 , # FF wr_

_Cog6 ok_

dis
0077 04BE1305 IF_ALWAYS   RDWORD 109 , 105 wr
Cog6 ok

d7 dis
00D7 5C7C0075 IF_ALWAYS   JMP 0 , # 75
Cog6 ok

= Example of disassembling memory that is not machine code =

Clear the stack:

st?

_ST:_

_Cog6 ok_

In Propforth 2.7, the word stBot is a memory location that holds an address which is a pointer to the bottom of the stack.  

*stBot

_Cog6 ok_

*st?

_ST: 0000010F_

_Cog6 ok_

Begin disassembling at the address of stBot:

*dis

_010F 00000000 IF_NEVER    WRBYTE 0 , 0_

_Cog6 ok_

*dis

_0110 00000000 IF_NEVER    WRBYTE 0 , 0_

_Cog6 ok_



