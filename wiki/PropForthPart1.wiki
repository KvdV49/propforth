#summary Additional explanation for PropforthPart1.f
#labels v3.2

= Introduction =

The file [http://code.google.com/p/propforth/wiki/PropForthPart1 PropFrothPart1.f] contains the first part of PropForth kernel, written in forth.

The second and final part is contained in [http://code.google.com/p/propforth/wiki/PropForthPart2 PropFrothPart2.f]. 

= why parts 1 & 2?  Why not one big file? =

The PropForth kernel source code is split into two parts because of the source text buffering command fl (file load)

{{{
fl
}}}

This command buffers source text in pasted into the tera term window into unused EEPROM.  There is too much text to fit into the unused EEPROM available, splitting it in two parts and processing the the source text in two passes solves this issue. 

= Strange looking Construct appears frequently =

{{{
SomeName W@ wvariable SomeName SomeName W!
}}}

What is this weird construct?  This appears frequently in the propforth source definition files. 

[http://code.google.com/p/propforth/wiki/PropForthPart1 PropFrothPart1.f] is the source code of the RUNNING forth.  So the definition for an existing variable SomeName must appear in the source.  (otherwise, the spinmaker word would still build it into the spin file, but we wouldn't see any source code for it.)

But in the running kernel, SomeName already has a value, and we don't necessarily know what that value is supposed to be.  But we DO know that the current vaule is correct, so we use that.

So to summarrize: 

the code

{{{
SomeName W@ wvariable SomeName SomeName W!
}}}

is really

{{{
SomeName W@        /get current the value of variable we need to define
wvariable SomeName /define the variable we need in the kernel
SomeName W!        /set the variable to the same value that it had in the previous kernel
}}}

Again, the purpose is so that high level forth source code exists for the variable, and the variable gets set to the correct (current) value. 

Once you understand what is going on, the strange construct starts to look reasonable after a while.

= another strange construct that appears frequently =

{{{
' _AnAssemblerLabel  asmlabel _AnAssemblerLabel
}}}

This is the same as with the variable names above, except this is for assembler labels. 

{{{
' _AnAssemblerLabel         \ get the address of _AnAssemblerLabel and leave it on the stack
asmlabel _AnAssemblerLabel  \ create a definition for an assembler label named  _AnAssemblerLabel and assign it the value on the stack
}}}

= What does the underscore mean in the label names? =

Please see the explanation for the naming convention in ....where did I put that?

= Some prop - specific words =

\ _execasm2>1 ( n1 n2 -- n ) \ the assembler operation is specified by the literal which follows (replaces the i field)

' _execasm2>1 asmlabel _execasm2>1

\ _execasm1>1 ( n -- n ) \ the assembler operation is specified by the literal which follows (replaces the i field)

{{{
' _execasm1>1 asmlabel _execasm1>1

\ _execasm2>0 ( n1 n2 -- ) \ the assembler operation is specified by the literal which follows (replaces the i field)

' _execasm2>0 asmlabel _execasm2>0

}}}

These three words are not standard forth words, that are HAL (hardware abstraction layer) words specific to the prop. 

These words handle the three cases for constructing assembly code in the cog. 

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages