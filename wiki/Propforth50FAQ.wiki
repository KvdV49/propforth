#summary FAQ for Propforth 5.0 Release
#labels v5.0

= Introduction =

Different from earlier releases, starting with Propforth V4.5 there will be a FAQ for each release in a separate page.  This page is the Frequently Asked Questions for v5.0

Newer Topics to be added to the top.  Some questions are in the context of earlier answers, you may have to jump to the bottom.

= Question 12 Why redefine ONBOOT so many times? =

  In v4.5, many of the regression test used the technique of redefining the onboot word to change or add to the boot process.  This is a valid technique, but gets confusing if several things are going on and an earlier one needs to get changed.  

 In v5.0, the boot-time steps will will be handled in the .sfboot.f file. The onboot word (and other system housekeeping words) will be left as default where possible.  

  Notice that configurations that do not have SD hardware and support cannot use the .sfboot.f words (as these live on the SD).  Non SD configurations will likely handle boot time initialization from EEPROM, or resort to modifying the onboot word.  Since a non-SD configuration will likely be less complex, it is anticipated that this should not be a problem.   

= Question 11 Can you add "X" complex OS function to the OS? =

  Forth is not really an OS, but you can use it as if it were an OS.  The kernel provides a bunch of low level function support that we can use as we want.  "OS" implies a lot of built in house keeping that is done automatically; automagic housekeeping adds a LOT of expensive overhead.  While you can implement that if you  want (I want sometimes, and so do), this is really asking a lot from a micro controller and begins to take its toll on performance and code size.   Rather than support automatic, general overhead, the kernel itself is limited to just the functions, and we as developers use them as the application dictates.   You can decide _your application_ is an _OS_, but we interpret that as beyond the scope of the kernel. 

  So the short answer is yes, but you have to do it yourself.  The default kernel is to be kept simple, this is our design decision.

  Now, the EXTENSIONS, on the other hand, are optional; and can include the kitchen sink.  Any EXTENSIONS can be added to the package as we have done organized in sub-directories of the distributions archive. Examples are support for: Ethernet, HTTP server, NTP, Telnet server, RTC, ANSI terminal, ROM-less operation, and so on.

  We plan to include user extensions, such as caskaz's and Nick Lordi's works, as possible, in the release archive download (after we think we have the kernel stable).  We would love to include your contributions too.

  But so far, the only non-prop extensions added to the kernel were EEPROM file system support,  the SD support from caskaz and the spinneret support; and these were as extensions to the development kernel.  


=  Question 10 What is the purpose of Multi-prop / MCS? = 

  The Multi-Channel High Speed Serial Link(s) (MCS) provide a continuous, high speed channel between prop chips, and includes the transfer protocol.   The ideal is, if you need more resources for your application, you just add another prop.  Use is to be transparent to the user/application. 

  Why would one want to do this?  We think a useful application might need more than seven or eight things happening at once, or might need more than 32 pins.  We like the prop, and we have all this work in place, so we add more props.

  For example, one cog can control 16 servos (eight on each counter), and two cogs can control 32 servos; but this configuration would consume all the I/O pins and would not allow inputs, and leaves 6 cogs un-occupied.   With Multi-prop, once could have two cogs (or more) running 16 servos each , a cog (or multiple cogs) monitoring sensor inputs, a cog reading and writing to the SD card (or multiple cogs managing SD cards) , a cog talking to the FPU coprocessor (or mutiple cogs managing external coprocessors), a cog reading the GPS, a cog talking over ethernet, etc, etc; and cog acting as master sending request to the other cogs to get the datastreams processed.  
  
  The goal is simply to do experiments with multi-prop.  It may or may not work, we may or may not find it useful.  But its fun and keeps us busy. 

= Question 9 The Multi-prop stuff in 4.5 did not go beyond 1 slave, is this fixed? =

  The Multi-prop support (see test-4.3.2) did work, but automatic support for a slave was only implemented for the first level slave.  Slaves 2 through Slave N _can_ work, but you have to start them manually.  We did not include the manual steps for additional slaves in the regression tests; Sal was too busy and I could not make the time.   

  In v5.0, the configuration for the slaves is handled in boot scripts on the SD.  The slave boot scripts will be in a file named something like .sfboot.f on the SD card. 

  The current plans include a regression test that can be used as a template for N-props.  

= Question 8 Version 4.x was fine, why are you messing with the kernel?  =

  V3.6 was "good enough to use" as a forth kernel, but did not use enough things that are special about the prop. 
 
  V4.5 was "good enough to demo stuff" so we could get an idea of what could be done on the prop, but could not really be used in a final application. Too big memory foot print, not optimized; the optimizations were hindered by other bottlenecks. 

  V5.0 Shows what the prop can do, and leaves enough resource so we can do something.   It provides ways to work within the props constraints to overcome common "limitation" complaints.  The degree of success has not been determined, but it looks kind of interesting.  While previous versions 'seemed' fast, V5.0 'blows them away'.  

= Question 7 What are these weird strings that are not hex values but seem like they should be?  =

  Oh, you noticed that.  OK, this is a bit neat, but doesn't affect anything.  Sort of.  FORTH supports any number base up to machine size.   Sal has decided the forth machine supports up to BASE 64.  This way, any value for a 'long' can be encoded in 6 characters (instead of 8 characters in HEX or 10 or more character in decimal etc).  Using BASE 64 to read in values for longs reduces the interpreter activity by 25% over hex (6 characters instead of 8 for each transfer).   This happens quite frequently with the paged assembler, so the savings is significant.  Also, this is internal to forth, at this point; so while it LOOKS weird, it should not affect anything we the user/developer has to deal with.  If this proves to be incorrect, or in some way flawed, it can be corrected as appropriate. 

  This is actually an old technique, and its use is well established.  (Google Base64 and find wiki entry.  UUencode is an example).  I still think it kind of a neat trick.

=  Question 6 What's the deal with number base?  =

  Each Cog has its own number base setting.  Since one cog is running the interpreter and another is running the interface, its easy to get confused and have the wrong cog set to decimal or hex.  This is how Sal sorted it out.

  == Boot Kernel ==

  By default, the prop likes hexadecimal, so the BOOT KERNEL defaults to hex.  

  == Development Kernel ==

  By default, humans work in decimal, so in the development kernel in the  onreset word, the number base  is set to decimal.   

But we frequently want to input number in HEX. SOOOOOOOOOO support has been added so we can input HEX values even when the number base is not hex.    That is any string prefixed with an 'x' and containing 0-9 and/or 'A-F' is interpreted as a HEX value.  The string x1000 is interpreted as value 4096 decimal. The string  xAF00 is interpreted as 
44,800 decimal.  Nifty!

=  Question 5 Can multiple "paged assembler" (see question 3) words be brought in at the same time? =

   Yes, but you have to write them that way.   The current example is the SD support in v5.0.   All the assembler support words are in a single "unit" and the actual function called drives a switch statement.   So if you want to read, or write, or open a file, or close a file etc, the switch statement jumps around reading and writing until the SD access is finished.  When the SD access is complete, the paging buffer is free until the SD is called again.  If SD is still resident, it get called, or gets paged in again. 

=  Question 4 What is "Scripting Optimization"? =

  What we are calling "Scripting" involves running forth code from the SD card.  A section of the SD card can contain a "script" of forth words.  When called, the script is interpreted, and executed as if it were a forth definition.  The script does whatever it does, and leaves whatever results where-ever it needs to, and its done. No additional dictionary space was consumed for this script.

  Optionally, the SD card may contain forth colon definitions.  These definition are added to the dictionary, and can be called as needed.  When these definitions are no longer needed, they can be "forgotten".  This allows the definitions to be called repeatedly, but ultimately do not consumer any dictionary space. 

  Using this technique, one may achieve application of any size and any complexity.  There is no longer any need to worry about a "32K limit" in program size.   Just as an Intel processor has (or used to have) a 32k cache, the prop hub memory can be viewed as a "32k cache" with programs of any size.  Also, the SD card may be viewed as 2Gig, 4Gig, 8Gig etc of expanded RAM.  It is not, but we are going to pretend it is and see how far we get.   At present we think its cheaper and easier than adding actual RAM, and initial tests indicate it can be plenty fast if used appropriately. 

= Question 3 How do the assembler optimizations work? =

  Previously, we had to do messy things to get the assembler optimizations into the dictionary.  This has been simplified.  (We have to ask caskaz, Brian, and Nick for details, I did not do any assembler work on the early releases).

  Now the assembler words are handled in two ways: pages words and persistent words.

  == Persistent Words ==

  What we are calling  "Persistent Words" are assembler definitions that are called once and intended to be left running.  An example is the SERIAL driver word.  This word handles communication between the serial connection (to the PC terminal) and the running Forth interpreter.  This word is optimized in assembler, called as boot time, and left running during development and is left running in the final application. 

  == Paged Words ==

 Pages words are paged in and out of memory as needed.  When a paged word is called, the optimized assembler definition is brought into memory (there is a buffer for these words). The word is executed like any other forth word (and is very fast, being assembler).   If the word is called again and is still in memory, it is executed.  If another word is called, the new definition is pulled into the buffer.  This means the dictionary does NOT need to be filled with assembler definitions.   While the transfer does take time and is relatively slow, the there is a significant net gain in speed and a significant net gain in available memory. 

 === How big are pages words? ===
  
  So far the biggest paged word is "ACCEPT" at x2A bytes.  The buffer is slightly larger than this word at x30 (40 decimal) bytes.   MOST paged words so far are "small words" like ` + @ ! u* ` etc.  These only take a few bytes each.

  If any user encounters a case where the paged assembler buffer needs to be increased, post an issue and the size will be adjusted as needed. 

= Question 2 What Optimization are planned? =

  Sal is optimizing the kernel with assembler to reduce memory foot-print and increase speed.  

  == Memory Foot Print ==

  Cog memory now has 170 longs free

  == Profiling Execution for Bottlenecks ==

  Sal has done various analysis to confirm where the bottle necks are/were.  As is turns out, many of his assumptions were incorrect; the areas he thought were bottleneck were not, and areas that he didn't think would matter, made a big impact.  The result was he was able to determine that ACTUAL bottleneck and work on those, and ignore the "false bottle necks".   Good think he dd the profiling!  

= Question 1 Where are the Requirements listed? =

  (As in v4.5) In the Regression Test Suite.

  Traditional requirements are too expensive for our resources, and are typically too expensive for professional outfits (outside of military and aviation etc where there is contractual/legal obligation).  We are examining taking "requirements based test" one step further to "design based tests".   That is, each design element will be "completed" by a test that verifies the system operates to that design.  (An interesting result of this is that the actual coding happens last, and takes only a small part of the development cycle, and it is difficult to introduce bugs into the result). In this manner, the _regression suite_ performs the roles of design document, requirements, test, requirements  to test traceability, user manual, and tutorial.  The result is descriptively simple, yet seems to be effective. 

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages