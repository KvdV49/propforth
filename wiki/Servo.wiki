#summary Notes for Hobby Servo Support.
#labels servo,v5.3

<wiki:toc max_depth="9" />
= Servo =

This page is a supplement to to the main PROPFORTH.HTM refernce document.  Proforth.htm is included in the proforth download. When extracted,  the path to PROFORTH.htm is 

..\My Documents\GoDocs\mygo\V5.x\doc\PropForth.htm



= Basic Operation =

Hobby Servo is controlled by sending it a pulse every 20 milliseconds. The width of the pulse tell the servo the desired position, and it tries to move to that position.  The pulse can be 1.5 ms +/- 1 ms .  That is a pulse of 2.5 will ask for rotation 90 degrees. A pulse of 0.5 ms will ask for rotation of -90 degrees.  a pulse of 1.5 ms will ask the servo to move to its middle position. 

== Not always the MAX ==

Digital servos compensate, analog servos chatter or go through stops. 

Most cheaper servos do not move the full 180 degrees.  Some expensive servos move greater than 180.

Requesting the a servo to move beyond its physical limit can cause the servo to "chatter"; it hits the end stop but continues to try to move farther. We had a case where a cheap servo was used, and it broke through the end stops.  So we went conservative, and change the DEFAULT code to stop short of the usual limit.

By DEFAULT the Absolute allowable limits are 0.75 to 2.25   (1.5 is alway middle). The limits are adjustable in code.  It is suggested that users get familiar with the code and controlling the servo before changing the defaults.  Then, it is suggested to find out the max for your specific servos, and set those as the limits in software.

== One I/O pin per servo ==

One I/O pin is required to directly control a servo.  Up to 32 servos can be directly controlled using a propeller chip. This would consume at minimum two cogs. If 32 servos were used, all the I/O pins would be outputs, so it would not be easy to talk to the prop chip.

== One counter can control 8 servos ==

Instead of 1 clock 1 servo; 1 clock 8 servos, 20 ms / 2.5 = 8

To control a servo, a pulse is sent out every 20 milliseconds. While a cog is waiting until it needs to send another pulse, it can send pulses to additional servos.  The maximum pulse that will be sent to a servo is 2.5 milliseconds.  20 ms per servo / 2.5 ms = 8 servos total.  

Max time is 2.35-2.39 ms due to processing overhead. 

== One cog has two counters ==

Each cog has two counters, (A and B).  Each counter can control 8 servos.  On cog can control 16 servos.  Two cogs can control 32 servos if we wish to use up all the pins.  

== mask bit =

The software is set up to control which servos are enabled.

The word `sm_enable ` contains a bit mask to turn servos on and off.

=====>
`sm_enable `
========>
put a 1 in the bits to turn on the servo

For example:
{{{
b_1_0000_0000_0000 sm_enable 
}}} 
or
{{{
d_4096 sm_enable 
}}} 

will enable the servo on pin 12.  (There is a 1 in position 12 of the binary value, and that binary value is 4096 in decimal). 



if you want to keep RSR232 and EEPROM default lines use
{{{
h_FFF_FFFF  sm_enable 
d_268_435_455 sm_enable 
b_1111_1111_1111__1111_1111_1111_1111 sm_enable 
}}}
 
to enable all the pins 28 servos, leaving 28, 29 for EEPROM, and 30 31 for serial. 

= Pin is Servo number =

The software is designs so that Pins are related to servo number. 
Recommend NOT changing this.
 
== Usage of pin assignments ==

===> specify start pin, the servos and pin assignments proceed in sequence.  

Pin 8-24 depends on if servo is enabled, can be changed but code get complex, so don't bother.

NOTE:  check the sm_emable example above?  If this means only pins 8-23(?) are assigned for servo use? 


= same as previous versions =

In case anybody has existing code based on previous versions:  The current support is done to same as previous versions (somebody check?  I don't have the previous versions set up)

interfaces are same 

set-pause and calibrate are same 

= Smallest noticeable change = 

What is the smallest noticeable change in servo position we can achieve? 

SMALLEST NOTICE ABLE CHANGE

The default limits for the control pulses are 0.75 to 2.25 ms.  2.25 - 0.75 = range of 1.5 ms 

  * 1.5 ms = 1500uS = 1,500,000 ns

Theoretically, divide 15,000,000 ns by 12.5 ns 

  * 120,000 is DYNAMIC RANGE

To TEST - 
  * Whether or not a change of 1 will move the servo arm?
  * move to a position, mark it 
  * move it to 45 degrees
  * move it back (repeatability)

  * move to a position, mark it 
  * move it to 45 degrees (or any repeatable position that is convenient)
  * move it to position -1 to notice a change
  * keep changing position by 1 unit until a change is noticed.

Repeat this until it does not return to the the exact starting point. 
  
  * 120,000 position is    1D4C0 hex
  * 65535            is     FFFF

variable is 32 bits anyway.

== To test ==

Move to 120,000 positions (1D4C0 hex).  Some changes are too small to cause the servo to move.  Determine for a give servo the smallest positional change that can be performed. 

The number of positions is greater than 16 bits, so it wont fit in a word.  It will definitely fit in a long, but the long has more bits than we need.  be aware so junk in the the unused bits doesn't trip something up. 

The number of usable positions may be smaller than 120,000.  If the number turns out to be 65535 or less, the position value could be scaled and a word (16 bit) variable could be used. 

= note = 

change comment in line 166 and 1000 in line 168 and 176 to 120,000

= Max is probably 28 servos = 

More than 28 servos prevents us from talking to and controlling the prop, and getting to the EEPROM.  

MAX setup 28 servos

But I don't have 28 servos. How to test?   

  * two servo, leave one at the same pin
  * move one on each different pin.
  * Plug one servo is in each pin, and move both

= Deadband = 

This is not Jerry Garcia for servos.  This is the minimum value change for evoking movement from the servo. Typical specs say 4 microseconds (4uS) or 4000ns. Which is also 0.004 milliseconds. 

  * specs - deadbandwidth 4uS - this many 12.5 ns = 320 counts
  * must have at least this much variational before it moves.

  * 320 `*` 12.5 is minimum it can move.` 

----

= servo.f =

This is the text of servo.f from v5.3

{{{

fl

1 wconstantbuild_servo.f

\
\ waitcnt ( n1 n2 -- n1 ) \ wait until n1, add n2 to n1
[ifndef waitcnt
: waitcnt
	_xasm2>1 h1F1 _cnip
;
]

\ a cog special register
[ifndef ctra
h1F8	wconstant ctra 
]

\ a cog special register
[ifndef ctrb
h1F9	wconstant ctrb
]

\ a cog special register
[ifndef frqa
h1FA	wconstant frqa
]

\ a cog special register
[ifndef frqb
h1FB	wconstant frqb
]

\ a cog special register
[ifndef phsa
h1FC	wconstant phsa
]

\ a cog special register
[ifndef phsb
h1FD	wconstant phsb
]

\
\ Servo motors are controlled by a pulse width modulation (pwm).
\ Every 20 milliseconds a pulse of length 0.75 milliseconds 
\ to 2.25 millseconds determines the position of the servo motor.
\
\ Example1: 0.75ms
\ ---_____________________________________________________________________________---________
\
\ Example2: 1.5ms
\ ------__________________________________________________________________________------_____
\
\ Example3: 2.25ms
\ ---------_______________________________________________________________________---------__
\
\
\ Each servo motor requires calibration, so we will set the absolute minimum to 0.5 ms and the
\ absolute maximum to 2.5 ms. Depending on the servos you are using, you may want to adjust these
\ values. 
\

\
\ This driver will drive 16 servos per cog, it uses the 2 counters in a time domain multiplexed
\ mode to generate the pulses.
\
\ Each counter is set to single ended PWM/NCO mode. In this mode the counter drives an io pin.
\ The value of the pin is controlled by bit 31 of the phsa/phsb registers. These registers and
\ incremented every cycle of the system clock. For an 80 Mhz system clock this provides for
\ 12.5 ns resolution.
\
\ Without intervention the phsa/phsb registers would generate a square wave with the cycle time
\ being more than 50 seconds
\ ----------------------____________________----------------------____________________
\
\ By starting the phsa/phsb register at the appropriate place in the cycle, and by resetting
\ it to the same position every 20 ms, we generate a pwm signal on the io pin.
\
\ Since there are 2 counters we can do this with 2 pins at a time.
\
\ And since we only need intervention during the hi time of the signal, we can interleave the
\ processing so that each clock will address 8 io pins.
\
\ This is done by taking the 20ms cycle, and splitting it into 8 2.5ms sections, and driving the
\ corresponding pin hi in that portion of the cycle.
\
\ This means the absolute maximum we can set the pulse width will be 2.5ms
\
\ 0ms                 5ms                 10ms                15ms                20ms
\ ------__________________________________________________________________________------_____ ctra pin n1
\ __________------___________________________________________________________________________ ctra pin n1 + 2
\ ____________________------_________________________________________________________________ ctra pin n1 + 4
\ ______________________________------_______________________________________________________ ctra pin n1 + 6
\ ________________________________________------_____________________________________________ ctra pin n1 + 8
\ __________________________________________________------___________________________________ ctra pin n1 + 10
\ ____________________________________________________________------_________________________ ctra pin n1 + 12
\ ______________________________________________________________________------_______________ ctra pin n1 + 14

\ ------__________________________________________________________________________------_____ ctrb pin n1 + 1
\ __________------___________________________________________________________________________ ctrb pin n1 + 3
\ ____________________------_________________________________________________________________ ctrb pin n1 + 5
\ ______________________________------_______________________________________________________ ctrb pin n1 + 7
\ ________________________________________------_____________________________________________ ctrb pin n1 + 9
\ __________________________________________________------___________________________________ ctrb pin n1 + 11
\ ____________________________________________________________------_________________________ ctrb pin n1 + 13
\ ______________________________________________________________________------_______________ ctrb pin n1 + 15



\
\ This constant defines the number of times per second a pulse is generated
\ for the servo motor.
\
d_50 wconstant sm_cyclefreq

\
\ The number of clock cycles in one pulse sequence of 20ms
\
clkfreq sm_cyclefreq u/ constant sm_cyclecnt

\
\ The number of cycles in 2.5ms, 1/8 of the 20 ms cycle. However an effect
\ of this is that the maximum pulse time is 2.5ms less the time it take to
\ process a cycle. Thus the absolute maximum time it for a pulse width is
\ approximately 2.39ms to 2.4ms on an 80mHz system.
\
sm_cyclecnt 8 u/ constant sm_cyclecnt/8

\
\ These constants define the absolute minium and maximum lengths of time
\ for the pulse. The maximum can never be more than the time slot.
\
\ The minimum was set to 500usec and and maximum to 2500usec
\ but someone managed to turn their servo into a countinuos rotation servo
\ without intending to do so.
\ So the defaults are set to 750usec and 2250usec.
\
clkfreq d_750   d_1_000_000 u*/ constant sm_minhi
clkfreq d_2_250 d_1_000_000 u*/ sm_cyclecnt/8 min constant sm_maxhi



\
\ This variable defines which IO pins are enabled as outputs
\ by the servo driver, the default is 0 - 27 since 30 & 31 are used
\ for the serial port, and 28 & 29 for the eeprom
\
\ variable sm_enable h_0FFF_FFFF sm_enable L!
variable sm_enable h_0000_000F sm_enable L!

\
\ this array defines the pulse hi times, it is initialized 1/2 way between
\ the min and max
\
lockdict variable sm_hitime d_124 allot freedict		\ 32 longs

\
\ this array defines the minimum pulse hi time, it is initialized to the minimum
\
lockdict variable sm_minhitime d_124 allot freedict	\ 32 longs

\
\ this array defines the maximum pulse hi time, it is initialized to the maximum
\
lockdict variable sm_maxhitime d_124 allot freedict	\ 32 longs

\
\ _sm_idx ( n1 addr -- addr ) calculates the array offset for the particular servo
: _sm_idx
	swap 0 max d_31 min 4* +
;
	

\ sm_setpos ( n1 u -- ) n1 is an integer between 0 and 31, u is an unsigned integer between 0 and 10,000
: sm_setpos
	0 max d_10_000 min
\						\ ( n1 u -- )
	over dup sm_minhitime _sm_idx L@
\						\ ( n1 u n1 minhitime -- )
	swap sm_maxhitime _sm_idx L@ 
\						\ ( n1 u minhitime maxhitime -- )
	over -
\						\ ( n1 u minhitime range -- )
	rot d_10_000 u*/ +
\						\ ( n1 pos -- )
	swap sm_hitime _sm_idx L! 
;  



\
\ sm_servo ( n1 -- ) this cog will drive servos n1 to n1 + 15
: sm_servo
	4 state andnC!
	c" SERVO" cds W!
\				\ ( n1 -- )
	0 max h18 min
	dup h_10 bounds
	do
		sm_enable L@ 1 i lshift and
		if
			i dup pinlo pinout
		then
	loop
\				\ ( n1 -- )
	1 frqa COG!
	1 frqb COG!
\				\ counter set to drive pin n1, single ended nco/pwm mode
	dup h_1000_0000 +
\				\ the offset into the array defining the pulse width
	swap 4* sm_hitime +
\				\ ( ctrn1 hitimeoffset -- )
	cnt COG@ sm_cyclecnt +
\				\ ( ctrn1 hitimeoffset nextcycletime -- )
	begin
		h10 0
		do
			0 phsa COG! 0 phsb COG!
\				\ counter a set to drive pin n1,   single ended nco/pwm mode
\				\ counter b set to drive pin n1+1, single ended nco/pwm mode
\				\ ( ctrn1 hitimeoffset nextcycletime -- )
			rot dup i + dup ctra COG!
			1 + ctrb COG!
\				\ ( hitimeoffset nextcycletime ctrn1 -- )
			rot dup i 2 lshift + dup L@ negate phsa COG!
			4 + L@ negate phsb COG!
\				\ ( nextcycletime ctrn1 hitimeoffset -- )
			rot
\				\ ( hitimeoffset ctrn1 nextcycletime -- )
\				\ wait for the next 2.5ms time slot
			sm_cyclecnt/8 waitcnt
		2 +loop
	0 until
;

\ _pos? ( n1 n2 -- n3 n4 ) n3 usec per cycle for pin n1, n4 usec per cycle for pin n2
: _pos?
\					\ increment counter when pulse is hi for pin n1
	h_6800_0000 + ctra COG! 1 frqa COG!
\					\ increment counter when pulse is hi for pin n2
	h_6800_0000 + ctrb COG! 1 frqb COG!
\					\ zero counts, wait one cycle and get counts
	cnt COG@ 0 phsb COG! 0 phsa COG! 
	sm_cyclecnt + 0 waitcnt
	phsb COG@ phsa COG@
\					\ display number of usec pin was hi in one cycle count
	rot drop
\					( n1 n2 timen1 timen2 -- )
;

\ pos? ( n1 n2 -- ) display for pin n1 and pin n2 the number of usec hi per cycle
: pos?
	2dup
	_pos?

	>r
\					( n1 n2 timen1 -- )
 	rot  <# # # #> .cstr h2D emit hF4240 clkfreq u*/ <# # # # # #> .cstr space
	r>
 	swap <# # # #> .cstr h2D emit hF4240 clkfreq u*/ <# # # # # #> .cstr space
;


\ sm_setminmax ( min max n1 -- ) sets calibration parameters for each servo
: sm_setminmax
	swap sm_maxhi min over sm_maxhitime _sm_idx L!
	swap sm_minhi max swap sm_minhitime _sm_idx L!
;

\ _sm_cal2 ( n1 -- )
\ _sm_cal2
: _sm_cal2
	sm_enable L@ over 3 swap lshift and
	if
		dup 1+ pos?
		hD emit
	else
		drop
	then
;

\ _sm_cal1 ( servo key delta -- servo key )
: _sm_cal1
	rot tuck
\					\ ( key servo delta servo -- )
	sm_hitime _sm_idx dup
\					\ ( key servo delta addr addr -- )
	L@ rot + sm_minhi max sm_maxhi min swap L!
\					\ ( key servo -- )
	swap
;

\ _sm_cal ( n1 -- n1 ) n1 - the serv0 0 - 9
: _sm_cal
	begin
		key
		dup h61 = if h-2710 _sm_cal1 else
		dup h73 = if h-3E8 _sm_cal1 else
		dup h64 = if h-64 _sm_cal1 else
		dup h66 = if h-10 _sm_cal1 else
		dup h68 = if h10 _sm_cal1 else
		dup h6A = if h64 _sm_cal1 else
		dup h6B = if h3E8 _sm_cal1 else
		dup h6C = if h2710 _sm_cal1
		thens
		over _sm_cal2
		hD =
	until
;


\ sm_calibrate ( n1 -- ) n1 - servo
: sm_calibrate
	begin
		." a - <<<<    s - <<<    d - <<    f - <    h - >    j - >>    k - >>>    l - >>>>" cr

		." Move servo to leftmost position then hit enter" cr
		_sm_cal cr
		dup sm_hitime _sm_idx L@ swap
\										\ ( left n1 -- )

		." Move servo to rightmost position then hit enter" cr
		_sm_cal cr
		dup sm_hitime _sm_idx L@ swap
\										\ ( left right n1 -- )
		dup >r sm_setminmax
		r>
\										\ ( center left-center right n1 -- )

		." 0 - Leftmost   1 - Center    2 - Rightmost     r - Recalibrate    ESC - Done" cr
		0 begin
			drop
			key
			dup h30 = if over 0 sm_setpos else 
			dup h31 = if over h1388 sm_setpos else 
			dup h32 = if over h2710 sm_setpos
			thens
			over _sm_cal2
	
			dup h1B = over 72 = or
		until
		h1B =
	until
	cr dup sm_minhitime _sm_idx L@ . dup sm_maxhitime _sm_idx L@ . . cr  
;
	
\ 


\ sm_start_servos ( -- ) runs 32 servo drivers on cogs 0 - 1, io pins 0 - 31
\ 			modify after calibrating servos
: sm_start_servos
\ initialize arrays, default calibration
\
	32 0
	do
		sm_minhi i sm_minhitime _sm_idx L!
		sm_maxhi i sm_maxhitime _sm_idx L!
	loop

\ calibration for servos
\	105000 200000 0 sm_setminmax

	32 0
	do
		i sm_minhitime _sm_idx L@
		i sm_maxhitime _sm_idx L@
		over - 2/ +
 
		i sm_hitime _sm_idx L!
	loop

	1 cogreset h_10 delms c" 0 sm_servo" 1 cogx
\	1 cogreset h_10 delms c" d_16  sm_servo" 2 cogx
	10 delms
;



}}}


= End 20130202 =