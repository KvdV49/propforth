#summary Notes for Hobby Servo Support.
#labels servo

= Servo =

Hobby Servo is controlled by sending it a pulse every 20 milliseconds. The width of the pulse tell the servo the desired position, and it tries to move to that position.  The pulse can be 1.5 ms +/- 1 ms .  That is a pulse of 2.5 will ask for rotation 90 degrees. A pulse of 0.5 ms will ask for rotation of -90 degrees.  a pulse of 1.5 ms will ask the servo to move to its middle position. 

== Not always the MAX ==

Digital servos compensate, analog servos chatter or go through stops. 

Most cheaper servos do not move the full 180 degrees.  Some expensive servos move greater than 180.

Requesting the a servo to move beyond its physical limit can cause the servo to "chatter"; it hits the end stop but continues to try to move farther. We had a case where a cheap servo was used, and it broke through the end stops.  So we went conservative, and change the DEFAULT code to stop short of the usual limit.

By DEFAULT the Absolute allowable limits are 0.75 to 2.25   (1.5 is alway middle). The limits are adjustable in code.  It is suggested that users get familiar with the code and controlling the servo before changing the defaults.  Then, it is suggested to find out the max for your specific servos, and set those as the limits in software.

== One I/O pin per servo ==

One I/O pin is required to directly control a servo.  Up to 32 servos can be directly controlled using a propeller chip. This would consume at minimum two cogs. If 32 servos were used, all the I/O pins would be outputs, so it would not be easy to talk to the prop chip.

== One counter can control 8 servos ==

Instead of 1 clock 1 servo; 1 clock 8 servos, 20 ms / 2.5 = 8

To control a servo, a pulse is sent out every 20 milliseconds. While a cog is waiting until it needs to send another pulse, it can send pulses to additional servos.  The maximum pulse that will be sent to a servo is 2.5 milliseconds.  20 ms per servo / 2.5 ms = 8 servos total.  

Max time is 2.35-2.39 ms due to processing overhead. 

== One cog has two counters ==

Each cog has two counters, (A and B).  Each counter can control 8 servos.  On cog can control 16 servos.  Two cogs can control 32 servos if we wish to use up all the pins.  

== mask bit =

The software is set up to control which servos are enabled.

The word `sm_enable ` contains a bit mask to turn servos on and off.

=====>
`sm_enable `
========>
put a 1 in the bits to turn on the servo

For example:
{{{
b_1_0000_0000_0000 sm_enable 
}}} 
or
{{{
d_4096 sm_enable 
}}} 

will enable the servo on pin 12.  (There is a 1 in position 12 of the binary value, and that binary value is 4096 in decimal). 



if you want to keep RSR232 and EEPROM default lines use
{{{
h_FFF_FFFF  sm_enable 
d_268_435_455 sm_enable 
b_1111_1111_1111__1111_1111_1111_1111 sm_enable 
}}}
 
to enable all the pins 28 servos, leaving 28, 29 for EEPROM, and 30 31 for serial. 

= Pin is Servo number =

The software is designs so that Pins are related to servo number. 
Recommend NOT changing this.
 
== Usage of pin assignments ==

===> specify start pin, the servos and pin assignments proceed in sequence.  

Pin 8-24 depends on if servo is enabled, can be changed but code get complex, so don't bother.

NOTE:  check the sm_emable example above?  If this means only pins 8-23(?) are assigned for servo use? 


= same as previous versions =

In case anybody has existing code based on previous versions:  The current support is done to same as previous versions (somebody check?  I don't have the previous versions set up)

interfaces are same 

set-pause and calibrate are same 

= Smallest noticeable change = 

What is the smallest noticeable change in servo position we can achieve? 

SMALLEST NOTICE ABLE CHANGE

The default limits for the control pulses are 0.75 to 2.25 ms.  2.25 - 0.75 = range of 1.5 ms 

  * 1.5 ms = 1500uS = 1,500,000 ns

Theoretically, divide 15,000,000 ns by 12.5 ns 

  * 120,000 is DYNAMIC RANGE

To TEST - 
  * Whether or not a change of 1 will move the servo arm?
  * move to a position, mark it 
  * move it to 45 degrees
  * move it back (repeatability)

  * move to a position, mark it 
  * move it to 45 degrees (or any repeatable position that is convenient)
  * move it to position -1 to notice a change
  * keep changing position by 1 unit until a change is noticed.

Repeat this until it does not return to the the exact starting point. 
  
  * 120,000 position is    1D4C0 hex
  * 65535            is     FFFF

variable is 32 bits anyway.

== To test ==

Move to 120,000 positions (1D4C0 hex).  Some changes are too small to cause the servo to move.  Determine for a give servo the smallest positional change that can be performed. 

The number of positions is greater than 16 bits, so it wont fit in a word.  It will definitely fit in a long, but the long has more bits than we need.  be aware so junk in the the unused bits doesn't trip something up. 

The number of usable positions may be smaller than 120,000.  If the number turns out to be 65535 or less, the position value could be scaled and a word (16 bit) variable could be used. 

= note = 

change comment in line 166 and 1000 in line 168 and 176 to 120,000

= Max is probably 28 servos = 

More than 28 servos prevents us from talking to and controlling the prop, and getting to the EEPROM.  

MAX setup 28 servos

But I don't have 28 servos. How to test?   

  * two servo, leave one at the same pin
  * move one on each different pin.
  * Plug one servo is in each pin, and move both

= Deadband = 

This is not Jerry Garcia for servos.  This is the minimum value change for evoking movement from the servo. Typical specs say 4 microseconds (4uS) or 4000ns. Which is also 0.004 milliseconds. 

  * specs - deadbandwidth 4uS - this many 12.5 ns = 320 counts
  * must have at least this much variational before it moves.

  * 320 `*` 12.5 is minimum it can move.` 


= End 20130202 =