#summary Recursion in Proforth
#labels v5.0

<wiki:toc max_depth="9" />


= Recursion =

Recursion is when a function calls itself. 

In forth, we can have a reference to the same function with a function definition.  The word "recurse" make a function call itself again.

Caskaz got this from  Sal, and posted it in the rpopforth 5.0 thread

http://forums.parallax.com/showthread.php?138399-Propforth-5.0-is-available-for-download&p=1145116&viewfull=1#post1145116

= Code =

This code implements recursion

{{{
lockdict
: recurse lastnfa nfa>pfa w, ; immediate
freedict

}}}

Here is Caskaz's example of how its used:

{{{
\ ( n1 -- n2 )  n2 = n1 X (n1-1) X (n1-2) X . . . X 1
: factorial
       dup 0 <=
               if
                   drop 1
               else
                   dup 1- recurse u*
               then
;

\ ( n1 -- n2 )  n2 = n1 X (n1-1) X (n1-2) X . . . X 1
: factorial_test factorial . cr ;

: ft factorial_test ; \ so its shorter to type

: ftl  
     0 begin
            cr 
            dup . 
            dup ft
            1+
       0 until 
; \ this example work correctly for values up to 12
  \ the value displayed for 13 is incorrect, it has already overflowed
  \ the routine finally crashes after 25


}}}

In this example, `factorial` takes a number off the stack.
If the number is less than or equal to 1, the function returns 1
Otherrwise, it decrements the number, call itself, and does unsigned multiply on the result.

The affect is the factorial function. 

= What it does =

Here is a test to show what the recursion really does.

{{{
lockdict
: recurse lastnfa nfa>pfa w, ; immediate
freedict

: rtest  
  ." IN->" st?
   dup 0 > 
   if
     1- recurse  ." here!" st?
   else
        ." finish!"
   then
   ." Out->" st?
; 
  


}}}

In the case of propforth, the routine repeats itelf.

{{{
Prop0 Cog6 ok
  3 rtest
IN->ST: 0_000_000_003
IN->ST: 0_000_000_002
IN->ST: 0_000_000_001
IN->ST: 0_000_000_000
finish!Out->ST: 0_000_000_000
here!ST: 0_000_000_000
Out->ST: 0_000_000_000
here!ST: 0_000_000_000
Out->ST: 0_000_000_000
here!ST: 0_000_000_000
Out->ST: 0_000_000_000
Prop0 Cog6 ok


}}}

The most we can do with the current stack configuration is 16 calls.

{{{
Prop0 Cog6 ok
100 rtest
IN->ST: 0_000_000_100
IN->ST: 0_000_000_099
IN->ST: 0_000_000_098
IN->ST: 0_000_000_097
IN->ST: 0_000_000_096
IN->ST: 0_000_000_095
IN->ST: 0_000_000_094
IN->ST: 0_000_000_093
IN->ST: 0_000_000_092
IN->ST: 0_000_000_091
IN->ST: 0_000_000_090
IN->ST: 0_000_000_089
IN->ST: 0_000_000_088
IN->ST: 0_000_000_087
IN->ST: 0_000_000_086
IN->ST: 0_000_000_085
IN->ST: 0_000_000_084
IN->ST:
CON:Prop0 Cog6 RESET - last status: 2 RETURN STACK OVERFLOW

}}}


= Recursion for FFT (under construction) =

From heater:

" there is a recursive definition of the FFT. It's not quite as 
fast as the normal style we see and it needs 50% more buffer space but it occurs to me that Forth should be well suited to a recursive approach what with being stack based."

== Requirements ==

 * define a word, call it FFT, 
 * FFT  takes four parameters off the stack, call them: x, y, n, s,
 * FFT needs to be able call itself twice,
   * Once with parameters x, y, n/2, s*2  
   * And again with: x+s/2, y+n, n/2, s*2
 
 * Then FFT will do a bunch of processing using the original value of n it was passed and the global input/output buffers.
 
 * It should do nothing when n is zero.
 
 == To Start ==

Here is what heater suggests as a start:

{{{
\ -------------------------------------------------------------
: FFT ( x y n s -- )
   \ Check if n is zero
 
    something something something FFT
    something something something FFT
 
    \ more processing using n
 
;
 
\ FFT is originally called with
inBuff outBuff buffSize 1 FFT
\ -------------------------------------------------------------
}}}

heater's first try:

"My current attempt is below. It uses pick which some people seem to frown on.  What do you think?"

Braino response:  Pick is very expensive and slow. Propforth does not include PICK in the kernel for this reason.  We can use it if we wish, but we must recognize the cost. Since it is probably not what you want, you have to want it enough to implement it yourself.  My advise is you probably don't, but there are case where it is the only way. 

{{{
 
\ -------------------------------------------------------------
: FFT ( x y n s -- ) recursive
    3 pick . 2 pick . 1 pick . 0 pick . cr
 
    1 pick 0= if
        ." Bottom" cr
        \ Something here
    else
        3 pick 3 pick 3 pick 2 / 3 pick 2 * FFT
 
        3 pick over 2 / + 3 pick 3 pick + 3 pick 2 / 3 pick 2 * FFT
 
        \ Something here.
 
    endif
drop drop drop drop
;
 
100 200 1024 1 FFT
\ -------------------------------------------------------------
}}} 
 
"I'm hoping the recursive FFT can work easily with no locals or globals (except the buffers). The magic part is that there is only a single loop, all the other house keeping happens by virtue of that recursive calling. It's a very neat and short way to do it."

== Braino's attempt ==

Using the stated requirements: [Recursion#Requirements]

Straight off the requirements, no refactoring.  There are better ways to do this, I'm just playing
 
NOTICE: each time the recurse word is executed, the return stack grows.  Each time the function call itself, the parameter stack grows by 4 elements. 

{{{

lockdict
: recurse lastnfa nfa>pfa w, ; immediate
freedict

: 2swap \ ( a b c d - c d a b )
        >r    \ a b c d - a b c (d)r
        swap  \ a b c (d)r - a c b (d)r
        >r    \ a c b (d)r - a c (b d)r 
        swap  \ a c (b d)r -  c a (b d)r
        r> r> \ c a (b d)r -  c a b d
        swap >r \  c a b d - c a d (b)r
        swap r> \ c a d (b)r - c d a b 
;

: 4dup \ ( a b c d - a b c d a b c d )
       >r >r \ a b c d - a b  (c d)r
       2dup  \ a b - a b a b  (c d)r
       r> r> \ a b a b - a b a b c d 
       2swap \ a b a b c d - a b c d a b 
       >r >r \ a b c d a b - a b c d  (a b)r
       2dup  \ a b c d - a b c d c d
       r> r> \ a b c d c d a b
       2swap  \ a b c d - a b c d a b c d 
;
{ \ this was the intermediate coding, this is not used
: FFT_call_twice \ ( x y n s - ) when n is not zero
  \ Once with parameters x, y, n/2, s*2                
                 4dup 
                 swap  2/ \ (n/2)
                 swap  2* \ (s*2)
                 FFT_A

  \ And again with: x+s/2, y+n, n/2, s*2 

                 4dup 
                 dup 2/  \ (s/2)
                 swap >r \ hide s
                 swap >r \ hide n
                 swap >r \ hide y
                 +       \ x+s/2  (this stacks on stack)      
                 r> r>   \ retrieve y , n
                 swap    \ n, y
                 2dup    \ n, y , n , y
                 +       \ n, y , n+y
                 swap    \ n, n+y, y
                 drop    \ n, n+y
                 swap  2/  \ n+y, n/2 (this stays on stck)
                 r>       \ retrieve s
                 2*       \ s*2     
                 FFT_B    \ x+s/2, y+n, n/2, s*2
; 
} \ the above routine is commented out
 

\ -------------------------------------------------------------
: FFT \ ( x y n s -- ) consumes 4 values, deposits no values
  \ Check if n is zero
    st?
    swap dup 0 >= if 
           swap \ put the stack back in order
    \ Once with parameters x, y, n/2, s*2                
           4dup 
           swap  2/ \ (n/2)
           swap  2* \ (s*2)
           recurse           
    \ of course, the above assumes that FFT leaves no values on the stack

    \ And again with: x+s/2, y+n, n/2, s*2 
            4dup 
            dup 2/  \ (s/2)
            swap >r \ hide s
            swap >r \ hide n
            swap >r \ hide y
            +       \ x+s/2  (this stays on stack)      
            r> r>   \ retrieve y , n
            swap    \ n, y
            2dup    \ n, y , n , y
            +       \ n, y , n+y
            swap    \ n, n+y, y
            drop    \ n, n+y
            swap 2/ \ n+y, n/2 (this stays on stack)
            r>       \ retrieve s
            2*       \ s*2     
            recurse  \ x+s/2, y+n, n/2, s*2
     \ of course, the above assumes that FFT leaves no values on the stack

     else
               \ do nothing if n is  0
          swap \ but do put the stack back
     then

    \ more processing using n
    \ just to make it work, I will decrement n
    swap 1- swap
 
;

}}}

For the time being, this only fills the stack. And of course, since it calls itself with a new set of parameters, it uses up the stack twice as fast. 

This routine would have to be re-written so it only uses the top four elements of the stack.  It has to keep doing something to those, rather than calling with new parameters, as the prop does not have the memory to waste. 

The other alternative would be to move the stack to SD memory.  But that is a task for another day. 


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages