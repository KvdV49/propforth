#summary Recursion in Proforth

= Recursion =

Recursion is when a function calls itself. 

In forth, we can have a reference to the same function with a function definition.  The word "recurse" make a function call itself again.

Caskaz got this from  Sal, and posted it in the rpopforth 5.0 thread

http://forums.parallax.com/showthread.php?138399-Propforth-5.0-is-available-for-download&p=1145116&viewfull=1#post1145116

= Code =

This code implements recursion

{{{
lockdict
: recurse lastnfa nfa>pfa w, ; immediate
freedict

}}}

Here is Caskaz's example of how its used:

{{{
\ ( n1 -- n2 )  n2 = n1 X (n1-1) X (n1-2) X . . . X 1
: factorial
       dup 0 <=
               if
                   drop 1
               else
                   dup 1- recurse u*
               then
;

\ ( n1 -- n2 )  n2 = n1 X (n1-1) X (n1-2) X . . . X 1
: factorial_test factorial . cr ;

: ft factorial_test ; \ so its shorter to type

: ftl  
     0 begin
            cr 
            dup . 
            dup ft
            1+
       0 until 
; \ this example work correctly for values up to 12
  \ the value displayed for 13 is incorrect, it has already overflowed
  \ the routine finally crashes after 25


}}}

In this example, `factorial` takes a number off the stack.
If the number is less than or equal to 1, the function returns 1
Otherrwise, it decrements the number, call itself, and does unsigned multiply on the result.

The affect is the factorial function. 

= Recursion for FFT (under construction) =

From heater:

" there is a recursive definition of the FFT. It's not quite as 
fast as the normal style we see and it needs 50% more buffer space but it occurs to me that Forth should be well suited to a recursive approach what with being stack based."

== Requirements ==

 * define a word, call it FFT, 
 * FFT  takes four parameters off the stack, call them: x, y, n, s,
 * FFT needs to be able call itself twice,
   * Once with parameters x, y, n/2, s*2  
   * And again with: x+s/2, y+n, n/2, s*2
 
 * Then FFT will do a bunch of processing using the original value of n it was passed and the global input/output buffers.
 
 * It should do nothing when n is zero.
 
 == To Start ==

Here is what heater suggests as a start:

{{{
\ -------------------------------------------------------------
: FFT ( x y n s -- )
   \ Check if n is zero
 
    something something something FFT
    something something something FFT
 
    \ more processing using n
 
;
 
\ FFT is originally called with
inBuff outBuff buffSize 1 FFT
\ -------------------------------------------------------------
}}}

heater's first try:

"My current attempt is below. It uses pick which some people seem to frown on.  What do you think?"

Braino response:  Pick is very expensive and slow. Propforth does not include PICK in the kernel for this reason.  We can use it if we wish, but we must recognize the cost. Since it is probably not what you want, you have to want it enough to implement it yourself.  My advise is you probably don't, but there are case where it is the only way. 

{{{
 
\ -------------------------------------------------------------
: FFT ( x y n s -- ) recursive
    3 pick . 2 pick . 1 pick . 0 pick . cr
 
    1 pick 0= if
        ." Bottom" cr
        \ Something here
    else
        3 pick 3 pick 3 pick 2 / 3 pick 2 * FFT
 
        3 pick over 2 / + 3 pick 3 pick + 3 pick 2 / 3 pick 2 * FFT
 
        \ Something here.
 
    endif
drop drop drop drop
;
 
100 200 1024 1 FFT
\ -------------------------------------------------------------
}}} 
 
"I'm hoping the recursive FFT can work easily with no locals or globals (except the buffers). The magic part is that there is only a single loop, all the other house keeping happens by virtue of that recursive calling. It's a very neat and short way to do it."

== Braino's attempt ==

Using the stated erquirements: Recursion#Requirements
 



= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages