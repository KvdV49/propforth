#summary A/D in assembler for Propforth 5.0
#labels AD,v5.0,caskaz

= Introduction =

This page is an example of converting high level FORTH code into assembler.

The code is caskaz's contribution from 20120321

http://forums.parallax.com/showthread.php?138399-Propforth-5.0-is-available-for-download&p=1084006&viewfull=1#post1084006

= Hardware =

== prop board ==

This example can use any propforth board.

Quickstart and protoobard are used here

== Analog input circuit ==

 * The input singla is on pin zero as defined by 0 wconstant adcpin

 * The feedback pin is on pin one as defined by 1 wconstant fbpin

in the code below.

An example circuit goes here =>  `(*)`


= A/D code =

This is the entire code snitpet posted for the AD extension.  It consists of two or three parts:
 # the optimized assembler code, in base 64 encoding
 # the PASM assembler instructions for the prop, in comments
 # the orignal forth code used to develop the function (not present in this example)

The optimized assembler code is the sequence of prop assembler byte codes that make up the function.  The bytes are coded in base 64 to make loading faster, as fewer symbols are needed to represent the values.  Recall that in propforth, values that begin with lowercase z are interporeted as base 64 (if that are not found in the dictionary as a forth defineition). 

In this case the A/D function was implemented directly in PASM. Remember that forth works from the stack, and the assembler syntax may appear "backwards" or otherwise different compared to other assembler implementations. 

The original forth code can be included in comments as a reference.  Once a function is implemented in forth and tested to assure correct function, we have our starting point. The forth implementation of a time critical function can turn out to be "too slow" for the target application.  The function can then be optimized in assembler.  This involved removing the "forth overhead" from the function's internal parts, and making over changes to improve speed, efficiency, etc.   It is good parctice to leave the source in comments as a reference in case future changes are required.  (braino plans to add example high level forth to show the working of the A/D at a later time)

{{{
\ a cog special register
[ifndef ctra
h1F8	wconstant ctra
]
[ifndef frqa
h1FA	wconstant frqa 
]
[ifndef phsa
h1FC	wconstant phsa 
]

0 wconstant adcpin
1 wconstant fbpin

variable result

\ a_adc    A/D-conversion    ( result_addr  cycles  -- )
lockdict create a_adc forthentry
$C_a_lxasm w, h121  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiZuB l, z1SyLI[ l, z2Wi[3B l, z1SyLI[ l, z2WiPak l, z20iP[V l, z3riP[V l, z2WiPiv l,
z24iPeE l, z20iPmD l, z8FPfW l, z1SV04P l, 0 l, 0 l,
freedict

: sigma_delta
1 frqa COG! fbpin dup pinout 9 lshift h24000000 or adcpin or ctra COG!         
\ A/D start
result 13880 a_adc
;

: adc
 c" sigma_delta" 5 cogx
 begin
     result L@ .  cr     
     10 delms             \ 10msec
 0 until
;

decimal
{
fl
hex
[ifndef phsa
h1FC	wconstant phsa 
]

\ sigma-delta A/D conversion
\ ( n1 n2 -- )  n1:result address  n2:cycles 
build_BootOpt :rasm
               \ read interval               
               mov  __interval , $C_stTOS
               spop
               \ read A/D result address
               mov  __result , $C_stTOS
               spop
               mov  $C_treg1 , cnt  
               add  $C_treg1 , __interval
__1
               waitcnt   $C_treg1 , __interval
               mov  $C_treg2 , phsa
               sub  $C_treg2 , $C_treg3
               add  $C_treg3 , $C_treg2 
               wrlong    $C_treg2 , __result
               jmp # __1                      
__interval
 0
__result
 0
;asm a_adc		
}
}}}


= Lots of Comments =


{{{
\ a cog special register
[ifndef ctra
h1F8	wconstant ctra
]
}}}

`[ifndef` is "if not defined"  then do the next lines until the close bracket `]`.  In this case, define the constant.

Prop Manual Page 95

{{{
[ifndef frqa
h1FA	wconstant frqa 
]
}}}
Prop Manual Page 111

{{{
[ifndef phsa
h1FC	wconstant phsa 
]
}}}
Prop Manual Page 180

{{{
0 wconstant adcpin
1 wconstant fbpin

variable result
}}}
Prop Pin 0 is used for input the Analog signal to be converted to Digital 

Prop pin 1 is the Feed Back `(???)`

The variable "result" is the hub memory location where the A to D convert result is transfered to other functions.

{{{
\ a_adc    A/D-conversion    ( result_addr  cycles  -- )
lockdict create a_adc forthentry
$C_a_lxasm w, h121  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiZuB l, z1SyLI[ l, z2Wi[3B l, z1SyLI[ l, z2WiPak l, z20iP[V l, z3riP[V l, z2WiPiv l,
z24iPeE l, z20iPmD l, z8FPfW l, z1SV04P l, 0 l, 0 l,
freedict
}}}
lockdict locks the dictionary in hub memory so we can create an entry for the assembler ruoutine (without another process stepping on our definition with its being written). 

The forth word CREATE starts a forth definition.  REMEMBER, 
the way propforth works, calling create does NOT make a dictionary entry by itself, as in other forths.   CREATE sets up stuff on the stack so the following words can make the definition.

a_adc is the label for the dictionary entry for the function.  

forthentry sets the flag for F so words will dispaly this entry as F.  It also does other stuff, I'm not entirely sure.

the last freedict ends the process, it might be the part that actually completes the new dictionary entry, I have to check this. 

{{{

: sigma_delta
1 frqa COG! fbpin dup pinout 9 lshift h24000000 or adcpin or ctra COG!         
\ A/D start
result 13880 a_adc
;
}}}

Parallax App note 8 is on sigma delta

http://www.parallaxsemiconductor.com/an008

{{{

: adc
 c" sigma_delta" 5 cogx
 begin
     result L@ .  cr     
     10 delms             \ 10msec
 0 until
;
}}}

adc is a function that runs on cog 5 and monitors that value in the previoulsy define variable "result".  The contents of result is diplayed every 10 milliseconds.

{{{

decimal
}}}

switch back to decimal in case something changed the base


{{{

{

}}}
Begining of the section that was commented out, we no longer need this code now that we have series of values in base 64


{{{
fl
hex
}}}

FL is the fast load word, this routine uses one cog to send the input text stream into unused hub memory for buffering, while another cog starts interpreting the text in the "buffer".  FL is fast, and doesn't use up any hub memory (since it acts on unused memory), but is limited to the size of unused memory. 

hex changes the base to sixteen. 

{{{
[ifndef phsa
h1FC	wconstant phsa 
]
}}}
Prop Manual Page 180 (why is this in here twice?)
The ifdef makes sure it is only defined once

The label is defined once (the first time) in the forth assembler code.  When the resultant code is converted to base 64 encoding, the instructions to the interpreter are no longer present at this location.   The label is define again (the second time) in the code that sets up the base 64 encoded routine.  The result (should be) the the label is only defined once, but is available when we have to mess with the original version. 

{{{

\ sigma-delta A/D conversion
\ ( n1 n2 -- )  n1:result address  n2:cycles 
build_BootOpt :rasm
}}}

`n1` is the address where the returned value gets placed.  In this example, is is the variable "result"

`n2` is the number of cycles.  (cycles of what?  Is this the number of times the input pin is sampled?  Or is this the duration of the sampling?)

`build_BootOpt`  (figure out what this is doing)

`:rasm`  (figure out what this is doing)

{{{
               \ read interval               
               mov  __interval , $C_stTOS
               spop
}}}

This is where the actual assembler code begins.

Move the value at the Top Of Stack to location __interval

pop the value off the top of the stack

{{{
               \ read A/D result address
               mov  __result , $C_stTOS
               spop
}}}

Move the value at the Top Of Stack to location __result

pop the value off the top of the stack


{{{
               mov  $C_treg1 , cnt  
               add  $C_treg1 , __interval
}}}

Move the value from system counter register cnt  (prop maual page 73)

to (explain $C_treg1) 

add __interval to (the previously obtained value of) system counter register


{{{
__1
               waitcnt   $C_treg1 , __interval
               mov  $C_treg2 , phsa
               sub  $C_treg2 , $C_treg3
               add  $C_treg3 , $C_treg2 
               wrlong    $C_treg2 , __result
               jmp # __1                      
}}}

__1 is a label, so we have a place to jump to in our loop

When the loop time (value in $C_treg1) expires, jump to label __interval

Get the value of phsa (Propeller manual page 180) and put it in $C_treg2

subtract the value (in $C_treg2 from the value in $C_treg3)  better check this

add the value (in $C_treg3 to the value in $C_treg2)  better check this

write the long in $C_treg3 to location of label __result

jump back to label __1 for our loop

{{{
__interval
 0
__result
 0
}}}

The locations (variables) __interval and __result are initalized to 0 when the code was defined. 

{{{
;asm a_adc		
}}}

This ends the assembler definition for function a_adc

{{{
}
}}}

This is the ending comment for the forth assembler code. 

= converting the result to base 64 = 

( need to describe the process for this )

----

= References =

Propeller Manual http://www.parallax.com/Portals/0/Downloads/docs/prod/prop/WebPM-v1.1.pdf

Propeller Quick Reference v1.6 http://nagasm.suac.net/ASL/Propeller/printedPDF/QuickReference-v15.pdf (This link is to version 1.5; version 1.6 isn't available on line)