#summary A/D in assembler for Propforth 5.0
#labels AD,v5.0,caskaz

= Introduction =

This page is an example of converting high level FORTH code into assembler.

The code is caskaz's contribution from 20120321

http://forums.parallax.com/showthread.php?138399-Propforth-5.0-is-available-for-download&p=1084006&viewfull=1#post1084006

= Hardware =

== prop board ==

This example can use any propforth board.

Quickstart and protoobard are used here

== Analog input circuit ==




= A/D code =

This is the entire code snitpet posted for the AD extension.  It consistes of two parts:
 # the optimized assembler code, in base 64 encoding
 # the PASM assembler instructions for the prop, in comments
 # the orignal forth code used to develop the function (not present in this example)

The optimized assembler code is the sequence of prop assembler byte codes that make up the function.  The bytes are coded in base 64 to make loading faster, as fewer symbols are needed to represent the values.  Recall that in propforth, values that begin with lowercase z are interporeted as base 64 (if that are not found in the dictionary as a forth defineition). 

In this case the A/D function was implemented directly in PASM. Remember that forth works from the stack, and the assembler syntax may appear "backwards" or otherwise different compared to other assembler implementations. 

The original forth code can be included in comments as a reference.  Once a function is implemented in forth and tested to assure correct function, we have our starting point. The forth implementation of a time critical function can turn out to be "too slow" for the target application.  The function can then be optimized in assembler.  This involved removing the "forth overhead" from the function's internal parts, and making over changes to improve speed, efficiency, etc.   It is good parctice to leave the source in comments as a reference in case future changes are required.  (braino plans to add example high level forth at a later time)

{{{
\ a cog special register
[ifndef ctra
h1F8	wconstant ctra
]
[ifndef frqa
h1FA	wconstant frqa 
]
[ifndef phsa
h1FC	wconstant phsa 
]

0 wconstant adcpin
1 wconstant fbpin

variable result

\ a_adc    A/D-conversion    ( result_addr  cycles  -- )
lockdict create a_adc forthentry
$C_a_lxasm w, h121  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiZuB l, z1SyLI[ l, z2Wi[3B l, z1SyLI[ l, z2WiPak l, z20iP[V l, z3riP[V l, z2WiPiv l,
z24iPeE l, z20iPmD l, z8FPfW l, z1SV04P l, 0 l, 0 l,
freedict

: sigma_delta
1 frqa COG! fbpin dup pinout 9 lshift h24000000 or adcpin or ctra COG!         
\ A/D start
result 13880 a_adc
;

: adc
 c" sigma_delta" 5 cogx
 begin
     result L@ .  cr     
     10 delms             \ 10msec
 0 until
;

decimal
{
fl
hex
[ifndef phsa
h1FC	wconstant phsa 
]

\ sigma-delta A/D conversion
\ ( n1 n2 -- )  n1:result address  n2:cycles 
build_BootOpt :rasm
               \ read interval               
               mov  __interval , $C_stTOS
               spop
               \ read A/D result address
               mov  __result , $C_stTOS
               spop
               mov  $C_treg1 , cnt  
               add  $C_treg1 , __interval
__1
               waitcnt   $C_treg1 , __interval
               mov  $C_treg2 , phsa
               sub  $C_treg2 , $C_treg3
               add  $C_treg3 , $C_treg2 
               wrlong    $C_treg2 , __result
               jmp # __1                      
__interval
 0
__result
 0
;asm a_adc		
}
}}}


= Lots of Comments =


{{{
\ a cog special register
[ifndef ctra
h1F8	wconstant ctra
]
}}}
Prop Manual Page 95

{{{
[ifndef frqa
h1FA	wconstant frqa 
]
}}}
Prop Manual Page 111

{{{
[ifndef phsa
h1FC	wconstant phsa 
]
}}}
Prop Manual Page 180

{{{
0 wconstant adcpin
1 wconstant fbpin

variable result
}}}
Prop Pin 0 is used for input the Analog signal to be converted to Digital 
Prop pin 1 is the Feed Back (???)

The variable "result" is the hub memory location where the A to D convert result is transfered to other functions.

{{{
\ a_adc    A/D-conversion    ( result_addr  cycles  -- )
lockdict create a_adc forthentry
$C_a_lxasm w, h121  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiZuB l, z1SyLI[ l, z2Wi[3B l, z1SyLI[ l, z2WiPak l, z20iP[V l, z3riP[V l, z2WiPiv l,
z24iPeE l, z20iPmD l, z8FPfW l, z1SV04P l, 0 l, 0 l,
freedict
}}}
lockdict locks the dictionary in hub memory so we can create an entry for the assembler ruoutine (without another process stepping on our definition with its being written). 

The forth word CREATE starts a forth definition.  REMEMBER, 
the way propforth works, calling create does NOT make a dictionary entry by itself, as in other forths.   CREATE sets up stuff on the stack so the following words can make the definition.

a_adc is the label for the dictionary entry for the function.  

forthentry sets the flag for F so words will dispaly this entry as F.  It also does other stuff, I'm not entirely sure.




{{{

: sigma_delta
1 frqa COG! fbpin dup pinout 9 lshift h24000000 or adcpin or ctra COG!         
\ A/D start
result 13880 a_adc
;
}}}

{{{

: adc
 c" sigma_delta" 5 cogx
 begin
     result L@ .  cr     
     10 delms             \ 10msec
 0 until
;
}}}

{{{

decimal
}}}

{{{

{

}}}

{{{
fl
hex
}}}

{{{
[ifndef phsa
h1FC	wconstant phsa 
]
}}}

{{{

\ sigma-delta A/D conversion
\ ( n1 n2 -- )  n1:result address  n2:cycles 
build_BootOpt :rasm
}}}

{{{
               \ read interval               
               mov  __interval , $C_stTOS
               spop
}}}

{{{
               \ read A/D result address
               mov  __result , $C_stTOS
               spop
}}}

{{{
               mov  $C_treg1 , cnt  
               add  $C_treg1 , __interval
}}}

{{{
__1
               waitcnt   $C_treg1 , __interval
               mov  $C_treg2 , phsa
               sub  $C_treg2 , $C_treg3
               add  $C_treg3 , $C_treg2 
               wrlong    $C_treg2 , __result
               jmp # __1                      
}}}

{{{
__interval
 0
__result
 0
}}}

{{{
;asm a_adc		
}}}

{{{
}
}}}


= converting the result to base 64 = 


----

= References =

Propeller Manual http://www.parallax.com/Portals/0/Downloads/docs/prod/prop/WebPM-v1.1.pdf

Propeller Quick Reference v1.6 http://nagasm.suac.net/ASL/Propeller/printedPDF/QuickReference-v15.pdf (This link is to version 1.5; version 1.6 isn't available on line)



Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages