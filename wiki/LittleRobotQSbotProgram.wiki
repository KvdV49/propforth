#summary Refined Program for Quickstart LittleRobot
#labels v5.5,LittleRobot

<wiki:toc max_depth="9" />

-----

= I. Overview =

There is a version of bot.f in the PropForth-V5.5-20130317.zip that we have CHANGED into QSbot.f, shown on this page.  

QSbot.f is the modified program to use for the Quickstart version of the LittleRobot.  We will use this in our workshop session today. 

Using these instructions, we will:

  * Connect each components for the bot
  * Test each components for the bot
  * Build the bot
  * Program the bot
  * Test the assembled bot

-----

= II. Physical connections =


The following chat is the reference for how the connection are made. 

Don't worry, we don't have to do them all just yet. 

We will connect each part one at a time, and test it to show how it works

When you make the connections, use the pin number from the QSbot column. 

Ignore the crossed out Bot 1 and Bot 2 pinouts.  Those are included for comparison. You won't care about these until later. 

|| || QSbot || ~~Bot1~~ || ~~Bot2~~ ||
|| SR04  || 24 trig , 25 echo || ~~16 trig, 17 echo~~ || ~~P24 trig, P25 echo~~  || Vin *SR04 must have no more than 5.0v Vin* ||
|| -- || P24 trig  ||  ~~P16 trig~~ || ~~P24 trig~~ ||
|| -- ||  P25 echo  || ~~P17 echo~~ || ~~P25 echo~~ ||BE SURE ECHO HAS ~~330~~ 10k ohm resistor! || 
|| Ready LED ||  No Ready LED on QSbot || ~~P3~~ || ~~P23~~ ||
|| MotorA ||  8-11 || ~~d_24 d_25 d_26 d_27~~ || ~~d_15 d_14 d_13 d_12~~ || Vin Motors Can be 5-12v ||
|| -- ||  P08 = IN1 || ~~P11 = IN1~~ || ~~P15 = IN1~~ || 
|| -- ||  P09 = IN2 || ~~P12 = IN2~~ || ~~P14 = IN2~~ || 
|| -- ||  P10 = IN3 || ~~P13 = IN3~~ || ~~P13 = IN3~~ || 
|| -- ||  P11 = IN4 || ~~P14 = IN4~~ || ~~P12 = IN4~~ || 
|| MotorB ||  12-15 || ~~d_20 d_21 d_22 d_23~~ || ~~d_11 d_10 d_9 d_8~~  || Vin Motors Can be 5-12v  ||
|| -- ||  P12 = IN1 || ~~P20 = IN1~~ || ~~P11  close to the senosor = IN1~~  || 
|| -- ||  P13 = IN2 || ~~P21 = IN2~~ || ~~P10 = IN2~~  || 
|| -- ||  P14 = IN3 || ~~P22 = IN3~~ || ~~P9  = IN3~~  || 
|| -- ||  P15 = IN4 || ~~P23 = IN4~~ || ~~P8  = IN4~~  || 
|| HC05/HC06 ||  26-27 || ~~P2, P0, P1~~ || ~~P27, P26, P22~~ || Vdd 3.3v||
|| --   ||  p26 = HC06-Tx || ~~P2 = bt Tx~~  || ~~P27 = bt Tx~~ ||
|| --   ||  P27 = HC06-Rx || ~~P0 = bt Rx~~  || ~~P26 = bt Rx~~ ||
|| --   ||  xx || ~~P1 = bt KEY~~ || ~~P22 = bt KEY~~ || (KEY is not used on HC06 carrier board version) ||

run the bot 100 mm, and see how far the bot actually travels. 
-----


= III. Test Individual Parts =

 * Quickstart
 * Stepper Drivers
 * SR04 
 * Blue Tooth

== 1. Quickstart == 

 First we see the Quickstart microcontroller board, what it does, and check that  works. 

 Using the PropTool, LOAD the EEpromkernel.spin firmware into the quickstart board eeprom memory.

 Use the EEprom kernel instead of the DevKernel.spin

 http://code.google.com/p/propforth/wiki/GettingStartedWithPropForth  

  === a. Hello World ===

  See the page for Hello World,  then return to this page. 

  http://code.google.com/p/propforth/wiki/GettingStartedHelloWord

  === b. Blinky LED ===run the bot 100 mm, and see how far the bot actually travels. 

  See the page for Blinky LED, then return to this page

  http://code.google.com/p/propforth/wiki/GettingStartedBlinkyLED

== 2. Stepper Drivers == 

 The stepper motors are driven by the little hardware board they are connected to.  Four control lines run from the quickstart to the motor driver, and two wires run from power and ground;  and five wires run from the driver to the motor itself.  The fifth wire to the motor is ground.  The other four wires send power to th motor coils, and the prop controls when they are on and off. 

 The stepper drivers are actually ULN2004 darlington transistor arrays.  We can use then as stepper drivers since the current and voltage are low. The same code we are using now with BIG STEPPERS and other general stepper driver hardware.  

   === a. Blinky LED again ===

   Connect each motor's in1 to in4 to the Quickstart header per the chat above.  Also connect the (+) from the ULN2003 to the battery (+) red wire connector, and the (-) to the battery (-) black wire connector.

   After the connections are made, test them using the same code as blinky LED.  For each stepper, start with pin x and type

   {{{ 

x pinout x pinhi x pinlo

}}}

   You will see each pin light if the connections are correct.  

   If the pins do NOT light, or if you smell something, UNPLUG the USB immediately. TURN OFF the battery switch.  If these burn, they will no longer work.  Check the connection, and start again. 

   === b. MotorA or MotorB? ===

   After the LED all light properly, try to run code. 

   MotorA is the first one, and should be on the left. MotorB is the other one, and should be on the right.  If this is not so, the bot will run backwards.  No biggie, just switch the wires that are easiest. You can either unplug and replug the four wires for each motor at the quickstat; or you can unplug the bundle of wires from the motor to the ULN2003 board, and swap those. 

   Copy the code from the file linked below to a text file.  CHANGE THE PINS in the file to the ones listed in the chart above. 

   http://code.google.com/p/propforth/wiki/LittleRobotDemoSteppers


== 3. SR04  == 

  The SR04 is the Ultrasonic Range finder.

   === a. 5.0 volts power ===

   The SR04 connects to 5.0 V on the red (+) battery connector. 

   === b. 10K on ECHO ===

   The 10k ohm resistor goes between the SR04 echo pin and the Quickstart input pin P25.  The extra Female to Female jumper wire is for this.  Slide one end of the F-F on the SR04 echo pin; slide the other F connector onto tone leg of the resistor.  The remaining leg of the resistor goes in the F side of the M-F jumper, and the Male Pin of the jumper plugs into P25. 

   === c. SR04 test program ===

   Be sure the pin assignments match the chart above.  Sometimes I forget to change them in the code, better check!

   Also, notice that there is MORE TO THIS SECTION after the code, check the end after the code is loaded!!!!

http://code.google.com/p/propforth/wiki/LittleRobotDemoUltrasonic

NOTICE! You must highlight all the way to the cr if you copy from this web page. Otherwise, copy  the code to your text editor, and work from your edited copy.

REBOOT to see the above programs load and run.  The Quickstart LEDs should flash in relation to the distance.  Each LED represents 20 cm counting in binary. Talk about binary with the group until you understand. 
  
   === d. Good Data ===

   When the sensor starts running,  point the sensor at a large flat object  close to the sensor,  like a wall.  Notice that the sensor give a single continuous reading. This is a "good" reading.  Only one single comes back, the sound that bounced of the wall. 

   === e. Noisy Data ===

   Now point the sensor at a bunch of small things a little bit far away.  This could be a bunch of chair and table legs. notice that the measurements tend to jump around.  This is because the signals are coming from a whole bunch of objects at different distances.  This is a noisy reading. We can use this too, but we have to be a little clever.  We'll get to using noisy data in an advanced session. 

== 4. HC06 Blue Tooth == 

The blue tooth module is a little bit tricky the first time through, so we have pre-programmed the modules.  

If you try to program or reprogram modules on your own, refer to 

http://code.google.com/p/propforth/wiki/LittleRobotBluetooth

  === a. blue tooth prop connections ===

  HC06 Tx goes to the prop quickstart pin 26

  HC06 Rx goes to the prop quickstart pin 27

  === b. blue tooth POWER is 3.3 ===

3.3 volts is provided on the QUICKSTART  40 pin header. 3.3v is the SECOND FROM THE RIGHT ON THE TOP. Be careful, it is right next to the 5volt Vin.

REMEMBER!  The bluetooth modules use 3.3volts ONLY!  Do NOT connect the HC06 to 5.0 volts. The 3.3 volt connection is the second from the right on the top, on the Quickstart 40 pin connector. Refer to the PinFinder, its printed right on there. 
 
   === c. blue tooth ground ===

   The bluetooth module connects to the same black wire (-) negative connection on the battery pack as as do all the other components. 

   === d. blue tooth program ===

   The the program boots, it looks for the Bluetooth Tx pin.  The HC05 and HC06 bluetooth modules we use hold the Tx line hi.  Normally all the lines are low. So, if the pin wherre we expect a Tx is held hi, we probably has a BT module, and prpbably want to use it.  So, iwhen the program detects the T hi at boot, it switches to use the Tc pins.  The regular terminal doesn't respond as its no longerr needed.

   If you wish to skip the boot behavio (to use the regular PC terminal), you can use either of these methods, depenedin on your needs: 

  * hold down the ESC key during boot. This prevents the autoboot from rrunning, and so prevents the drivers from starting.  The stepper, LED, and BT programs are loaded and available, but do not start by themselves.



Note that the baud rate is four time that listed; `57600 * 4 = 230400`

-----

= IV. QSbot program =

The QSbot program is really just  modified ONREST6 and BOOT.f

After the devices are shown to work using the code linked above, the following onreset6 and boot.f files. 

These are just combine the oneset6 and boot.f from the individual drivers. 

The most recently uploaded version of a file (closest to the bottom of the fsls list) is the version that is used. This effectively overwrites the old version, without having to physically remove the old version. 

{{{

fl 

\ BOOT.F for HC06 bluetooth, steppers, S04 measurement, and LED display

fswrite boot.f

hA state orC! version W@ .cstr cr cr cr
: findEETOP
0 h100000 h8000
do
i t0 2 eereadpage
if
leave
else
i h7FFE + t0 3 eereadpage
if
leave
else
drop i h8000 +
then
then
h8000 +loop
;

c" boot.f - Finding top of eeprom, " .cstr findEETOP ' fstop 2+ alignl L! forget findEETOP c" Top of eeprom at: " .cstr fstop . cr

c" boot.f - Loading ansi.f~h0D~h0D" .cstr hA state andnC!
fsload  ansi.f
c" boot.f - Loaded ansi.f~h0D~h0D" .cstr hA state andnC!
c" boot.f - Loading sr04-testbed.f~h0D~h0D" .cstr hA state andnC!
fsload  sr04-testbed.f
c" boot.f - Loaded sr04-testbed.f~h0D~h0D" .cstr hA state andnC!
c" boot.f - Loading QSbotStepper.f~h0D~h0D" .cstr hA state andnC!
fsload QSbotStepper.f
c" boot.f - Loaded QSbotStepper.f~h0D~h0D" .cstr hA state andnC!
c" boot.f - Loading BTtest.f~h0D~h0D" .cstr hA state andnC!
fsload BTtest.f
c" boot.f - Loaded BTtest.f~h0D~h0D" .cstr hA state andnC!

cr cr
c" boot.f - DONE PropForth Loaded~h0D~h0D" .cstr hA state andnC!


\  ONRESET6 for HC06 bluetooth, steppers, S04 measurement, and LED display

: onreset6
          fkey? and fkey? and or h1B <>
  if
    $S_con iodis $S_con cogreset 100 delms
    c" hcRx hcTx 57600 serial" $S_con cogx 100 delms
    cogid >con
    c" init_motorA" 0 cogx
    c" init_motorB" 1 cogx
    c" _sr04_measure" 2 cogx
    c" sr04_display" 3 cogx
then

\ Menu \ for stepper testing
c" onreset6" (forget)
sr04_test
;

...

cr

}}}

= V. Tweak the Calibration values =

The two key motions have calibration values.  

 * `_distance_cal` is the distance the bot move for one complete revolution of the wheels.
 * `_right_cal` is the distance the wheels move to rotate 360 degrees.

These calibration values are adjusted each time the wheel size of body size changes.  Other factors also influnece these values, such as friction between the floor and the wheels, and the friction between the tail peice and the floor.

== 1. calibration methods ==

There are two simple methods used to calibrate the bot motions

 * measure and calculate
 * successive approximation 

 === A. measure and calculate: ===

 Measure the diameter of the wheels. Use the diameter to calculate the circumference of the wheel.  The formula for circumference is 
 
 ` D  * Pi = Circumference `

The milled acrylic wheels with the rubber tread should be about 80 millimeter.  80 times Pi is about 251.3, so the wheels will travel about 251.3 millimeters in one rotation. 

 === B. successive approximation: ===

Successive approximation is a way to test, and 'dial-in' till we find the correct value. 

   # Set the value too high, test.
   # Set the value too low, test. 
   # Take the average of the last two values, test.
   # repeat

Each time, the average of the two previous values gets us closer.  The amount we change is alway half of the previous amount.  when the amount of change is 1 unit,  we are done.run the bot 100 mm, and see how far the bot actually travels. 

-----

== 2. `_distance_cal` ==

`_distance_cal` is the distance the bot move for one complete revolution of the wheels.

   # Set the value too high, run the bot 100 mm, and see how far the bot actually travels. 
   # Set the value too low, run the bot 100 mm, and see how far the bot actually travels. 
   # Take the average of the last two values, run the bot 100 mm, and see how far the bot actually travels. 
   # repeat

Each time, the average of the two previous values gets us closer.  The amount we change is alway half of the previous amount.  when the distance is exact or the amount of change is 1 unit,  we are done.

After a few tries, the bot will travel exactly 100mm when commanded. Test by commanding 500 mm, etc, and verify that the bot travels the specified distance.

 === measure and calculate:  ===

   # Measure the diamter of the wheels.  
   # The milled acrylic whells with the rubber tread should be about 80 millimeter.  
   # 80 times Pi is about 251.3, so the wheels will travel about 251.3 millimeters in one rotation. 

 * _distance_cal is the distance the bot move for one complete revolution of the wheels.
 * _right_cal is the distance the wheels move to rotate 360 degrees.

 === successive approximation: ===

   # Set the value too high, run the bot 100 mm, and see how far the bot actually travels. 
   # Set the value too low, run the bot 100 mm, and see how far the bot actually travels. 
   # Take the average of the last two values, run the bot 100 mm, and see how far the bot actually travels. 
   # repeat

After a few tries, the bot will travel exactly 100mm

I started with the deafult value of 263 for `_distance_cal` and calculated 251. It was a little short so I round up to 252. seems spot on now. 

-----

== 3. `_right_cal` ==

`_right_cal` is the distance the wheels move to rotate 360 degrees.

   # Set the value too high, 360 degrees right (`3600 r`, its in 1/10th of a degree) , and see how far the bot actually rotates. 
   # Set the value too low, 360 degrees right (`3600 r`, its in 1/10th of a degree) , and see how far the bot actually rotates. 
   # Take the average of the last two values, 360 degrees right (`3600 r`, its in 1/10th of a degree) , and see how far the bot actually rotates. 
   # repeat

After a few tries, the bot will rotate pretty much exactly 360 degrees. 

 === measure and calculate:  ===

 # Measure the width of the chassis
 # From wheel center to wheel center is about 120 mm
 # `120 * pi = 376.99 `  The The wheel would have to travel 376 mm to rotate 360 degrees.  But both wheels are moving. Now I'm getting confused...

 === successive approximation: ===

... So lets just use successive approximation. I started with the deafult value for `_right_cal~ and ended with 5718 when I noticed the tail was sticking and the batteries were low. 




== Tweaked code ==

All we need to do is keep loading the last file after we edit it.   The last version of the file is the one that Propforth sees, the others are ignored. 

After pasting this edited file into the termianl window, reboot

After reboot, connect via blue tooth, and test again. 

NOTE:  ASK ABOUT TEFLON TAPE ONE THE REAR SKID!!!!

{{{
\ reload with new calibration attempts:

fl 

fswrite QSbotStepper.f

: _mota_pins d_8 d_9 d_10 d_11 ;
: _motb_pins d_12 d_13 d_14 d_15 ;

\ 263 wconstant _distance_cal
\ 251 wconstant _distance_cal

252 wconstant _distance_cal

\ 6052 wconstant _right_cal
\ 6000 wconstant _right_cal
\ 5000 wconstant _right_cal
\ 5500 wconstant _right_cal
\ 5750 wconstant _right_cal
\ 5625 wconstant _right_cal

\ 5687 wconstant _right_cal \ ok, ten time was short
\ 5688 wconstant _right_cal \ ok, ten times left was short 
\ 5718 wconstant _right_cal \ ok, ten time 
\ 5734 wconstant _right_cal \ ok, ten time 
 5742 wconstant _right_cal \ ok, ten time 


c" QSBOT " prop W@ ccopy

_right_cal  propid W!  \ change this nubmer so we know we changed the code

fsload 4step.f

_mota_pins      step_create_halfstep motha
_motb_pins      step_create_halfstep mothb


: init_motorA
c" MOTOR A" cds W! motha step_init 0 motha step_accel 900 motha step_setspeed
;

: init_motorB
c" MOTOR B" cds W! mothb step_init 0 mothb step_accel 900 mothb step_setspeed

;

: forwarda
motha step motha step_sleep
;

: forwardb
mothb step  mothb step_sleep
;

: reversea
negate motha step  motha step_sleep
;

: reverseb
negate mothb step  mothb step_sleep
;


: forward
4096 _distance_cal */ <# #s #> dup 0 cogx 1 cogx
c"  forwarda" 0 cogx
c"  reverseb" 1 cogx
;

: reverse
negate forward
;

: right
_right_cal 3600 */
<# #s #> dup 0 cogx 1 cogx
c"  reversea" 0 cogx
c"  reverseb" 1 cogx
;

: left
negate right
;

: f forward ;
: r right ;
: l left ;
: b reverse ; 
: .cal cr  
." _distance_cal = " _distance_cal .
."    _right_cal = " _right_cal .
cr st?  ;

: Menu 
       cr cog? 
       cr cr ." Commands are:" cr
        cr ."  f forward "
        cr ."  r right "
        cr ."  l left "
        cr ."  b reverse " 
        cr ."  .cal - print cal values "
        cr cr
; 

\  we don't want a new onreset6 here
\ we dont want a new boot.f
\ we do want new call values in QSbotStepper.f

...


}}}


= NOTES =

  * The QS LEDs are used to visually represent the current distance measurement.  This also serves as a "Ready" indicator. 
  * QS LED count increments of 20mm ( try 15 or other values) 
  * SR04_display routine shows the numeric value for the distance measurement without scrolling 
  * The extra `dup drop` pairs are removed from the SR04 trigger pulse routine
  * The SR04 driver includes a 60 ms recovery time per the data sheet.

We may also add more functions to QSbot.f, depending on user needs.  On the list of functions to add:
  * SR04 - Add a flag to control measurement ON/OFF
  * SR04 - add timeout for too long measurement (?)
  * SR04 - Add variance
  * SR04 - Add running average, 
  * SR04 - Add recent min and max, 
  * SR04 - Add detect receding/closing, 
  * SR04 - Add detect too close/too far

QSbot.f is based on [http://code.google.com/p/propforth/wiki/LittleRobotDemoProgram#bot-fixed.f bot-fixed.f], which is base on the original bot.f from the Extensions directory in the Propforth-v5.5 download.

= CHANGES from bot.f =

Sal's demo program bot.f was first pass at brining together several drivers o test the LittleRobot proof of concept prototype.  Now that we've been using it, there are a couple improvement we make right off the bat.  Here are things we changed, if you wish to compare the two.   

 * SR04 resistor - 10k
 * pinout - Don't use the pins already used by buttons 0-7 for peripherals
 * pinout - Use the pins already used by buttons 0-7 for input 
 * pinout - Use pins 8 to 15 for motors
 * pinout - Don't use the pins already used by LED on 16-23 for our drivers
 * pinout - Use the pins with LED 16-23 to display the distance measurement
 * pinout - Use pins 24 to 27, as these are not assigned
 * pinout - Use pin 24 for SR04 trigger
 * pinout - Use pin 25 for SR04 echo
 * pinout - Use pin 26 for blue tooth Tx
 * pinout - Use pin 27 for blue tooth Rx



= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages