#summary Using a custom Serial connection
#labels v5.0,Serial


<wiki:toc max_depth="9" />


= regular full duplex serial connection =

To start a regular full duplex serial connection, we use the "term" and "serial" words. 

serial is optimized in assembly and built into the kernel.

term is a short but scarey looking bit of code, we can just paste it in with out digging too deep at the moment. 

== term ==

define the "term" word:

{{{
\ terrm \ ( cog 0 - )
: term
      over cognchan min 
      ." Hit CTL-P to exit term, CTL-Q exit nest1 CTL-R exit nest2 ... CTL-exit nest9~h0D~h0A"

      >r >r cogid 0 r> r> (iolink)

      begin 
           key dup h10 = 
           if drop -1 
           else dup h11 h19 
                between 
                if 
                   1- 
                then 
                emit 0 
           then 	
      until
      cogid iounlink
;

}}}

The "term" word is abbreviation for terminal.  The parameters passed on the stack are the cog to talk to, and a flag (that is always zero for me, I should figure out what it for). 


== serial ==

{{{
c"  0 1 115200 4 /  serial" nfcog cogx
}}}

serial ttakes three parameters:  Tx-pin Rx-pin and Baud rate.

 * Tx is the pin you have selected to talk on (transmit)
 * Rx is the pin you have selected to listen (recieve)
 * baud is the Baud Rate DIVIDED BY FOUR!!!

Remember, we must divide the baud rate by four!  The baud rate USED to fit in a word (2 bytes) memory cell up to baud 57600. But the biggest number in a word is 65535.  

Now we routinely use 230400. This would require a larger memory cell allocation. Sal considered using a another word, and storing the baud value in a long.  While this would only cost 1 more word for the storage, it would require a bunch of code changes to access the long. The net cost increase would be more than just one word. 

Rather than use the extra memory, and make a bunch of other code changes, Sal decided to use (baud divided by four).  This way, all current valid baud rates still fit in a word size cell. While other code changes were made to support higher baud rates, those had to happen anyway.  This solution appear to have the minimum impact on code size and execution speed.

Tx = pin 0
Rx = pin 1
baud (115200) = 115200/4 = 28800

We could do the example above either 
{{{
c" 0 1  115200 4 /  serial" nfcog cogx
}}}

or

{{{
c" 0 1 28800  serial" nfcog cogx
}}}

The division operation only hapens once at compile time, so the impact of the expensive division operation on execution speed is negligible. And having "baud 4 /" helps me remember.  OK, its a little weird, space is at a premium, and it works. 




== the full code ==

{{{

: term
	over cognchan min ." Hit CTL-P to exit term, CTL-Q exit nest1 CTL-R exit nest2 ... CTL-exit nest9~h0D~h0A"
	>r >r cogid 0 r> r> (iolink)
	begin key dup h10 = if drop -1 else dup h11 h19 between if 1- then emit 0 then 	until
	cogid iounlink
;

c" 0 1 28800  serial" nfcog cogx

cog?

5 0 term

}}}


= Custom Serial Connection =

From forum post 

http://forums.parallax.com/showthread.php?138399-Propforth-5.0-is-available-for-download&p=1083307&viewfull=1#post1083307

This draft will go into PROPFORTH.html when complete

= new info 20130527 =

Propforth 6  will implement serial with flow control. There are many types of flow control, some of these are contradictory or incompatible with each other.  propforth will implement a SPECIFY scheme that will function properly. 

Testing has demonstrated that this scheme delivers about 20k character per second.  Compare to Bluetooth which delivers about 5k character per second as 230400 baud. 

= About SERIAL = 

SERIAL is necessarily built into the kernel, but we tend to use it all over the place in various (modified) forms. To allow the default SERIAL to be present in the kernel , and to allow modification to the kernel default at the same time, SERIAL is a loadable module.

There are two parts the the serial function: {{{_serial }}} and {{{serial}}}.  
The "internal" part is in the definition {{{_serial}}} (with an underscore). This does that internal kernel operation for serial communications. Generally, we don't want to call {{{_serial }}} or any of its subfunctions directly.
The "external" part is in the definition {{{serial  }}} (with no underscore). This is the function the user or application calls to interface to the function.
The external word {{{serial  }}} is the "interface", this is the word "packages up" the function and is how to get at {{{_serial }}} .

= INTERNAL {{{_serial }}}  =

The high level source code for {{{_serial  }}} is in
{{{
..\kernels\BootKernel\BootOptimizeKernel\
PropForthBootOptimzeAsmSrc.f
 }}} 


Rename file 
{{{
PropForthBootOptimzeAsmSrc.f 
}}}
and modify it as necessary for your particular needs.

This is actually assembler code (and was based on forth definitions in previous versions). This serial code has been optimized to the extent that it is no longer useful to go back to a high forth version for this function.

{{{ serial  }}} assembler code starts at line 775 actually at label:
{{{
build_BootOpt :rasm
}}}

{{{ serial  }}} assembler code ends at line 1104
{{{
;asm _serial
}}}

= EXTERNAL serial =

The high level source code for {{{ serial  }}}  is in
{{{
..\kernels\BootKernel
PropForthStartKernel.f
 }}} 

The are some {{{ serial  }}}  related constants at lines 54 through 60

The high level forth definition for {{{ serial }}} is at line 2459

what {{{serial}}} does:
 # changes baud to number of clock cycles
 # takes the string to be displayed in {{{cog?}}} and sets it up
 # takes cog and marks it as no longer available {{{(4 state nc!)}}}
 # sets flags (HC08 is 1 done expand CRFL)
 # set break length to 0
 # starts {{{_serail}}}

= INTERFACE to {{{_serial }}}  VIA {{{serial  }}}  =

Please notice the the difference between {{{_serial  }}} and {{{serial  }}} is
 * {{{_serial  }}} takes number of clocks per bit
 * {{{serial  }}} takes baud rate

see 
{{{  
..\kernels\doc\tutorials
tutorial-3.2 Serial Loopback.txt 
 }}}

For instructions how to start a serial connection


see
http://code.google.com/p/propforth/wiki/HalfDuplexSerial
for information on half duplex serial

= DOCUMENTATION EXPERIMENT =

We are hoping that the user community will contribute to the documentation. The idea is that as each user question is resolved, the user that receives the answer helps us "write it up" such that other folks can understand it, and this gets added to the PROFORTH.html document.

@Markus - Please give this a look, and see if this gets you any further along. Please ask more questions, we will work with you till you feel you understand the functions sufficiently to do what you want.

If Markus (and the rest of us) can help us write up the documentation for this function to ensure that it is sufficiently clear and complete, Sal will add to PROPFORTH.html. We want to give this "user question driven" documentation model a try, to off-load Sal and limit effort to questions that are have been asked. (Trying to anticipate every possible question didn't work out previously). 