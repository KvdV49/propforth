#summary Wednesday was Jimmy Flying solo.
#labels LittleRobot,v5.5

= Introduction =

Wednesday is instructor Jimmy conducting Lab and Review. 

Hopefully, we have prepared the instruction for session without developer support

Wednesday 20130501 was to be Jimmy's first session on his own, but this was overcome by events. The following session, Friday, we will try Lab and Review.   Professor Braino and Boy Chance will be present, but we will refrain from leading and observe how the lab might be conducted in our absence. 

Jimmy has most of what we think he needs:

  * Windows laptop
  * proptool installed
  * propforthv5.5 downloaded and unzipped
  * USB cable
  * devkernel.spin loaded to EEPROM
  * completed Hello World 
  * completed LED01

Jimmy does NOT have:

 * video conference software properly configured on laptop (maybe its just too old and broken?)
 * voice chat software properly configured on laptop 

WE need to fix this Friday

We have not completed the arrangements for one laptop per robot; there are some complications as laptops are not usually assigned to the younger students.

= Review =

Ensure everyone has complete Hello world, and trained anther;  then practice

Ensure everyone has completed pinhi, and trained another;  then practice

Ensure everyone has completed ascending descending LEDs, and trained another;  then practice

= review materioal that was not covered properly when introduced =

We used these, but did not explain them. My bad. Upthe earlier lessons after the pilot session ends, and put these where they belong.
  * sc 
  * st? 
  * . 
  * ."
  * "


== forth word sc ==
  
sc is STACK CLEAR.  This deletes all the items on the stack, and tells you how many it got rid off. This is very useful in debug and test, when things might be acting different than you expect. It cleans up the stack.

== forth word st? ==

st? is "display the contents of the stack".  The numbers are formatted as 32 bit longs, such that we can always see every bit represented.  Explain what this means, it might be too much for the kids.  And teachers. 

== forth word - . (dot) ==

The period or dot takes a number off the stack, and puts it on the display as a number. 

Type the following 

{{{
1 45 87 34 99 
. . . . .
}}}

Compare dot to `st?`, where the values are padded with leading zeros.  When dot executes, only the non zero bits are displayed, the number is NOT padded with zeros.

== forth word  ." (dot-double-quote) ==

Dot-double-quote begins a string literal

== forth word  "  (double-quote) ==

double-quote terminates a string literal

= new material =

Today we will use fkey?, if, and then.  Introduce FLAGS. More character I/O words. Add explanation of some words we didn't explain properly.

I/O means Input and Output.  Discuss I/O

== New Word - emit == 

The stack note for emit is:

{{{
\ emit ( char - )  \ type a single character to the display
}}}

Emit takes a number off the stack, and tries to display it as an alphanumeric on the display.   Try the following:

{{{
55 emit
76 emit
33 emit
255 emit
256 emit
}}}

Here's something neat and scary.  IF YOU EMIT  the proper sequence of numbers, YOU  can reprogram the PC!!!!!!!!!!!!  YES!!!! Muhuhahahahahaha!  This is tons of fun, folks can never figure out that you pranked them!!!  Also, you can sometimes prank yourself!!! For HOURS!!! Hahahahahaha!

Remember, if you prank yourself, and reprogram the PC terminal program, exit the terminal program (teraterm or cool term) and restart it. 

If you deprogram the quickstart, , press the reset button. If that doesn't work, ask the teacher, perhaps the Propforth kernel needs to be re-burned into EEPROM (we'll explain that later). 

== FLAG ==

A *FLAG* is a value where zero `0` means NO or FALSE; and anything that not zero like 1, -1, 17, a million, are all considered to mean TRUE or YES

Flags are a big deal, we will use these again. 

Putting a zero on the stack is used to tell the next routine NO

Putting a non zero 1, -1  etc on the stack tells the next routing YES

This is really cool, its the essence of how computers talk.

== New Word - fkey? ==

`fkey?` is the coolest function.  When this word is executed, it preforms:

  * Was a key Pressed?
and
  * What key was pressed?

`fkey?` has the following stack note:

` \ fkey? ( - char t/f )  `

The parts before the DASH says what it consumes from the stack, and the part after the dash says what it deposits on the stack. 

This says, ( `fkey?` takes no items from the stack.  - `fkey? leaves a character, and a flag )

If a key on the keyboard was press, the stack will have number that represents the key that was pressed, and a TRUE flag.

If the a key was NOT pressed, the stack will have a number that would be impossible to get from a key, and a FALSE or zero flag

== word pair: if...then ==

If and then go together as a pair.  the pair needs to match; otherwise behavior is undefined.  This means things can get strange and unpredictable, which is what we DON'T want.  

== New Word - if ==

`if` consumes a value of the stack.  The value is used as a flag.  

  * For value zero (0) propforth will jump the first word after `then`
  * For values non-zero (1, -1, 40672, etc) propforth continues exectuion with the word after `if`

== New Word - then ==

`then` marks the end of `if`.  When `if` encounters a FALSE, execution jumps to after the `then`

= TASK - ESCAPE KEY =

Often, we want to run a program and control when it stops by hitting a key.  Traditionally, we use the escape key (ESC) to escape from an executing program.


{{{


\ : test \ ( N - )  N = number of time to loop during testing

: test 

      0 do i . 
           fkey? 
                 if 
                     h_1B = 
                           if
                             leave 
                           else  
                             emit 
                           then 
                 else 
                     drop 
                 then 
                 500 delms
      loop ; 

st?

99 test  st?

st?            
}}}


= words up till today =

These are the FORTH words introduced so far:

= words =

session 03

|| word || name || stack note || used for || terminator ||
|| if || if || ( t/f - )||  if condition flag is tru, do the following, otherwise skip to after the THEN || then ||
|| then || then  || ( - )||  this is the end of the stuff the if does when it see true;  execution continues with the next word after THEN|| space ||

add these

|| emit || fkey? ||


session 02

|| word || name || stack note || used for || terminator ||
|| delms || delay for milliseconds || ( n - )||  pause fo so many milliseconds || space ||
|| i || iteration counter || ( - n )||  the number of this loop, beteen N1 and N2off the do...loop || space ||
|| do || do repeatedly || ( N1 N2 - )||  Do this following starting wilth N2, and stop when it reaches N1 || space ||
|| loop || end of the repeated loop  || ( - )||  when we reach here, go back to the do and see if we still need to repat || space ||
|| +   || plus || (n1 n2  - n3 ) || add n1 and n2 and leave the result n3 on the top of the stack || space ||
|| - || minus || ( n1 n2  - n3 ) || start with n1, subtract n2, leave the result n3 on the top of the stack || space ||

Add these to session 2


||. ||



session 01

|| word || name || stack note || used for || terminator ||
|| pinout || pin-out || ( n - )||  make a pin an output || space ||
|| pinhi || pin-high || ( n - )||  make a pin a logically high Vdd || space ||
|| pinhi || pin-low || ( n - )||  make a pin a logically low Vss || space ||
|| pinin || pin-in || ( n - )||  make a pin an input || space ||
|| :   || colon || (identifer - ) || starts a new word definition || semi colon ; ||
|| ; || semicolon || ( - ) || ends a new word definition started by colon || space ||


Add these to session 01

|| ." || "||






= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages