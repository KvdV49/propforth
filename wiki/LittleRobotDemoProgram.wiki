#summary Sal's demo software for LittleRobot Demo
#labels LittleRobot,v5.5

<wiki:toc max_depth="9" />

= Introduction =

This is contents of BOT.F in the extensions directory of the download archive.
It is MODIFIED for the particulars of the Ancona robot kits, with notes.

Check the notes to mod the software for you bot!

= PIN configuration = 

The BOT.F program below has two options for connecting the pins for the peripherals (these are the sensors and actuators, the motors and range finder).


*Ancona ~~is~~ WAS using BOT1*

There may be an issue with Quickstart pins 16 and 17 for SR04 due to the LEDs and drivers.  TRYING BOT2, just shift the wires.

The program Looks at Pins P2 and P27.  This is the BLUETOOTH Tx line, it is held high.  So the program can find where the Bluetooth is by looking for the Blue tooth Tx line. 

{{{
2 px? 27 px? 0= and [if 1 wconstant build_bot1 ]
27 px? 2 px? 0= and [if 1 wconstant build_bot2 ]
}}}

  * If 2 is high ( bt Tx ) and 27 is low use  BOT1 pinout ( ~~USE BOT1~~ )
  * If 27 is high ( bt Tx ) and 2 is low use  BOT2 pinout ( trying bot 2 due to SR04 )

== BOT1 ==

~~We are using BOT 1 for the time being, it flashes the Quickstart LEDs~~

The SR04 on pins 16 and 17 might have a problem, try bot2

{{{

[ifdef build_bot1
\ for the HC05

1 wconstant hcProgPin
0 wconstant hcRx
2 wconstant hcTx

16 wconstant _sr04_trig
17 wconstant _sr04_echo

3 wconstant _ready_led

: _mota_pins d_24 d_25 d_26 d_27 ;
: _motb_pins d_20 d_21 d_22 d_23 ;

263 wconstant _distance_cal
6052 wconstant _right_cal
c" BOT " prop W@ ccopy
1 propid W!
]
)))

}}}

== BOT2 ==

Bot 2 uses the LEDs differently.  We'll try this in a later session. 

== Connect the wires per the chart ==

=== PIO - Pin Assignments to the Prop 40 pin connector ===

We used BOT 1 in class Ancona Spring 2013.  But now try BOT2.

|| || Bot1 || Bot2 ||
|| SR04  || 16 trig, 17 echo || P24 trig, P25 echo  || Vin ||
|| -- || P16 trig || P24 trig ||
|| -- || P17 echo || P25 echo || BE SURE ECHO HAS 10k ohm resistor! see note below ||
|| Ready LED || P3 || P23 ||
|| MotorA || d_24 d_25 d_26 d_27 || d_15 d_14 d_13 d_12|| Vin ||
|| -- ||  P24 = IN1 || P15 = IN1 || 
|| -- ||  P25 = IN2 || P14 = IN2 || 
|| -- ||  P26 = IN3 || P13 = IN3 || 
|| -- ||  P27 = IN4 || P12 = IN4 || 
|| MotorB || d_20 d_21 d_22 d_23 || d_11 d_10 d_9 d_8  || Vin ||
|| -- ||  P20 = IN1 || P11 = IN1  || 
|| -- ||  P21 = IN2 || P10 = IN2  || 
|| -- ||  P22 = IN3 || P9  = IN3  || 
|| -- ||  P23 = IN4 || P8  = IN4  || 
|| HC05/HC06 || P2, P0, P1 || P27, P26, P22 || Vdd ||
|| --   || P2 = bt Tx  || P27 = bt Tx ||
|| --   || P0 = bt Rx  || P26 = bt Rx ||
|| --   || P1 = bt KEY || P22 = bt KEY || (KEY is not used on HC06 carrier board version) ||
|| || || || REMEMBER HC05/HC06 uses Vdd 3.3 volts!!! The rest use Vin!!!!||

  ==== UPDATE SR04 RESISTORS ====

* UPDATE SR04 RESISTORS*

Turns out there were at least two issues:

  # the resistor on SR04 echo is ~~3.9~~ 10K ohms, NOT 330 ohms.
  # The 330 ohm resistor caused a problem, to correct:

If you started with the 330  ohm resistor, switch to 10K ohm resistor. When the bot is powered on, the SR04 works correctly.

Note that the SR04 only reads correctly when the motors are stopped. This will be discussed later. 

=== POWER - Connections from the Battery pack to all the devices ===

These pins are the same on all configurations

||POWER || 5v Vin || Vss/GND ||3.3v Vdd || 
|| Battery pack || Vin = RED wire ||  Vss/GND = BLACK wire || - ||
|| MotorA || Vin || Vss/GND ||  - ||
|| MotorB || Vin || Vss/GND ||  - ||
|| SR04 || Vin || Vss/GND ||  - ||
|| Prop || Vin || Vss/GND || HC05/HC06 ||
|| HC05/HC06 || - || Vss/GND || Vdd/3.3v || 

REMEMBER:
  * Only HC05/HC06 connects to Vdd (3.3 volts)
  * The remaining parts connect to Vin 5.0 volts)
  * The SR04 MUST have the 10k ohm resistor between ECHO and P17, or the prop input will be damaged!

= The Program =

bot.f was Sal's original program.  It automatically detects the bluetooth, and initializes as BOT1 (this is for using protoboard, etc) or BOT2 (fo quickstart, allows quickstart LEDs to be used as diagnositics

bot-fixed - fixes some auto boot options, so we can escape autoboot for diagnostic.  Also allows Quickstat LEDs to display the SRR04 distance estimate. the LED display will not work with BOT1 pin out, this is only for BOT2.


== bot.f ==

START WITH THE EEpron KERNEL.  Load the EEprom kernel to the Quickstart using the PRopeller Tool software on the PC.  

Paste the entire contents of the code box below into the terminal program window to load the LittleRobot demo software

Or copy it to you own editor, make changes, then paste it in.

This has modification to use the Laser Cut Acrylic wheels and the 4x8 pink foam chassis.

{{{

fl

fswrite 4step.f
{

Drives a 4 phase stepper motor, tested with 28byj stepper motor wth a uln2003 driver

Create a structure, either a halfstep, or full step, specify the pins, 16 17 18 & 19 in this case


\ For half stepping
     16 17 18 19 step_create_halfstep moth


\ Initialize
     moth step_init

\ Step forward
     4096 moth step

\ Step reverse
     -4096 moth step

\ Turn off drivers
     moth step_sleep

\ Turn on drivers
     moth step_active

\ Set the step speed - setting too fast a speed will cause it to skip steps (1100 for test motor)
     1100 moth step_setspeed

\ or
\ For full stepping
     16 17 18 19 step_create_fullstep motf


\ Initialize
     motf step_init

\ Step forward
     2048 motf step

\ Step reverse
     -2048 motf step

\ Turn off drivers
     motf step_sleep

\ Turn on drivers
     motf step_active

\ Set the step speed - setting too fast a speed will cause it to skip steps (550 for test motor)
     550 motf step_setspeed



step structure
00 - 04 -- current step position - steps
04 - 08 -- current step velocity - steps / sec
08 - 0C -- max step velocity - steps / sec (should be a multiple of step acceleration)
0C - 10 -- step acceleration - steps / sec / sec (min 2)
10 - 14 -- step mask
14 - 34 -- 8 longs - step values
34 - 38 -- steps to speed
38 - 39 -- step position mask
}


\ 1 wconstant step_debug

h0  wconstant _step_position
h4  wconstant _step_current_velocity
h8  wconstant _step_max_velocity
hC  wconstant _step_accel
h10 wconstant _step_mask
h14 wconstant _step_bits
h34 wconstant _steps_to_speed
h38 wconstant _step_position_mask
h39 wconstant _step_size

[ifdef step_debug
\ step_dump ( addr -- )
: step_dump
	." current_position: " dup L@ . cr
	." current_velocity: " dup _step_current_velocity + L@ . cr
	."     max_velocity: " dup _step_max_velocity + L@ . cr
	."            accel: " dup _step_accel + L@ . cr
	."   steps to speed: " dup _steps_to_speed + L@ . cr
	."    position_mask: " dup _step_position_mask + C@ . cr
	base W@ swap hex
	."             mask: " dup _step_mask + L@ .long cr
	."             bits: "
	_step_bits + h20 bounds
	do
		i L@ .long space
	4 +loop
	base W!
	cr
;

\ step_dump1 ( addr -- )
: step_dump1
	." current_position: " dup L@ . 
	." current_velocity: " dup _step_current_velocity + L@ .
	."     max_velocity: " dup _step_max_velocity + L@ .
	."            accel: " _step_accel + L@ .
;
]

\ step_sleep ( addr -- )
: step_sleep
	_step_mask + L@ outa COG@ swap andn outa COG! 
;

\ step_active( addr -- )
: step_active
	dup _step_position + L@ over _step_position_mask + C@
	and 4* over + _step_bits + L@
	swap _step_mask + L@
	outa COG@ swap andn or outa COG!
;


\ step_init ( addr -- )
: step_init
 	dup _step_mask + L@ dira COG@ or dira COG!
	step_sleep	 
;

: _step_create1
	lockdict variable _step_size allot lastnfa nfa>pfa 2+ alignl freedict
	dup _step_size 0 fill
	4 ST@ >m 4 ST! 3 ST@ >m 3 ST! 2 ST@ >m  2 ST! 1 ST@ >m 1 ST!
;

: _step_create2
	rot2 or rot or rot or over _step_mask + L!
;

: _step_create3
	_step_bits + + L!
;

\ create a step structure

\ step_create_halfstep name ( n1 n2 n3 n4 -- )
: step_create_halfstep
	_step_create1
\ pin 1
	4 ST@ over 0 _step_create3
\ pin 1 2
	4 ST@ 4 ST@ or over 4 _step_create3
\ pin 2
	3 ST@ over 8 _step_create3
\ pin 2 3
	3 ST@ 3 ST@ or over hC _step_create3
\ pin 3
	2 ST@ over h10 _step_create3
\ pin 3 4 
	2 ST@ 2 ST@ or over h14 _step_create3
\ pin 4
	1 ST@ over h18 _step_create3
\ pin 4 1
	1 ST@ 5 ST@ or over h1C _step_create3

	_step_create2

	d_700 over _step_max_velocity + L!
	d_10  over _step_accel + L!
	d_70  over _steps_to_speed + L!

	_step_position_mask + 7 swap C!
;


\ step_create_fullstep name ( n1 n2 n3 n4 -- )
: step_create_fullstep
	_step_create1
\ pin 1 2
	4 ST@ 4 ST@ or over 0 _step_create3
\ pin 2 3
	3 ST@ 3 ST@ or over 4 _step_create3
\ pin 3 4 
	2 ST@ 2 ST@ or over 8 _step_create3
\ pin 4 1
	1 ST@ 5 ST@ or over h10 _step_create3

	_step_create2

	d_500 over _step_max_velocity + L!
	d_10  over _step_accel + L!
	d_50  over _steps_to_speed + L!
	_step_position_mask + 3 swap C!
;

\ _step_time( addr -- ticks)
: _step_time
	dup _step_current_velocity + L@ dup
\ addr cv cv
	2 ST@ _step_accel + L@ +
\ cv nv
	rot _step_max_velocity + L@ min
\ cv nv
	over - 2/ +
\ av
	clkfreq swap u/
;


\ __step ( +-1 addr xx -- +-1 addr xx )
: __step
	over _step_position + dup L@ 4 ST@ + swap L!
	over dup _step_current_velocity + L@ over _step_accel + L@ +
	over _step_max_velocity + L@ min swap _step_current_velocity + L!
	over step_active
;


[ifdef step_debug
: waitcnt
	over . dup . + cr
;
]

\ step ( n addr -- )
: step
	over 0<
	if
		-1
	else
		over 0>
		if
			1
		else
			0
		then
	then
\ n addr step
	dup 0<>
	if 	
		swap rot abs
\ +-1 addr n

		over _steps_to_speed + L@ 2* over <=
		if
			over _steps_to_speed + L@ dup >r tuck  2* - >r
		else
			dup 1 =
			if
				0 >r 0 >r
			else
				dup 2/ dup >r
				swap 1 and >r
			then
			
		then
[ifdef step_debug
		st? rs?
]
		over _step_time
[ifndef step_debug
		cnt COG@ +
]
		swap		

		0
		do
[ifdef step_debug
			i .long space
			over step_dump1
]
\ +-1 addr cnt
			__step
			over _step_time
			waitcnt
		loop

		r> dup 0=
		if
			drop
		else
			2 ST@ _step_accel + dup L@ >r 0 swap L!
			0
			do
[ifdef step_debug
				i .long space
				over step_dump1
]
\ +-1 addr cnt
				__step
				over _step_time
				waitcnt
			loop
			over _step_accel + r> swap L!
		then





		r> dup 0=
		if
			drop
		else
			2 ST@ _step_accel + dup L@ negate swap L!
			0
			do
[ifdef step_debug
				i .long space
				over step_dump1
]
\ +-1 addr cnt
				__step
				over _step_time
				waitcnt
			loop
			over _step_accel + dup L@ negate swap L!
		then

	then
	drop 0 swap _step_current_velocity + L! drop
; 

: step_accel
;

: step_setspeed
;

[ifdef step_test
d_16 d_17 d_18 d_19 step_create_halfstep moth
d_16 d_17 d_18 d_19 step_create_fullstep motf


\ _tstep ( steps addr -- )
: _tstep
	cnt COG@ >r
	2dup step
	cnt COG@ r> -
\ steps addr ticks
	2 ST@ abs
	u/
	d_1000_000 clkfreq u*/
\ steps addr usec/step
	." step:: steps: " rot .
\ addr usec/step
	over 5 + C@ 3 = if ." fullstep " then
	over 5 + C@ 7 = if ." halfstep " then
	over 6 + C@ ." accel: " .
	." usec/step: " dup .
	." steps/sec: " d_1_000_000 swap u/ . cr
	step_sleep
;

\ _step_test ( addr -- )
: _step_test
	dup step_init
	
	." Hit a key to terminate tests~h0D~h0D"

	fkey? nip 0=
	if
		d_12 0
		do
			i over step_accel
			fkey? nip 0=
			if
				d_8192 over _tstep d_1000 delms
				fkey? nip 0=
				if
					d-8192 over _tstep d_1000 delms
				else
					leave
				then
			else
				leave
			then
		loop
	then
	drop
;

: step_testh
	moth _step_test
;

: step_testf
	motf _step_test
;
]
 
...




fswrite sr04.f

1 wconstant build_sr04
[ifndef _sr04_trig
16 wconstant _sr04_trig
]
[ifndef _sr04_echo
17 wconstant _sr04_echo
]

variable _sr04_distance


: _sr04_measure
c" MEASURE" cds W!
4 state andnC!

_sr04_trig pinlo _sr04_trig pinout
_sr04_echo >m
_sr04_trig >m
begin
dup _maskouthi dup dup dup dup drop drop drop _maskoutlo

over dup dup dup

waitpeq
cnt COG@
rot2

waitpne
cnt COG@ swap -
d_170_000 clkfreq */


_sr04_distance L!
\ d_60 delms
d_200 delms
0 until
;

...

fswrite boot.f

hA state orC! version W@ .cstr cr cr cr
: findEETOP
0
h100000 h8000
do
i t0 2 eereadpage
if
leave
else
i h7FFE + t0 3 eereadpage
if
leave
else
drop i h8000 +
then
then
h8000 +loop
;

c" boot.f - Finding top of eeprom, " .cstr findEETOP ' fstop 2+ alignl L! forget findEETOP c" Top of eeprom at: " .cstr fstop . cr
c" boot.f - Loading bot.f~h0D~h0D" .cstr hA state andnC!
fsload bot.f
c" boot.f - Loaded bot.f~h0D~h0D" .cstr hA state andnC!
c" boot.f - DONE PropForth Loaded~h0D~h0D" .cstr hA state andnC!
...


fswrite bot.f


2 px? 27 px? 0= and
[if
	1 wconstant build_bot1
]

27 px? 2 px? 0= and
[if
	1 wconstant build_bot2
]

[ifdef build_bot1
\ for the HC05     \ \ BOT 1  \ \ BOT 1 \ \ BOT 1 \ \ BOT 1 \ \ BOT 1  

1 wconstant hcProgPin
0 wconstant hcRx
2 wconstant hcTx

16 wconstant _sr04_trig
17 wconstant _sr04_echo

3 wconstant _ready_led

: _mota_pins d_24 d_25 d_26 d_27 ;
: _motb_pins d_20 d_21 d_22 d_23 ;

\ 263 wconstant _distance_cal  \ Sal's
\ 229 wconstant _distance_cal  \ laser cut acrylic 20130601 73 * pi = 229.33
\ 6052 wconstant _right_cal    \ Sal's

\  The 4x6 inch wide pink foam blocks with wheels are 119 mm wide so
\ The body radius (wheel base/2) = 59.5
\ body_radius * wheel_radius * pi = _right_cal
\ 59.75 * 36.5 * pi = 6851  
\ practical body radius (wheel base/2) = 58.865 
\ 6750 wconstant _right_cal \ for 4x6 foam chassic (with acrilic wheels)

\ 253 wconstant _distance_cal  \ braino's 3d printed wheels 82 * pi = 257.8
\ 253 - 600 mm goes 7 long
255 wconstant _distance_cal  \ braino's 3d printed wheels 82 * pi = 257.8
\ 255 - 600 mm goes perfect
\ 257 wconstant _distance_cal  \ braino's 3d printed wheels 82 * pi = 257.8
\ 257 - 600 mm goes 7 short
\258 wconstant _distance_cal  \ braino's 3d printed wheels 82 * pi = 257.8
\ 258 - 600 mm goes 4 short
\ 260 wconstant _distance_cal  \ braino's 3d printed wheels 82 * pi = 257.8
\ 260 - 600 mm goes 15 short

\  The 6x8 inch wide pink foam blocks with wheels are 165 mm wide so
\ The body radius (wheel base/2) = 82.5
\ body_radius * wheel_radius * pi = _right_cal
\ 82.5 * 82.0 * pi = 21252
\ 8480 wconstant _right_cal \ for 6x8 foam chassic (w/ 3D printer wheels) 

\ Ancona uses acrylic wheels and 6x8 foam 

229 wconstant _distance_cal  \ laser cut acrylic 20130601 73 * pi = 229.33
8480 wconstant _right_cal \ for 6x8 foam chassic (w/ 3D printer wheels) 


{
\ debug *********************************************************************
wvariable right_cal 
: !right_cal right_cal W! ; : @right_cal right_cal W@ ;
21252 !right_cal 
: _right_cal @right_cal ;
: !rc  cr ." 6851 6822 6836 " cr  
  @right_cal . dup !right_cal ." RC to " . ;    
\ debug *********************************************************************
}

c" BOT " prop W@ ccopy
1 propid W!
]

[ifdef build_bot2
\ for the HC05        -- bot 2  -- bot 2  -- bot 2  -- bot 2  -- bot 2 
\ green wire
	22 wconstant hcProgPin
\ white/orange wire
	26 wconstant hcRx
\ white/green wire
	27 wconstant hcTx

24 wconstant _sr04_trig
25 wconstant _sr04_echo

23 wconstant _ready_led

: _mota_pins d_15 d_14 d_13 d_12 ;
: _motb_pins d_11 d_10 d_9 d_8 ;

\ 263 wconstant _distance_cal
\ 254 wconstant _distance_cal  \ laser cut acrylic 20130601 81 * pi
229 wconstant _distance_cal  \ laser cut acrylic 20130601 73 * pi

\ 6052 wconstant _right_cal
\ 6880 wconstant _right_cal
\ 6851 wconstant _right_cal \ for 4x6 foam chassic        no
6822 wconstant _right_cal \ for 4x6 foam chassic        

c" BOT " prop W@ ccopy
2 propid W!
]

fsload 4step.f
fsload sr04.f

_mota_pins	step_create_halfstep motha
_motb_pins	step_create_halfstep mothb


: init_motorA
c" MOTOR A" cds W! motha step_init 0 motha step_accel 900 motha step_setspeed
;

: init_motorB
c" MOTOR B" cds W! mothb step_init 0 mothb step_accel 900 mothb step_setspeed

;

: forwarda
motha step motha step_sleep
;

: forwardb
mothb step  mothb step_sleep
;

: reversea
negate motha step  motha step_sleep
;

: reverseb
negate mothb step  mothb step_sleep
;


: forward
4096 _distance_cal */ <# #s #> dup 0 cogx 1 cogx
c"  forwarda" 0 cogx
c"  reverseb" 1 cogx
;

: reverse
negate forward
;

: right
_right_cal 3600 */
<# #s #> dup 0 cogx 1 cogx
c"  reversea" 0 cogx
c"  reverseb" 1 cogx
;

: left
negate right
;


: d
_sr04_distance L@ . cr
;

: cal
_sr04_distance L@
c" 4096 forwarda" 0 cogx
c" 4096 reverseb" 1 cogx

c"  " 0 cogx
c"  " 1 cogx
_sr04_distance L@

c" 4096 reversea" 0 cogx
c" 4096 forwardb" 1 cogx

c"  " 0 cogx
c"  " 1 cogx
_sr04_distance L@

rot + 2/ swap - .
;

\ braino debug 20130610


: esc h_1B emit ;
: csi esc h_5B emit ;
: m ." m" ;    
: smallf ." f" ; 
: K ." K" ;
: semicolon ." ;" ;

\ v>c convert a value ( 0-9 ) for a digit character for emit 
: v>c h_30 + emit ;
\ .digits ( n -  ." emit as DECIMAL characters" ) for AT  convert 0-99 for emit
: .digits 
          dup h_9 > if h_0A u/mod v>c then \ greater than 9 mod decimal 10
          v>c ;
\ AT  ( x y - ) put cursor at x,y
: AT csi .digits semicolon .digits smallf ;

: home       csi ." 1;1f" ;
: clear      csi ." 2J" ; 
: preclear   csi ." 1J" ;
: postclear  csi ." 0J" ;
: cls home clear  ;

: dd _sr04_distance L@ . ; 

:  sr04 cls ." sr04 test " 

0 10 AT ." SR04 mm= ...." 

 begin 10 10 AT dd ."    " 1 delms fkey? swap drop until ; 

\ braino debug 20130610


: onreset6
cr ." INITALIZING motors and sensor (cogs 0, 1, 2) in 1 second...." cr 1000 delms

fkey? and fkey? and or h1B <>
if
c" init_motorA" 0 cogx
c" init_motorB" 1 cogx
c" _sr04_measure" 2 cogx
 ."  motors and sensors initialized ... " cr cr
cog? 
then

cr ." Switch to Bluetoot HC05  in 5 seconds...."  cr 5000 delms


fkey? and fkey? and or h1B <>
if
$S_con iodis $S_con cogreset 100 delms
c" _ready_led dup pinout pinhi" $S_con cogx
c" hcRx hcTx 57600 serial" $S_con cogx 100 delms
cogid >con

."  Bluetooth initialized "   cr cr
cog? 
then


cr ." RESETING on cog6 now ....  "  cr  

c" onreset6" (forget)
;


...



fswrite btstat.f


230400 4/ wconstant hcBaud

0 wconstant hcSerialCog

hcSerialCog cogreset 100 delms
c" hcRx hcTx hcBaud serial" hcSerialCog cogx 100 delms
1 hcSerialCog sersetflags


: hcSend
	cogid hcSerialCog iolink .cstr 1000 delms cogid iounlink cr
;

hcProgPin pinhi hcProgPin pinout

c" AT+VERSION~h0D~h0A" hcSend
c" AT+ROLE?~h0D~h0A" hcSend
c" AT+UART?~h0D~h0A" hcSend
c" AT+NAME?~h0D~h0A" hcSend
c" AT+PSWD?~h0D~h0A" hcSend

hcProgPin pinlo 

...

fswrite btinit.f

hcProgPin pinhi hcProgPin pinout

c" AT+NAME=BrainoBOT-4x6~h0D~h0A" hcSend
c" AT+PSWD=1234~h0D~h0A" hcSend
c" AT+UART=230400,0,0~h0D~h0A" hcSend
c" AT+VERSION~h0D~h0A" hcSend
c" AT+ROLE?~h0D~h0A" hcSend
c" AT+UART?~h0D~h0A" hcSend
c" AT+NAME?~h0D~h0A" hcSend
c" AT+PSWD?~h0D~h0A" hcSend

hcProgPin pinlo 

\ after the hc05 is power cycled, the baud rate will change, not like the hc06

...
{
\ fl

: dw
-1 _sr04_distance L! begin _sr04_distance L@ -1 <> until
_sr04_distance L@ . cr

;

: ci
	0 3600 right h0D 0 cogio W!
	begin
		dup . dw 1+
		0 cogio W@ h0D <>
	until
	drop

;



: cil
	0 3600 left h0D 0 cogio W!
	begin
		dup . dw 1+
		0 cogio W@ h0D <>
	until
	drop

;


: CIR
	dw 30 0 do
		120 right h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
		i . dw
	loop
;

: CIL
	dw 30 0 do
		120 left h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
		i . dw
	loop
;

: tl
	dw 30 0 do
		120 left h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
	loop
;
	
: tr
	dw 30 0 do
		120 right h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
	loop
;

}

fl

wvariable _mon 0 _mon W!
wvariable _monoff
variable _monstate

fl
: stepmon
	4 state andnC!
	c" STEPMON" cds W!
	_mon W@ 0=
	if
		lockdict here W@ _mon W! d8192 allot freedict
	then
	_mon W@ d8192 0 fill

	0 _monoff W!
	
	ina COG@ h_0FF0_0000 and _monstate L!
	begin
		ina COG@ h_0FF0_0000 and dup _monstate L@ <>

		if
			_monstate W@ cnt COG@ over _mon W@ + L!
			4+ h1FFF and _monstate W!
		else
			drop
		then		
	0 until
;

: _dmon1
	base W@ swap hex
	1 max 2047 min dup .word h3A dup emit emit space
	4* _mon W@ + dup L@ swap 4- L@ dup .long h3A emit space
	- dup .long space
	swap base W!
	d1000000 clkfreq u*/mod swap clkfreq 2/ > if 1+ then dup .long space .
;

: dmon
	d2048 1
	do
		i _dmon1 cr
	loop
;

: dmo
	d128 1
	do
		i _dmon1 cr
	loop                                                                                                                    
;



: dm
	d32 1
	do
		i _dmon1 cr
	loop
;

: m 3 cogreset 100 delms c" stepmon" 3 cogx ;



}}}

== bot-fixed.f ==

Adds ability to esape out of autoboot behavior. Hadly for testing when connected to PC, rather than rely on blue tooth and batteries.

For the Quickstart:  Uses Quickstart LEDS to display the SR04 distance estimate.  This won't work on Bot1 pin out, it only works on the BOT2 pinout. 

{{{
fl

fswrite 4step.f
{

Drives a 4 phase stepper motor, tested with 28byj stepper motor wth a uln2003 driver

Create a structure, either a halfstep, or full step, specify the pins, 16 17 18 & 19 in this case


\ For half stepping
     16 17 18 19 step_create_halfstep moth


\ Initialize
     moth step_init

\ Step forward
     4096 moth step

\ Step reverse
     -4096 moth step

\ Turn off drivers
     moth step_sleep

\ Turn on drivers
     moth step_active

\ Set the step speed - setting too fast a speed will cause it to skip steps (1100 for test motor)
     1100 moth step_setspeed

\ or
\ For full stepping
     16 17 18 19 step_create_fullstep motf


\ Initialize
     motf step_init

\ Step forward
     2048 motf step

\ Step reverse
     -2048 motf step

\ Turn off drivers
     motf step_sleep

\ Turn on drivers
     motf step_active

\ Set the step speed - setting too fast a speed will cause it to skip steps (550 for test motor)
     550 motf step_setspeed



step structure
00 - 04 -- current step position - steps
04 - 08 -- current step velocity - steps / sec
08 - 0C -- max step velocity - steps / sec (should be a multiple of step acceleration)
0C - 10 -- step acceleration - steps / sec / sec (min 2)
10 - 14 -- step mask
14 - 34 -- 8 longs - step values
34 - 38 -- steps to speed
38 - 39 -- step position mask
}


\ 1 wconstant step_debug

h0  wconstant _step_position
h4  wconstant _step_current_velocity
h8  wconstant _step_max_velocity
hC  wconstant _step_accel
h10 wconstant _step_mask
h14 wconstant _step_bits
h34 wconstant _steps_to_speed
h38 wconstant _step_position_mask
h39 wconstant _step_size

[ifdef step_debug
\ step_dump ( addr -- )
: step_dump
	." current_position: " dup L@ . cr
	." current_velocity: " dup _step_current_velocity + L@ . cr
	."     max_velocity: " dup _step_max_velocity + L@ . cr
	."            accel: " dup _step_accel + L@ . cr
	."   steps to speed: " dup _steps_to_speed + L@ . cr
	."    position_mask: " dup _step_position_mask + C@ . cr
	base W@ swap hex
	."             mask: " dup _step_mask + L@ .long cr
	."             bits: "
	_step_bits + h20 bounds
	do
		i L@ .long space
	4 +loop
	base W!
	cr
;

\ step_dump1 ( addr -- )
: step_dump1
	." current_position: " dup L@ . 
	." current_velocity: " dup _step_current_velocity + L@ .
	."     max_velocity: " dup _step_max_velocity + L@ .
	."            accel: " _step_accel + L@ .
;
]

\ step_sleep ( addr -- )
: step_sleep
	_step_mask + L@ outa COG@ swap andn outa COG! 
;

\ step_active( addr -- )
: step_active
	dup _step_position + L@ over _step_position_mask + C@
	and 4* over + _step_bits + L@
	swap _step_mask + L@
	outa COG@ swap andn or outa COG!
;


\ step_init ( addr -- )
: step_init
 	dup _step_mask + L@ dira COG@ or dira COG!
	step_sleep	 
;

: _step_create1
	lockdict variable _step_size allot lastnfa nfa>pfa 2+ alignl freedict
	dup _step_size 0 fill
	4 ST@ >m 4 ST! 3 ST@ >m 3 ST! 2 ST@ >m  2 ST! 1 ST@ >m 1 ST!
;

: _step_create2
	rot2 or rot or rot or over _step_mask + L!
;

: _step_create3
	_step_bits + + L!
;

\ create a step structure

\ step_create_halfstep name ( n1 n2 n3 n4 -- )
: step_create_halfstep
	_step_create1
\ pin 1
	4 ST@ over 0 _step_create3
\ pin 1 2
	4 ST@ 4 ST@ or over 4 _step_create3
\ pin 2
	3 ST@ over 8 _step_create3
\ pin 2 3
	3 ST@ 3 ST@ or over hC _step_create3
\ pin 3
	2 ST@ over h10 _step_create3
\ pin 3 4 
	2 ST@ 2 ST@ or over h14 _step_create3
\ pin 4
	1 ST@ over h18 _step_create3
\ pin 4 1
	1 ST@ 5 ST@ or over h1C _step_create3

	_step_create2

	d_700 over _step_max_velocity + L!
	d_10  over _step_accel + L!
	d_70  over _steps_to_speed + L!

	_step_position_mask + 7 swap C!
;


\ step_create_fullstep name ( n1 n2 n3 n4 -- )
: step_create_fullstep
	_step_create1
\ pin 1 2
	4 ST@ 4 ST@ or over 0 _step_create3
\ pin 2 3
	3 ST@ 3 ST@ or over 4 _step_create3
\ pin 3 4 
	2 ST@ 2 ST@ or over 8 _step_create3
\ pin 4 1
	1 ST@ 5 ST@ or over h10 _step_create3

	_step_create2

	d_500 over _step_max_velocity + L!
	d_10  over _step_accel + L!
	d_50  over _steps_to_speed + L!
	_step_position_mask + 3 swap C!
;

\ _step_time( addr -- ticks)
: _step_time
	dup _step_current_velocity + L@ dup
\ addr cv cv
	2 ST@ _step_accel + L@ +
\ cv nv
	rot _step_max_velocity + L@ min
\ cv nv
	over - 2/ +
\ av
	clkfreq swap u/
;


\ __step ( +-1 addr xx -- +-1 addr xx )
: __step
	over _step_position + dup L@ 4 ST@ + swap L!
	over dup _step_current_velocity + L@ over _step_accel + L@ +
	over _step_max_velocity + L@ min swap _step_current_velocity + L!
	over step_active
;


[ifdef step_debug
: waitcnt
	over . dup . + cr
;
]

\ step ( n addr -- )
: step
	over 0<
	if
		-1
	else
		over 0>
		if
			1
		else
			0
		then
	then
\ n addr step
	dup 0<>
	if 	
		swap rot abs
\ +-1 addr n

		over _steps_to_speed + L@ 2* over <=
		if
			over _steps_to_speed + L@ dup >r tuck  2* - >r
		else
			dup 1 =
			if
				0 >r 0 >r
			else
				dup 2/ dup >r
				swap 1 and >r
			then
			
		then
[ifdef step_debug
		st? rs?
]
		over _step_time
[ifndef step_debug
		cnt COG@ +
]
		swap		

		0
		do
[ifdef step_debug
			i .long space
			over step_dump1
]
\ +-1 addr cnt
			__step
			over _step_time
			waitcnt
		loop

		r> dup 0=
		if
			drop
		else
			2 ST@ _step_accel + dup L@ >r 0 swap L!
			0
			do
[ifdef step_debug
				i .long space
				over step_dump1
]
\ +-1 addr cnt
				__step
				over _step_time
				waitcnt
			loop
			over _step_accel + r> swap L!
		then





		r> dup 0=
		if
			drop
		else
			2 ST@ _step_accel + dup L@ negate swap L!
			0
			do
[ifdef step_debug
				i .long space
				over step_dump1
]
\ +-1 addr cnt
				__step
				over _step_time
				waitcnt
			loop
			over _step_accel + dup L@ negate swap L!
		then

	then
	drop 0 swap _step_current_velocity + L! drop
; 

: step_accel
;

: step_setspeed
;

[ifdef step_test
d_16 d_17 d_18 d_19 step_create_halfstep moth
d_16 d_17 d_18 d_19 step_create_fullstep motf


\ _tstep ( steps addr -- )
: _tstep
	cnt COG@ >r
	2dup step
	cnt COG@ r> -
\ steps addr ticks
	2 ST@ abs
	u/
	d_1000_000 clkfreq u*/
\ steps addr usec/step
	." step:: steps: " rot .
\ addr usec/step
	over 5 + C@ 3 = if ." fullstep " then
	over 5 + C@ 7 = if ." halfstep " then
	over 6 + C@ ." accel: " .
	." usec/step: " dup .
	." steps/sec: " d_1_000_000 swap u/ . cr
	step_sleep
;

\ _step_test ( addr -- )
: _step_test
	dup step_init
	
	." Hit a key to terminate tests~h0D~h0D"

	fkey? nip 0=
	if
		d_12 0
		do
			i over step_accel
			fkey? nip 0=
			if
				d_8192 over _tstep d_1000 delms
				fkey? nip 0=
				if
					d-8192 over _tstep d_1000 delms
				else
					leave
				then
			else
				leave
			then
		loop
	then
	drop
;

: step_testh
	moth _step_test
;

: step_testf
	motf _step_test
;
]
 
...




fswrite sr04.f

1 wconstant build_sr04
[ifndef _sr04_trig
16 wconstant _sr04_trig
]
[ifndef _sr04_echo
17 wconstant _sr04_echo
]

variable _sr04_distance


: _sr04_measure
c" MEASURE" cds W!
4 state andnC!

_sr04_trig pinlo _sr04_trig pinout
_sr04_echo >m
_sr04_trig >m
begin
dup _maskouthi dup dup dup dup drop drop drop _maskoutlo

over dup dup dup

waitpeq
cnt COG@
rot2

waitpne
cnt COG@ swap -
d_170_000 clkfreq */


_sr04_distance L!
d_60 delms
0 until
;


: sr04_display
c" LED" cds W!
4 state andnC!

  7 0 do i 17 + pinout  loop

	begin
		_sr04_distance L@ 
\ 16 is sr04 echo 
    dup 50 125 between if 17 pinhi else 17 pinlo then 
    dup 125 250 between if 18 pinhi else 18 pinlo then 
    dup 250 500 between if 19 pinhi else 19 pinlo then 
    dup 500 1000 between if 20 pinhi else 20 pinlo then 
    dup 1000 2000 between if 21 pinhi else 21 pinlo then 
    dup 2000 4000 between if 22 pinhi else 22 pinlo then 
     4000 >  if 23 pinhi else 23 pinlo then 
    
		fkey? nip
\    80 delms
	until
;



...

fswrite boot.f

hA state orC! version W@ .cstr cr cr cr
: findEETOP
0
h100000 h8000
do
i t0 2 eereadpage
if
leave
else
i h7FFE + t0 3 eereadpage
if
leave
else
drop i h8000 +
then
then
h8000 +loop
;

c" boot.f - Finding top of eeprom, " .cstr findEETOP ' fstop 2+ alignl L! forget findEETOP c" Top of eeprom at: " .cstr fstop . cr
c" boot.f - Loading bot.f~h0D~h0D" .cstr hA state andnC!
fsload bot.f
c" boot.f - Loaded bot.f~h0D~h0D" .cstr hA state andnC!
c" boot.f - DONE PropForth Loaded~h0D~h0D" .cstr hA state andnC!
...


fswrite bot.f


2 px? 27 px? 0= and
[if
	1 wconstant build_bot1
]

27 px? 2 px? 0= and
[if
	1 wconstant build_bot2
]

[ifdef build_bot1
\ for the HC05

1 wconstant hcProgPin
0 wconstant hcRx
2 wconstant hcTx

16 wconstant _sr04_trig
17 wconstant _sr04_echo

3 wconstant _ready_led

: _mota_pins d_24 d_25 d_26 d_27 ;
: _motb_pins d_20 d_21 d_22 d_23 ;

263 wconstant _distance_cal
6052 wconstant _right_cal
c" BOT " prop W@ ccopy
1 propid W!
]

[ifdef build_bot2
\ for the HC05
\ green wire
	22 wconstant hcProgPin
\ white/orange wire
	26 wconstant hcRx
\ white/green wire
	27 wconstant hcTx

24 wconstant _sr04_trig
25 wconstant _sr04_echo

23 wconstant _ready_led

: _mota_pins d_15 d_14 d_13 d_12 ;
: _motb_pins d_11 d_10 d_9 d_8 ;

263 wconstant _distance_cal
6052 wconstant _right_cal
c" BOT " prop W@ ccopy
2 propid W!
]

fsload 4step.f
fsload sr04.f

_mota_pins	step_create_halfstep motha
_motb_pins	step_create_halfstep mothb


: init_motorA
c" MOTOR A" cds W! motha step_init 0 motha step_accel 900 motha step_setspeed
;

: init_motorB
c" MOTOR B" cds W! mothb step_init 0 mothb step_accel 900 mothb step_setspeed

;

: forwarda
motha step motha step_sleep
;

: forwardb
mothb step  mothb step_sleep
;

: reversea
negate motha step  motha step_sleep
;

: reverseb
negate mothb step  mothb step_sleep
;


: forward
4096 _distance_cal */ <# #s #> dup 0 cogx 1 cogx
c"  forwarda" 0 cogx
c"  reverseb" 1 cogx
;

: reverse
negate forward
;

: right
_right_cal 3600 */
<# #s #> dup 0 cogx 1 cogx
c"  reversea" 0 cogx
c"  reverseb" 1 cogx
;

: left
negate right
;


: d
_sr04_distance L@ . cr
;

: cal
_sr04_distance L@
c" 4096 forwarda" 0 cogx
c" 4096 reverseb" 1 cogx

c"  " 0 cogx
c"  " 1 cogx
_sr04_distance L@

c" 4096 reversea" 0 cogx
c" 4096 forwardb" 1 cogx

c"  " 0 cogx
c"  " 1 cogx
_sr04_distance L@

rot + 2/ swap - .
;

: h ." f=forward b=reverse l=left r=right "
    ."  sr04_test sr04_display " cr ;

: f forward ;
: b reverse ;
: l left ;
: r right ;


: onreset6
fkey? and fkey? and or h1B <>
if
$S_con iodis $S_con cogreset 100 delms
c" _ready_led dup pinout pinhi" $S_con cogx
c" hcRx hcTx 57600 serial" $S_con cogx 100 delms
cogid >con
c" init_motorA" 0 cogx
c" init_motorB" 1 cogx
c" _sr04_measure" 2 cogx
c" sr04_display" 3 cogx
then
c" onreset6" (forget)
;


...



fswrite btstat.f


230400 4/ wconstant hcBaud

0 wconstant hcSerialCog

hcSerialCog cogreset 100 delms
c" hcRx hcTx hcBaud serial" hcSerialCog cogx 100 delms
1 hcSerialCog sersetflags


: hcSend
	cogid hcSerialCog iolink .cstr 1000 delms cogid iounlink cr
;

hcProgPin pinhi hcProgPin pinout

c" AT+VERSION~h0D~h0A" hcSend
c" AT+ROLE?~h0D~h0A" hcSend
c" AT+UART?~h0D~h0A" hcSend
c" AT+NAME?~h0D~h0A" hcSend
c" AT+PSWD?~h0D~h0A" hcSend

hcProgPin pinlo 

...

fswrite btinit.f

hcProgPin pinhi hcProgPin pinout

c" AT+NAME=ANCONABOT-20130521~h0D~h0A" hcSend
c" AT+PSWD=1111~h0D~h0A" hcSend
c" AT+UART=230400,0,0~h0D~h0A" hcSend
c" AT+VERSION~h0D~h0A" hcSend
c" AT+ROLE?~h0D~h0A" hcSend
c" AT+UART?~h0D~h0A" hcSend
c" AT+NAME?~h0D~h0A" hcSend
c" AT+PSWD?~h0D~h0A" hcSend

hcProgPin pinlo 

\ after the hc05 is power cycled, the baud rate will change, not like the hc06

...
{
\ fl

: dw
-1 _sr04_distance L! begin _sr04_distance L@ -1 <> until
_sr04_distance L@ . cr

;

: ci
	0 3600 right h0D 0 cogio W!
	begin
		dup . dw 1+
		0 cogio W@ h0D <>
	until
	drop

;



: cil
	0 3600 left h0D 0 cogio W!
	begin
		dup . dw 1+
		0 cogio W@ h0D <>
	until
	drop

;


: CIR
	dw 30 0 do
		120 right h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
		i . dw
	loop
;

: CIL
	dw 30 0 do
		120 left h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
		i . dw
	loop
;

: tl
	dw 30 0 do
		120 left h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
	loop
;
	
: tr
	dw 30 0 do
		120 right h0D 0 cogio W!
		begin
			0 cogio W@ h0D <>
		until
	loop
;

}

fl

wvariable _mon 0 _mon W!
wvariable _monoff
variable _monstate

fl
: stepmon
	4 state andnC!
	c" STEPMON" cds W!
	_mon W@ 0=
	if
		lockdict here W@ _mon W! d8192 allot freedict
	then
	_mon W@ d8192 0 fill

	0 _monoff W!
	
	ina COG@ h_0FF0_0000 and _monstate L!
	begin
		ina COG@ h_0FF0_0000 and dup _monstate L@ <>

		if
			_monstate W@ cnt COG@ over _mon W@ + L!
			4+ h1FFF and _monstate W!
		else
			drop
		then		
	0 until
;

: _dmon1
	base W@ swap hex
	1 max 2047 min dup .word h3A dup emit emit space
	4* _mon W@ + dup L@ swap 4- L@ dup .long h3A emit space
	- dup .long space
	swap base W!
	d1000000 clkfreq u*/mod swap clkfreq 2/ > if 1+ then dup .long space .
;

: dmon
	d2048 1
	do
		i _dmon1 cr
	loop
;

: dmo
	d128 1
	do
		i _dmon1 cr
	loop
;

: dm
	d32 1
	do
		i _dmon1 cr
	loop
;

: m 3 cogreset 100 delms c" stepmon" 3 cogx ;


{
init_motorB
12345 forwardb

500 delms

12345 reverseb

st? 
sc

\ fsclear to coear filesystem
\ HC key to P27
\ HC Tx to P26
\ HC Rx to P25

}


}}}

= AUTOBOOT =

When the Quickstat boots the propforth EEprom Kernel, Propforth runs the boot.f if it is present.  This automagically configures and starts the bot. 

If you DON'T want the autoboot to run *hold down* the *ESC* key. 

NOTE: HOLD DOWN THE ESC key to stop the autoboot!!!

= EEpom file system commands =

Propforth writes files to the EEprom chip on the Quickstart, and uses it like a mini disk drive. 

If you want to see the list of files on the EEprom, type File System List command
{{{
fsls
}}}

If you want to clear the files (remove then so you can put the riht one in ) type

{{{
fsclear

}}}

To get rid of the LAST file type

{{{ 
fsdrop 

}}}

To display the contents of file boot.f on the screen type, this will work with any file name in the list

{{{
fsread boot.f
}}}

To make a new file type fswrite filename.  There are examples of this in the bot.f code above. fswrite ends with the three periods

{{{

fswrite myfilename

<your stuff goes here>

...

}}}




= end of demo program page =