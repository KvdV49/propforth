#summary Logger1Simple with SR04
#labels v5.5,SR04,Logger

<wiki:toc max_depth="9" />


= Introduction =

This demo adds SR04 to Logger1Simple
-----
= Step 1 - SD kernel  =

== Make the SD slot ==

I used the Spinneret standard pinout from http://code.google.com/p/propforth/wiki/SDsetupREVISITED#Spineret_%28standard%29_Pinout

Solder wires to the SD adapter.  

Connect it up per the instructions.

Put the new card in the slot.

== Load the kernel ==

From the PropForth download archive, location the SD kernel directory in the current release. 

`\My Documents\PropforthV5.5\CurrentRelease\PropForthSD`

Load the SD kernel `SDkernel.spin` using the proptool, as per normal.  

NOTE: the card will give you some error messages until you initiale it in the next step.  This is normal. 

== initialize the SD card ==

From the PropForth download archive, location the SD kernel directory in the current release. 

`\My Documents\PropforthV5.5\CurrentRelease\PropForthSD`

Load the SD initialization script sdfsInitScript.f

Simply paste this into the termianl emulator, and it does the work.  

-----

= Step 2 - Logger 1 Simple = 

Load simple logger package found in 

http://code.google.com/p/propforth/downloads/detail?name=Logger-2013-05-12.zip

on the downloads section according to the instructions on the 

Logger1Simple  page.

NOTE: By default, logger 1 simple uses 
  * cog 0 for TIME COUNTER
  * cog 3 for LOGGER

== Double Math f ==

DoubleMath.f is the same as the default Logger1Simple download.

Paste this into the terminal emulator program first.

Use mountusr,  ls, and fread DounbleMath.f to veify the source file is in SD.
{{{
mountusr
ls
fread DoubleMath.f
}}}

DoubleMath is included here for reference. You should download the archive and open the file in a text editor.  You should copy and paste from the text editor, as doing so from this browser window can cause undefined results. 

{{{
fl

mountsys

100 fwrite DoubleMath.f

1 wconstant build_DoubleMath
\
[ifndef dum*
lockdict create dum* forthentry
$C_a_lxasm w, h137  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2Wi]ZB l, z1SyLI[ l, z2Wi]RB l, z1SyLI[ l, z2Wy]b0 l, z2Wy]j0 l, z1SyLIZ l, z2WyPb0 l,
z2WyPj0 l, z2WyPr0 l, z2WyQ00 l, zeyPW1 l, zkyPO1 l, z26QPO0 l, z1SJ04] l, z21iPfm l,
z39iPnn l, z39iPvo l, z38iQ4p l, zgy]O1 l, zoy]W1 l, zoy]b1 l, zny]j1 l, z1SL04U l,
z2WiPRD l, z1SyJQL l, z2WiPRE l, z1SyJQL l, z2WiPRF l, z1SyJQL l, z2WiPRG l, z1SV01X l,
0 l, 0 l, 0 l, 0 l,
freedict
]

[ifndef dum/mod
lockdict create dum/mod forthentry
$C_a_lxasm w, h13E  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPuB l, z1SyLI[ l, z2WiaBB l, z1SyLI[ l, z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l,
z1SyLIZ l, z2WyQA0 l, z2WyaG0 l, z2WyaO0 l, zgyPO1 l, zoyPW1 l, zoyPb1 l, zoyPj1 l,
zoyaG1 l, zoyaO1 l, z1SS04d l, z27FaKs l, z3DFaRF l, z2WvQ00 l, z1SS04g l, z27iaKs l,
z3CiaRF l, z2WyQ01 l, zkyQ01 l, zoyaW1 l, znyab1 l, z3[yQCV l, z2WiPSt l, z1SyJQL l,
z2WiPSu l, z1SyJQL l, z2WiPSv l, z1SyJQL l, z2WiPSw l, z1SV01X l, 0 l, 0 l,
0 l, 0 l, 0 l,
freedict
]

[ifndef d+
lockdict create d+ forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z21iPRD l, z3OiPZE l, z1SyJQL l,
z2WiPRC l, z1SV01X l,
freedict
]

[ifndef d-
lockdict create d- forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z27iPRD l, z3SiPZE l, z1SyJQL l,
z2WiPRC l, z1SV01X l,
freedict
]

[ifndef du>
lockdict create du> forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z27FPRD l, z3FFPZE l, z2WyPO0 l,
z2WXPR6 l, z1SV01X l,
freedict
]

[ifndef du<
lockdict create du< forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z27FPRD l, z3FFPZE l, z2WyPO0 l,
z2WfPR6 l, z1SV01X l,
freedict
]

[ifndef d=
lockdict create d= forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z27FPRD l, z3FFPZE l, z2WyPO0 l,
z2WdPR6 l, z1SV01X l,
freedict
]

[ifndef du>=
lockdict create du>= forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z27FPRD l, z3FFPZE l, z2WyPO0 l,
z2WZPR6 l, z1SV01X l,
freedict
]

[ifndef du<=
lockdict create du<= forthentry
$C_a_lxasm w, h11D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPmB l, z1SyLI[ l, z2WiPeB l, z1SyLI[ l, z1SyLIZ l, z27FPRD l, z3FFPZE l, z2WyPO0 l,
z2WhPR6 l, z1SV01X l,
freedict
]

\ du* ( u1lo u1hi u2lo u2hi -- u1*u2lo u1*u2hi ) u1 multiplied by u2
[ifndef du*
: du*
	dum* 2drop
;
]

\ du/mod ( u1lo u1hi u2lo u2hi -- remainderlo remainderhi quotientlo quotienthi) \ unsigned divide & mod  u1 divided by u2
[ifndef du/mod
: du/mod
	0 rot2 0 rot2 dum/mod
;
]

\
\
\ du/ ( u1lo u1hi u2lo u2hi -- u1/u2lo u1/u2hi) u1 divided by u2
[ifndef du/
: du/
	du/mod rot drop rot drop
;
]

\ du*/mod ( u1lo u1hi u2lo u2hi u3lo u3hi -- u4lo u4hi u5lo u5hi ) u5 = (u1*u2)/u3, u4 is the remainder.
\         Uses a 128bit intermediate result.
[ifndef du*/mod
: du*/mod
	>r >r dum* r> r> dum/mod
;
]

\
\ du*/ ( u1lo u1hi u2lo u2hi u3lo u3hi -- u4lo u4hi ) u4 = (u1*u2)/u3. Uses a 128bit intermediate result.
[ifndef du*/
: du*/
	>r >r dum* r> r> dum/mod rot drop rot drop
;
]


\ dswap ( n1lo n1hi n2lo n2hi -- n2lo n2hi n1lo n1hi) 
[ifndef dswap
: dswap
	 0 ST@ 3 ST@ 1 ST! 2 ST!
	 1 ST@ 4 ST@ 2 ST! 3 ST!
;

\ drot ( n1lo n1hi n2lo n2hi n3lo n3hi -- n2lo n2hi n3lo n3hi  n1lo n1hi) 
[ifndef drot
: drot 
	 0 ST@ 3 ST@ 6 ST@ 2 ST! 5 ST! 2 ST!
	 1 ST@ 4 ST@ 7 ST@ 3 ST! 6 ST! 3 ST!
;
]
]
\ ddup ( n1lo n1hi --	n1lo n1hi n1lo n1hi)
[ifndef ddup
: ddup
	2dup
;
]
\ ddrop ( n1lo n1hi --	)
[ifndef ddrop
: ddrop
	2drop
;
]
\ dnip ( n1lo n1hi n2lo n2hi -- n2lo n2hi)
[ifndef dnip
: dnip
	rot drop
	rot drop
;
]
\ dover ( n1lo n1hi n2lo n2hi -- n1lo n1hi n2lo n2hi n1lo n1hi)
[ifndef dover
: dover
	3 ST@ 3 ST@
;
]

\ dtuck ( n1lo n1hi n2lo n2hi -- n2lo n2hi n1lo n1hi n2lo n2hi)
[ifndef dtuck
: dtuck
	dswap dover
;
]


\ d2dup ( n1lo nihi n2lo n2hi -- n1lo n1hi n2lo n2hi n1lo nihi n2lo n2hi)
[ifndef d2dup
: d2dup
	dover dover
;
]


\ dnegate( n1lo n1hi -- u1lo u1hi)
[ifndef dnegate
: dnegate
	0 0 dswap d-
;
]
\ dabs( n1lo n1hi -- u1lo u1hi)
[ifndef dabs
: dabs
	dup 0<
	if
		dnegate
	then
;
]

\ d* ( n1lo n1hi n2lo n2hi -- n1*n2lo n1*n2hi ) u1 multiplied by u2
[ifndef d*
: d*
	du*
;
]

\ d*/mod ( n1lo n1hi n2lo n2hi n3lo n3hi -- n4lo n4hi n5lo n5hi ) n5 = (n1*n2)/n3, n4 is the remainder.
\         Uses a 128bit intermediate result.
[ifndef d*/mod
: d*/mod
	dup 3 ST@ sign 5 ST@ sign
	>r
	dabs
	>r >r
	dabs dswap dabs
	dum*
	r> r>
	dum/mod
	r>
	if
		dnegate dswap dnegate dswap
	then
;
]

\ d*/ ( n1lo n1hi n2lo n2hi n3lo n3hi -- n5lo n5hi ) n5 = (n1*n2)/n3
\         Uses a 128bit intermediate result.
[ifndef d*/
: d*/
	d*/mod dnip
;
]
\ d/mod ( n1lo n1hi n2lo n2hi -- n4lo n4hi n5lo n5hi ) n5 = (n1/n2), n4 is the remainder.
[ifndef d/mod
: d/mod
	dup 3 ST@ sign
	>r
	dabs dswap dabs dswap
	du/mod
	r>
	if
		dnegate dswap dnegate dswap
	then
;
]

\ d/ ( n1lo n1hi n2lo n2hi -- n5lo n5hi ) n5 = (n1/n2)
[ifndef d/
: d/
	d/mod dnip
;
]

\
\
\ d# ( n1lo n1hi -- n2lo n2hi ) divide n1 by base and convert the remainder to a char and append to the output
[ifndef d#
: d#
	base W@ 0 du/mod rot drop rot tochar -1 >out W+! pad>out C!
;
]

\
\
\ d#s ( n1lo n1hi -- 0 ) execute # until the remainder is 0
[ifndef d#s
: d#s
	begin
		d# 2dup 0= swap 0= and
	until
	drop
;
]

\
\ du. ( n1lo n1hi -- ) prints the unsigned number on the top of the stack
[ifndef du.
: du.
	<# d#s #> .cstr space
;
]
\
\ d. ( n1lo n1hi -- ) prints the signed number on the top of the stack
[ifndef d.
: d.
	dup 0<
	if
		h2D emit dabs
	then
	du.
;
]

\
\ dL! ( nlo nhi addr -- )
[ifndef dL!
: dL!
	tuck 4+ L! L!
;
]
\
\ dL@ ( addr -- nlo nhi)
[ifndef dL@
: dL@
	dup L@ swap 4+ L@
;
]
\ d>u ( u1lo u1hi -- u1lo )
[ifndef d>u
: d>u
	drop
;
]
\ u>d ( u1lo -- u1lo u1hi )
[ifndef u>d
: u>d
	0
;
]
\ i>d ( d1lo -- d1lo d1hi )
[ifndef i>d
: i>d
	dup 0<
	if
		-1
	else
		0
	then
;
]

{

fl


\
\
\ dum* ( u1lo u1hi u2lo u2hi -- u1*u2LL u1*u2LM u1*u2HM  u1*u2HH) \ unsigned 64 bit * 64bit -- 128 bit result
\
\
build_BootOpt :rasm
		mov	__u2LM , $C_stTOS
		spop
		mov	__u2LL , $C_stTOS
		spop

		mov	__u2HM , # 0
		mov	__u2HH , # 0

\ treg1 - u1hi
\ stTOS - u1lo
		spopt

\ treg2 - resLL
\ treg3 - resLM
\ treg4 - resHM
\ treg5 - resHH

		mov	$C_treg2 , # 0
		mov	$C_treg3 , # 0
		mov	$C_treg4 , # 0
		mov	$C_treg5 , # 0


__x01
		shr	$C_treg1 , # 1		wz wc
		rcr	$C_stTOS , # 1		wc
	if_z	cmp	$C_stTOS , # 0		wz

	if_nc	jmp     # __x02
\
		add	$C_treg2 , __u2LL	wc
		addx	$C_treg3 , __u2LM	wc
		addx	$C_treg4 , __u2HM	wc
		addx	$C_treg5 , __u2HH
__x02
\
		shl	__u2LL , # 1		wc
		rcl	__u2LM , # 1		wc
		rcl	__u2HM , # 1		wc
		rcl	__u2HH , # 1

	if_nz	jmp     # __x01
\		
		mov	$C_stTOS , $C_treg2
		spush
		mov	$C_stTOS , $C_treg3
		spush
		mov	$C_stTOS , $C_treg4
		spush
		mov	$C_stTOS , $C_treg5

		jexit
__u2LL
 0
__u2LM
 0
__u2HM
 0
__u2HH
 0
;asm dum*


\
\
\ dum/mod ( u1LL u1LM u1HM u1HH u2lo u2hi -- remainderlo remainderhi quotientlo quotienthi )
\ unsigned divide & mod  u1 divided by u2
\
build_BootOpt :rasm
		mov	$C_treg4 , $C_stTOS
		spop
		mov	__u2lo , $C_stTOS
		spop
\ u2hi - treg4
\ u1HH - treg3
\ u1MH - treg2
\ u1ML - treg1
\ u1LL - stTOS
\

		mov	$C_treg3 , $C_stTOS
		spop
		mov	$C_treg2 , $C_stTOS
		spop
                     
		spopt

		mov	$C_treg6 , # h80
		mov	__remlo , # 0
		mov	__remhi , # 0
\
__x01
		shl	$C_stTOS , # 1		wc
		rcl	$C_treg1 , # 1		wc
		rcl	$C_treg2 , # 1		wc
		rcl	$C_treg3 , # 1		wc
\                                                
		rcl	__remlo , # 1		wc
		rcl	__remhi , # 1		wc
\
	if_c	jmp	# __x02
\        
		cmp	__remlo , __u2lo	wz wc
		cmpx	__remhi , $C_treg4	wc
	if_c	mov	$C_treg5 , # 0
	if_c	jmp	# __x03
	
__x02
		sub	__remlo , __u2lo	wz wc
		subx	__remhi , $C_treg4
		mov	$C_treg5 , # 1
__x03
		rcr	$C_treg5 , # 1		wc

		rcl	__quolo , # 1		wc
		rcl	__quohi , # 1
                                  
		djnz	$C_treg6 , # __x01
\
		mov	$C_stTOS , __remlo
		spush
		mov	$C_stTOS , __remhi
		spush
		mov	$C_stTOS , __quolo
		spush
		mov	$C_stTOS , __quohi
		jexit

__u2lo
 0

__remlo
 0
__remhi
 0

__quolo
 0
__quohi
 0
;asm dum/mod


\
\ d+ ( n1lo n1hi n2lo n2hi -- n3lo n3hi ) n3 = n1+n2
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		add	$C_stTOS , $C_treg2		wc
		addsx	$C_treg1 , $C_treg3
\
		spush
		mov	$C_stTOS , $C_treg1		
\
		jexit
;asm d+


\
\ d- ( n1lo n1hi n2lo n2hi -- n3lo n3hi ) n3 = n1-n2
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		sub	$C_stTOS , $C_treg2		wz wc
		subsx	$C_treg1 , $C_treg3
\
		spush
		mov	$C_stTOS , $C_treg1		
\
		jexit
;asm d-


\
\ du> ( n1lo n1hi n2lo n2hi -- flag )
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		cmp	$C_stTOS , $C_treg2	wz wc
		cmpx	$C_treg1 , $C_treg3	wz wc
\
		mov	$C_stTOS , # 0
	if_a	mov	$C_stTOS , $C_fLongMask
\
		jexit
;asm du>


\
\ du< ( n1lo n1hi n2lo n2hi -- flag )
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		cmp	$C_stTOS , $C_treg2	wz wc
		cmpx	$C_treg1 , $C_treg3	wz wc	
\
		mov	$C_stTOS , # 0
	if_b	mov	$C_stTOS , $C_fLongMask
\
		jexit
;asm du<

\
\ du= ( n1lo n1hi n2lo n2hi -- n3lo n3hi ) n3 = n1-n2
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		cmp	$C_stTOS , $C_treg2	wz wc
		cmpx	$C_treg1 , $C_treg3	wz wc
\
		mov	$C_stTOS , # 0
	if_e	mov	$C_stTOS , $C_fLongMask
\
		jexit
;asm d=


\
\ du>= ( n1lo n1hi n2lo n2hi -- flag )
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		cmp	$C_stTOS , $C_treg2	wz wc
		cmpx	$C_treg1 , $C_treg3	wz wc
\
		mov	$C_stTOS , # 0
	if_ae	mov	$C_stTOS , $C_fLongMask
\
		jexit
;asm du>=


\
\ du<= ( n1lo n1hi n2lo n2hi -- flag )
build_BootOpt :rasm
\ n2hi
		mov	$C_treg3 , $C_stTOS
		spop
\ n2lo
		mov	$C_treg2 , $C_stTOS
		spop
\ n1hi	
		spopt
\
\ stTOS - n1lo
\ treg1 - n1hi
\ treg2 - n2lo
\ treg3 - n2hi
\
		cmp	$C_stTOS , $C_treg2	wz wc
		cmpx	$C_treg1 , $C_treg3	wz wc	
\
		mov	$C_stTOS , # 0
	if_be	mov	$C_stTOS , $C_fLongMask
\
		jexit
;asm du<=


}

...

}}}

== time f ==

Time.f is the same as the default Logger1Simple download.

In this file, we can modify line 51 to change the logging frequency.  When clkfreq is used as the logging frequency, a log file record is recorded once every second.  multiplying this by 10 records once every 10 seconds etc. 

Recall that the crystal's drift is corrected each time the time is read. In the default case, the drift is corrected every second. The drift correction is stated in term of tick per hour.  I think the drift needs to be correct once each hour at minimum, but I didn't check it.  I think the might be affected by how often the records are collected, and how big the records are. Spare, short records might need a different correction than lots of long records, even on the same board.  I think what really matters is consistent record size and logging frequency, and setting the correction case by case. 

time.f  is included here for reference. You should download the archive and open the file in a text editor.  You should copy and paste from the text editor, as doing so from this browser window can cause undefined results. 

{{{
fl


100 fwrite time.f

\
\ 2012-Feb-04 Status: Alpha
\
\ Provides a high resolution long time system timer by using one cog
\ to update a 64-bit counter as rapidly as possible. The main word is
\ _tickCounter ( addr_dticks _timelock -- ) 
\
\ When this words starts it sets the default time zone,
\ Sets the default time to 2012-01-01_12:00:00 UTC,
\ and adjusts the parameters to the current clkfreq 
\
\ This word will be run on one cog at system startup.
\
\ Counts system clock cycles (ticks) since system startup as an
\ unsigned double long.
\
\ Update read cycle is approximately 1 - 2 microseconds on an
\ 80 Mhz system.
\
\ This is because we have to use a lock, to update, or to read the
\ 2 longs that make up the double counter.
\
\ The words which update the double counter, and which read the
\ double counter, are written in assembler to ensure maximum resolution.
\ 
\ This provides a range of about 7,311 years at 80 Mhz
\ 2^64 / 80,000,000 / 60 / 60 / 24 / 365
\
\ The range will vary if the clock frequency changes, the design point
\ on this was an 80 Mhz system
\
\ Time is then calculated as ticks since 1970-Jan-01_00:00:00
\ only unsigned counts are considered, so minimum date is 1970-Jan-01_00:00:00
\
\ So for the unix people, you can generate a unix time stamp easily
\
\ NOTE: UTC -> local timezone conversion can cause an underflow. 
\
\ setTimeZone ( h m -- ) - sets the time zone h and m can be positive or negative
\
\ setTime ( y m d h m s -- ) sets the UTC time
\
\ setLocalTime ( y m d h m s -- ) subtracts the time zone, then sets UTC time
\
\ getTime ( -- y m d h m s ticks -- ) gets UTC time
\
\ getLocalTime ( -- y m d h m s ticks -- ) gets local time
\ 
\ formatTime ( -- y m d h m s ticks -- cstr) formats a to a printable sortable string
\
\ getTimeStr( -- cstr) get the current UTC time as a string
\
\ getLocalTimeStr( -- cstr) get the current local time as a string
\
\ time ( -- ) print the local time
\
\ setDriftCorrection ( n1 -- ) sets the time correction to n1 ticks per day
\
\ utc ( -- ) print the utc time
\
\ timeStamp ( -- lo hi) gets a number which is the time stamp in microseconds (UTC)
\                       the number of microseconds since 1970-01-01_00:00:00
\                       print with d. or the double format words 
\
\ unixTimeStamp ( -- lo hi) gets a number which is the time stamp in seconds (UTC)
\                           the number of seconds since 1970-01-01_00:00:00
\                           print with d. or the double format words
\
\
1 wconstant build_time
\
\ Begin config parameters
\

\ NOTICE:  You need to set your own time ZONE!

[ifndef timeZoneHours
-7 constant timeZoneHours
]
[ifndef timeZoneMinutes
0 constant timeZoneMinutes
]
[ifndef doubleTimerCog
3 wconstant doubleTimerCog
]
\
\ End config parameters
\
\
\
\ a double long, the current number of clock ticks since boot
[ifndef _dtickCNT 
lockdict variable _dtickCNT 4 allot freedict
]
\
[ifndef _dtimeOffset 
lockdict variable _dtimeOffset 4 allot freedict 0 u>d _dtimeOffset dL!
]
\
\ These will be re-initialized by _tickCounter when is starts up
\ in case the running system is running a different clock 
\ frequency
\
[ifndef _driftCorrectionNumerator 
lockdict variable _driftCorrectionNumerator 4 allot freedict
]
\
[ifndef _dTimeZoneOffset 
lockdict variable _dTimeZoneOffset 4 allot freedict 0 u>d _dTimeZoneOffset dL!
]
\
[ifndef _dticks/400years 
lockdict variable _dticks/400years 4 allot freedict
]
[ifndef _dticks/100years 
lockdict variable _dticks/100years 4 allot freedict
]
[ifndef _dticks/leapyear 
lockdict variable _dticks/leapyear 4 allot freedict
]
\
[ifndef _dticks/year
lockdict variable _dticks/year 4 allot freedict
]
[ifndef _dticks/day 
lockdict variable _dticks/day 4 allot freedict
]
\
[ifndef _dticks/hour 
lockdict variable _dticks/hour 4 allot freedict
]
\
[ifndef _dticks/min 
lockdict variable _dticks/min 4 allot freedict
]
\
\
clkfreq u>d 
d_60 u>d du* 2dup _dticks/min dL!
d_60 u>d du* 2dup _dticks/hour dL!
d_24 u>d du* 2dup _dticks/day dL!
\
2dup d_365 u>d du* _dticks/year dL!
2dup d_366 u>d du* _dticks/leapyear dL!
\
\
\ days per 100 years = 100 * 365 + 24 leapdays = 36_524
2dup d_36_524 u>d du* _dticks/100years dL!
\
\ days per 400 years = 400 * 365 + 97 leapdays = 146_097
d_146_097 u>d du* _dticks/400years dL!
\
\
\
\ Tick / Date Time routines
\
\
\ isleap ( yyyy -- t/f)
[ifndef isleap
: isleap
	dup 3 and 0=
	if					\ divisible by 4   - yes
		dup d_100 u/mod drop 0=		\ divisible by 100 - no 
		if 
			d_400 u/mod drop 0=	\ divisible by 400 - yes
		else 
			drop -1
		then
	else 
		drop 0 
	then
;
]
\
\
\ This routine is slow, but it only gets called when the time is being set or
\ conversions, probably not worth a re-write
\
\ y>t ( yyyy -- tickslo tickshi ) year > ticks
: y>t
	d_1970 max
	dup
	d_1970 =
	if
		drop 0 u>d
	else
		dup d_1970 - d_365 u* swap
		d_1970
		do
			i isleap
			if
				1+
			then
		loop
		u>d _dticks/day dL@ du*
	then
;
\
\ This routine is also slow, and it gets called every time a timestamp is generated
\
\ _t>y ( tickslo ticksthi -- remlo remhi y)
: _t>y
	ddup 0 u>d d=
	if
		d_1970
	else
		0 rot2
		d_9281 d_1970
		do
			i isleap
			if
				_dticks/leapyear
			else
				_dticks/year
			then
			dL@ d2dup du>=
			if
				d-
			else
				ddrop rot drop i leave
			then
		loop
	then
;
\	
\
lockdict
wvariable _dpm d31 w, d59 w, d90 w, d120 w, d151 w, d181 w, d212 w, d243 w, d273 w, d304 w, d334 w, 0 _dpm W!
freedict
\
lockdict
wvariable _ldpm d31 w, d60 w, d91 w, d121 w, d152 w, d182 w, d213 w, d244 w, d274 w, d305 w, d335 w, 0 _ldpm W!
freedict
\
\ ymd>t ( yyyy mm dd -- tickslo tickshi ) ymd > ticks
: ymd>t
	1- >r 1- >r dup >r y>t r> r> r>
	rot isleap
	if
		_ldpm
	else
		_dpm
	then

	rot 2* + W@ + u>d _dticks/day dL@ du*
	d+
;
\
\ _t>ymd ( tickslo tickshi -- remlo remhi yy mm dd )
: _t>ymd
	_t>y
	dup >r
	isleap
	if
		_ldpm
	else
		_dpm
	then
	rot2
	_dticks/day dL@ du/mod d>u
	>r rot d22 + r> swap
	d12 0
	do
		2dup W@ u>=
		if
			W@ - 11 i -
			leave
		else
			2-
		then
	loop		
	1+ swap 1+
	r>
	rot2
;


\
\ ymdhms>t ( y m d h m s -- tlo thi )
: ymdhms>t
	>r >r >r
	ymd>t 
	r> u>d _dticks/hour dL@ du* d+
	r> u>d _dticks/min dL@ du* d+
	r> u>d clkfreq u>d du* d+
;

\
\ _t>ymdhms ( tickslo tickshi -- y m d h m s rem  )
: _t>ymdhms
	_t>ymd
	>r >r rot2 r> rot2 r> rot2
	_dticks/hour dL@ du/mod d>u rot2
	_dticks/min dL@ du/mod d>u rot2
	clkfreq u>d du/mod d>u rot2 d>u
;

\
\
\ the lock used to access the timecount
[ifndef _timelock
6 wconstant _timelock
]
\	
lockdict create __tickcounter forthentry
$C_a_lxasm w, h12E  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z1SyLIZ l, z2WiPik l, z2WyPj0 l, z8FPeB l, z20yPO4 l, z8FPmB l, z24yPO4 l, zDVPW6 l,
z1SS04Q l, z2WiPyk l, z27FPuD l, z8FPuB l, z20yPO4 l, z38yPj0 l, z8FPmB l, zCVPW7 l,
z24yPO4 l, z2WiPeF l, 0 l, 0 l, 0 l, 0 l, 0 l, 0 l,
0 l, 0 l, z1SV04Q l,
freedict

lockdict create __tickCNTat forthentry
$C_a_lxasm w, h11E  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z1SyLIZ l, z2WiPeB l, zDVPW6 l, z1SS04L l, z8iPRD l, z20yPb4 l, z8iPmD l, zCVPW7 l,
z1SyJQL l, z2WiPRE l, z1SV01X l,
freedict

\ _dtickCNT@ ( -- n1 n2 ) n1 - lo long of timecount n2, hi long of timecount
: _dtickCNT@
	_dtickCNT _timelock __tickCNTat _driftCorrectionNumerator dL@ _dticks/hour dL@ d*/ 
;


\
\ _dsettime ( tlo thi -- )
: _dsettime
	_dtickCNT@ d- _dtimeOffset dL!
;

\
\ _dsetLocaltime ( tlo thi -- )
: _dsetLocaltime
	_dTimeZoneOffset dL@ d- _dtickCNT@ d- _dtimeOffset dL!
;

\ setTimeZone ( h m -- ) - sets the time zone h and m can be positive or negative
: setTimeZone
	dup 0>=
	if
		u>d _dticks/min dL@ du*
	else
		abs
		u>d _dticks/min dL@ du*
		0 u>d dswap d-
	then

	rot
	dup 0>=
	if
		u>d _dticks/hour dL@ du*
	else
		abs
		u>d _dticks/hour dL@ du*
		0 u>d dswap d-
	then
	d+ _dTimeZoneOffset dL!
;
\
\ setTime ( y m d h m s -- ) sets the UTC time
: setTime
	ymdhms>t _dsettime
;
\ setLocalTime ( y m d h m s -- ) subtracts the time zone, then sets UTC time
: setLocalTime
	ymdhms>t _dsetLocaltime
;
\
\ _dgettime ( -- tlo thi) gets a 64bit (double) value which is the number of ticks since
\                         1970-01-01_00:00:00
: _dgettime
	_dtickCNT@ _dtimeOffset dL@ d+
;
\
\ _dgetLocaltime ( -- tlo thi) gets a 64bit (double) value which is the number of ticks since
\                              1970-01-01_00:00:00 + time zone
: _dgetLocaltime
	_dtickCNT@ _dtimeOffset dL@ d+ _dTimeZoneOffset dL@ d+
;

\ getTime ( -- y m d h m s ticks -- ) gets UTC time
: getTime
	_dgettime _t>ymdhms
;
\ getLocalTime ( -- y m d h m s ticks -- ) gets local time
: getLocalTime
	_dgetLocaltime _t>ymdhms
;
\
\ formatTime ( -- y m d h m s ticks -- cstr) formats a to a printable sortable string
: formatTime
	d_1000_000 clkfreq u*/ 
	<#
		# # # # # # drop h2E #C
		# # drop h3A #C # # drop h3A #C # # drop
		h5F #C # # drop h2D #C # # drop h2D #C # # # #
	#>
;
\
\ getTimeStr( -- cstr) get the current UTC time as a string
: getTimeStr
	getTime formatTime
;
\
\ getLocalTimeStr( -- cstr) get the current local time as a string
: getLocalTimeStr
	getLocalTime formatTime
;
\
\ time ( -- ) print the local time
: time 
	getLocalTimeStr .cstr cr
;
\ setDriftCorrection ( n1 -- ) sets the time correction to n1 ticks per hour
: setDriftCorrection
		i>d _dticks/hour dL@ d+ _driftCorrectionNumerator dL!
;
\
\ utc ( -- ) print the utc time
: utc 
	getTimeStr .cstr cr
;
\
\
\ timeStamp ( -- lo hi) gets a number which is the time stamp in microseconds (UTC)
\                       the number of microseconds since 1970-01-01 00:00:00
\                       print with d. or the double format words
: timeStamp
	_dgettime d_1_000_000 u>d clkfreq u>d du*/
;
\ unixTimeStamp ( -- lo hi) gets a number which is the time stamp in seconds (UTC)
\                           the number of seconds since 1970-01-01 00:00:00
\                           print with d. or the double format words
: unixTimeStamp
	timeStamp d_1_000_000 u>d du/
;
\ _tickCounter ( addr_dticks _timelock -- )
: _tickCounter
	4 state andnC!
	c" TIME COUNTER" cds W!

	clkfreq u>d 
	d_60 u>d du* 2dup _dticks/min dL!
	d_60 u>d du* 2dup _dticks/hour dL!
	d_24 u>d du* 2dup _dticks/day dL!
\
	2dup d_365 u>d du* _dticks/year dL!
	2dup d_366 u>d du* _dticks/leapyear dL!
\
\
\ days per 100 years = 100 * 365 + 24 leapdays = 36_524
	2dup d_36_524 u>d du* _dticks/100years dL!
\
\ days per 400 years = 400 * 365 + 97 leapdays = 146_097
	d_146_097 u>d du* _dticks/400years dL!
\
	timeZoneHours timeZoneMinutes setTimeZone
	0 setDriftCorrection
\
	cnt COG@ _dtickCNT L!

	__tickcounter
;

\ dow ( tlo thi -- dow ) dow - 0 - Sun, 1 -Mon ... 6 - Sat
: dow
	_dticks/day dL@ du/
	7 0 du/mod
	3drop 4 +
	dup 7 >=
	if
		7 -
	then
;

: startTickCounter
	doubleTimerCog cogreset d_100 delms
\ clear the lock explicitly 
	_timelock 7 hubopf drop
	c" _dtickCNT _timelock _tickCounter" doubleTimerCog cogx d_100 delms
	d_2012 1 1 d_12 0 0 setTime
;

startTickCounter



{
fl	
: ttest
	1000 0
	do
		getTimeStr
		7 lock
		.concstr c"  COG: " .concstr cogid .con .concr
		7 unlock
	loop
;
: test
	time cr
	1000 0
	do
		getTime 3drop 3drop drop
	loop
	time cr
;

: utt
	c" ttest" dup 1 cogx
	dup 2 cogx
	dup 3 cogx
	dup 4 cogx
	5 cogx
;

}


{
fl

\ __tickcounter ( addr_dticks _timelock-- )
\
build_BootOpt :rasm
	spopt
\
\ $C_stTOS - addr_dticks
\ $C_treg1 - _timelock
\
	mov	$C_treg2 , cnt
	mov	$C_treg3 , # 0 

	wrlong	$C_treg2 , $C_stTOS
	add	$C_stTOS , # 4
	wrlong	$C_treg3 , $C_stTOS
	sub	$C_stTOS , # 4

__mainloop
		lockset	$C_treg1 wc
	if_c	jmp	# __mainloop


		
		mov	$C_treg4 , cnt

		cmp	$C_treg4 , $C_treg2 wz wc

		wrlong	$C_treg4 , $C_stTOS
		add	$C_stTOS , # 4
		addx	$C_treg3 , # 0

		wrlong	$C_treg3 , $C_stTOS

		lockclr	$C_treg1

		sub	$C_stTOS , # 4
		mov	$C_treg2 , $C_treg4
\
\ Make sure the window for other cogs to access is wide enough to prevent deadlock
\
		nop
		nop
		nop
		nop

		nop
		nop
		nop
		nop
		

	jmp	# __mainloop


;asm __tickcounter

\ __tickCNTat ( addr_dticks _timelock -- countlo counthi )
build_BootOpt :rasm
	spopt
\
\ $C_stTOS - addr_dticks
\ $C_treg1 - _timelock
\
	mov	$C_treg2 , $C_stTOS

__mainloop
		lockset	$C_treg1 wc
 if_c	jmp	# __mainloop
	
	rdlong	$C_stTOS , $C_treg2
	add	$C_treg2 , # 4
	rdlong	$C_treg3 , $C_treg2

	lockclr $C_treg1
	spush
	mov	$C_stTOS , $C_treg3

	jexit

;asm __tickCNTat


}

...

}}}


== logger init  f ==

LoggerInit.f is a short script that creates a  50 meg file on the mountusr partition.  Recall each block is 512 bytes. 100_000 blocks is 51.2 meg.

This script MUST be run or the logge won't log anything.  It will run, but the data won't have anyplace to go. 

Use the following command to switch to the user partiion, list the directory (by default is has one file , log), and display the contents of the log.
 
{{{
mountusr 
ls 
fread log
}}}

= Step 3 SR04 =

Add the SR04 ultrasonic range finder

If you want to position the display output, you can do some crude but effective screen placement using ANSI terminal codes as shown in LittleRobotDemoUltrasonic

As always, remember:
 * SR04 needs 10k ohm resistor between echo and pin 25 (prop input pin)
 * SR04 connects to Vin (5volts)

Loading the follwoing will write the SRR04-SD.f file to memory
 
{{{
\ SR04 for SD logging

fl

10 fwrite SR04SD.f

1 wconstant build_sr04
[ifndef _sr04_trig
	d_24 wconstant _sr04_trig
]
[ifndef _sr04_echo
	d_25 wconstant _sr04_echo
]

variable _sr04_distance

: _sr04_measure
	c" MEASURE" cds W!
	4 state andnC!
	_sr04_trig pinlo _sr04_trig pinout
	_sr04_echo >m
	_sr04_trig >m
	begin
		dup _maskouthi dup dup drop _maskoutlo

		over dup dup dup

		waitpeq
		cnt COG@
		rot2

		waitpne
		cnt COG@ swap -
		d_170_000 clkfreq */
		_sr04_distance L!
		100 delms
	0 until
;

[ifdef sr04_test
: sr04_test
	begin
		_sr04_distance L@ . 
		fkey? nip
    100 delms
	until
;
]

\ c" _sr04_measure" 1 cogx
c" _sr04_measure" nfcog cogx

...


}}}

For testing, manually load the code at the end

{{{
: sr04_test
	begin
		_sr04_distance L@ . 
		fkey? nip
    
    100 delms
    
	until
;
}}}

and run the word 'sr04_test' to display the SRR04 distance on the terminal display

== SR04SD f ==

SR04-SD.f sets up the SR04 driver.  It uses the same pinout as the QSbot.f program discussed in the LittleRobot demo. 

When the program loads at boot time, it automatically starts the MEASURE routine on the next free cog. 

use `cog?` to show which tasks are running on each cog. 

-----
= Step 4 Update usrboot.f =

Change usrboot.f to include the line to load (and launch) the SR04 driver.  For clarity, I name this file 'usrboot-SD04.f' in the source directory on the PC. 


On powercycle or reboot, run the 'cog?' command to see that ach dirver is running:

{{{
Prop0 Cog6 ok
cog?
Cog:0  #io chan:1                     TIME COUNTER
Cog:1  #io chan:1 PropForth v5.5 2013Feb20 11:30 0
Cog:2  #io chan:1                          MEASURE
Cog:3  #io chan:1                           LOGGER
Cog:4  #io chan:1 PropForth v5.5 2013Feb20 11:30 0
Cog:5  #io chan:1 PropForth v5.5 2013Feb20 11:30 0
Cog:6  #io chan:1 PropForth v5.5 2013Feb20 11:30 0  6(0)->7(0)
Cog:7  #io chan:1                           SERIAL  7(0)->6(0)
Prop0 Cog6 ok


}}}


== Logger Boot 10 hc06 f ==

Logger boot10-HC06.f is a modified LoggerBoot.f

This loads itself onto the SD card, and create the new usrboot.f file. 

The new userboot.f file is loaded automatically at boot time. 

It set the timezone, and sets the drift correction (whoops! I didn't put that in.  It goes AFTER the fload time.f; but I haven't figured the coreection for this test rig anyway).

It loads the drivers, and starts all the tasks.

IF you HOLD DOWN the ESC key while its booting, the boot will be aborted. 

IF you wait uuntil the scripts start loading THEN hold down the escape key, you can load all the driver, but prevent it from switching to blue tooth at the very end. See `Onreset6`.   HANDY during DEBUG.

{{{
fl

mountsys

100 fwrite usrboot.f
version W@  .cstr cr

c" usrboot.f  -  initializing~h0D~h0D" .cstr

1 sd_mount

\
\ Begin config parameters
\
[ifndef timeZoneHours
-7 constant timeZoneHours
]
[ifndef timeZoneMinutes
0 constant timeZoneMinutes
]

\ from time.f
[ifndef doubleTimerCog
0 wconstant doubleTimerCog
]
\
\ End config parameters
\


fload DoubleMath.f
fload time.f

\ 0 setDriftCorrection \ 11_000_000 to 14_000_000 observed so far

fload SR04SD.f


lockdict wvariable logBuffer 256 allot freedict
: logdata
	getLocal Time formatTime logBuffer ccopy
\	c"  CNT REGISTER: " logBuffer cappend
\	base W@ hex cnt COG@ <# #s #> logBuffer cappend base W!
\	c"  timeStamp: " logBuffer cappend
\	base W@ decimal timeStamp <# d#s #> logBuffer cappend base W!
\	c"  unixTimeStamp: " logBuffer cappend
\	base W@ decimal unixTimeStamp <# d#s #> logBuffer cappend base W!

	c"  SR04 mm: " logBuffer cappend
	base W@ decimal _sr04_distance L@ <# #s #> logBuffer cappend base W!

	c" ~h0D" logBuffer cappend
	logBuffer
;



\ clkfreq constant logperiod \ once each second
 clkfreq 10 * constant logperiod \ once each ten seconds

\ log very second
: logger
	4 state andnC!
	c" LOGGER" cds W!
	mountusr
	cnt COG@ clkfreq +
	begin
		logperiod waitcnt
		logdata C@++ c" log" 7 lock sd_append 7 unlock
		
	0 until 
;

: ClearLog
	mountusr
	7 lock 0 c" log" sd_trunc 7 unlock
;

\ =========
\ for the HC06
\ white/orange wire - QSbot RXD to p27
27 wconstant hcRx

\ white/green wire - QSbot TXD to p26
26 wconstant hcTx
\ 9600 4/ wconstant hcBaud
230400 4/ wconstant hcBaud  \ NOW we are 230400 !!!

nfcog wconstant hcSerialCog
\ hcSerialCog cogreset 100 delms
\  c" hcRx hcTx hcBaud serial " hcSerialCog cogx 100 delms
\ ========== 


c" logger" nfcog cogx

fread .sdcardinfo

c" usrboot.f  -  DONE~h0D~h0D" .cstr

: onreset6
fkey? and fkey? and or h1B <>
if
$S_con iodis $S_con cogreset 100 delms
c" hcRx hcTx hcBaud serial" $S_con cogx 100 delms
cogid >con
\ c" _sr04_measure" 2 cogx
then
c" onreset6" (forget)
;
...

}}}

-----

The remainder is for debugging.  The autoboot scrip sets everything up; if you need to make changes section 5 and 6 talk about things to experiment with. 

-----
= Step 5 - Log the SR04 data =

After the logger and the SR04 are working, change the logger routing to log the SR04.  Add the appropriate line to the 'logdata' word as shown below, and paste the new 'LoggerBoot-SR04.f' file into the terminal.  Reboot.

Use 'ClearLog' to erase the old data from the log file.   Be sure to 'mountusr' to switch to the user partition on the SD, that is where the 'log' file resides.

{{{
: logdata
	getLocalTime formatTime logBuffer ccopy
	c"  CNT REGISTER: " logBuffer cappend
	base W@ hex cnt COG@ <# #s #> logBuffer cappend base W!
	c"  timeStamp: " logBuffer cappend
	base W@ decimal timeStamp <# d#s #> logBuffer cappend base W!
	c"  unixTimeStamp: " logBuffer cappend
	base W@ decimal unixTimeStamp <# d#s #> logBuffer cappend base W!
  
 c"  SR04 mm: "      logBuffer cappend
 base W@ decimal _sr04_distance  L@ <# #s #> logBuffer cappend base W!

	c" ~h0D" logBuffer cappend
	logBuffer
;


}}}

-----

= Step 6 - Connect via Blue tooth =

If you wish to connect wirelessly via blue tooth, it is advisable to do this last. 

After the SD kernel is shown to be working; and the logger is working, and the dirft offset has been calibrated, and the SR04 is working, and the SR04 is logging, add blue tooth suupport using the HC06.

Then past the final version of 'LoggerBoot-SR04.f' to switch the serial lines to the HC06. 

To deactivate the code that automatically switches to the blue tooth connection, comment out the code for
{{{
onreset6
}}}
in step 4 above.

-----

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages