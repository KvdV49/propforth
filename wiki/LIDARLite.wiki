#summary LIDAR-Lite laser range finder

= Introduction =

LIDAR-Lite was introduced as a kickstarter. This was claimed to be the same performance as the $350 SF02 laser range finder.  Naturally, I was curious, and backed the project.  We can never have too many great sensors. 

However, I am sceptical.  There's no way.  If this does work I will be very pleased.  But the only was to test is side by side.  So here goes.

= LIDAR Lite I2C =


== Documentation ==

The documentation for LIDAR Lite is in need of some work.  As of this writting,  the item marked "data sheet" is actuall marketing material.  The item marked User Guide has some of the material we would want from a data sheet. 

http://pulsedlight3d.com/pl3d/wp-content/uploads/2014/10/LIDAR-Lite-Operating-Manual.pdf

I'm giving comments, perhaps the materials will be improved.

== I2C ==

LIDAR Lite is I2C or PWM.  While the SF02 can spit readings directly to your serial terminal application, the LIDAR-Lite MUST talk through an external microcontroller.   Fair enough, most folks are going to hook this up to an arduinl, etc. anyway.  But its slower getting started. 

LIDAR-Lite is an I2C slave. Host microcontroller (our Prop in our case) is I2C master.

=== I2C address ===

One part of the manual says I2C address is 0x84 another place says 0xC4. So is it 0x84 or 0xC4?  

UPDATE: LIDAR Lite uses I2C address 0xC4 to transmit to the device, and I2C address 0xC5 to recive from the device. 

=== write ===

Manual says: Measurement: Write register 0x00 with value 0x04 (This performs a DC stabilization cycle, Signal Acquisition, Data processing).
Refer to the section "I2C Protocol Summary‚Äù in this manual for more information about I2C Communications.  

Success!

=== poll ===

Manual says: Periodically poll the unit and wait until an ACK is received. The unit responds to read or write requests with a NACK when the sensor is busy processing a command or performing a measurement. (Optionally, wait approx. 20 milliseconds after acquisition and then proceed to read of high and low bytes)

Update: Propforth 5.5  needs to DELAYS added between I2C command to the LIDAR Lite.  Otherwise, it appears Propforth sends the next command before the LIDAR-Lite is ready, and  ends up waiting forever, as the LIDAR-Lite never sees the command. 

Add delay of 37  milliseconds after setting the control register to "measure" 

The lines with delays of 2 milliseconds and 3 milliseconds in the code below

2 delms and 3 delms

are commented out.

=== read ===

Manual says:   Read: register 0x0f, returns the upper 8 bits of distance in cm, register 0x10, returns the lower 8 bits of distance in cm. 
(Optionally a 2 Byte read starting at 0x8f can be done) 

I started with the two reads of 1 byte, and its working.  Next I should try the single 16 bit read.

=== what it means ===

The manual says:

The effective 8 bit I2C address is: 0xC4 write, 0xC5 read. 

Load the control register (at address 0) with Value 4 to make a single measurement

= Sort this out =

We have been give a bunch of stuff.  Mostly hex values that could be I2C address or register address.

|| hex value || pssible meansing || comments ||
|| 0x00 || register||  load with 0x00 to initialize ||
|| 0x04 || init code || load into register 0x00 to init part ||
|| 0x0f || register  || upper 8 bits of distance in cm || 
|| 0x10 || register  || lower 8 bits of distance in cm || 
|| 0x8f || register  || 16 bits of distance in cm || 
|| 0xC4 || I2C address write ||  0xC4 write ||
|| 0xC5  || I2C address write || 0xC5 read ||

I don't know if this is correct, but it was in the materials:

|| 0x62 through 0x42 || Array of possible address for LIDAR-Lite Sensor || ??? ||

= Braino's PropFORTH 5.5 test code =

This is what I have running at this moment:

{{{

fl

1 wconstant build_LIDAR

wvariable lo wvariable hi 

: hiloinit 32767 lo W!  0 hi W!  ;

: ?lo dup lo W@ < if lo W! else drop then ;
: ?hi dup hi W@ > if hi W! else drop then ;
: .hilo  hi W@  .  lo W@  . ;

\ _LIDARs ( addr -- ) Send - [I2C write address] reg to write 
: _LIDARs 
\        _eestart hC4 _eewrite 2 delms   swap _eewrite or 
        _eestart hC4 _eewrite   swap _eewrite or 
        if              h44 ERR         then ;
\ _LIDARr ( addr -- )  recieve - [I2C read address] reg to read 
: _LIDARr
\        _LIDARs 2 delms  _eestart hC5 _eewrite 
        _LIDARs  _eestart hC5 _eewrite 
        if              h45 ERR         then ;
\ Measurement:  Write register 0x00 with value 0x04
\ _Lidarcrw ( c -- ) send charon stack to ctl reg 0x00
: _Lidarcrw
	h00 _LIDARs  _eewrite _eestop
	if
		h46 ERR
	then
;
\ \ no 10 25 31, 34 stopped;  yes 100 50 37 
:  measure  h04 _Lidarcrw 37 delms ;

\ -------------------

\  : LidarControlRegister h00 _LIDARs ; 

\  :  measure LidarControlRegister h04 _LIDARs ;

\ Read: reg 0x0f, upper 8 bits dist; reg 0x10 lower 8 bits dist ; 2Byte 0x8f

\ _LIDARr8 ( addr - U8 )  register read
: _LIDARr8 
               _LIDARr  -1 _eeread _eestop 
;

: LIDAR.LO measure h10 _LIDARr8 dup ?lo dup ?hi ;

: LIDAR.HI measure h0F _LIDARr8  ;

\ measure LIDAR.HI 8 lshift LIDAR.LO or . 

\ : PL  LIDAR.HI 8 lshift 2 delms LIDAR.LO or  ;
\ : PL  LIDAR.HI 8 lshift 3 delms LIDAR.LO or  ;
: PL  LIDAR.HI 8 lshift LIDAR.LO or  ;

: .PL PL . ;

\  checking ( count - count+1 ) 
: checking 1+ dup . .PL ." === "  .hilo  cr ;

: test 
      0 hiloinit
      begin   checking
        fkey? swap drop until ;    


}}}

= distance readings = 

Like the SF02, the data readings "bounce around" a bit. 

The test code reads measurements in a continuous loop.  I print the current reading, and save highest and lowest reading so far. 

I aim the device at a target a known distance, and measure to 10,000 iteration.  I should probably just capture the measurements, and make a distribuation graph using a spread sheet.   But I'm just playing for now. 

== 150 cm distance ==

This was probably 84 centimeters, from the top of my bench to the ceiling. 

The 1st measurement was 84 cm, most measurements were around 84 cm.

 * 3rd measurement was 83 cm, 
 * 8th was 82 cm.
 * 21rst measurement was 85 cm.
 * 69th was 86 cm.
 * 383th was 81 cm.
 * 1244th was 80 cm
 * 5409th was 87 cm.
 * 9361rst was 57 cm (wow, talk about an outlier!)

== 15cm distance ==

I measured this with a ruler:


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages