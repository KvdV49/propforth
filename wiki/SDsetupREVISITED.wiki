#summary Set up SD for Propforth.
#labels SDcard,PropForthSDFastSerialKernel.spin,Loopy

= NOTICE =

You MUST have the PULL UP RESISTORS or it won't work.  Do I have you attention?  See below for the pull up resistors you must have.  Or it won't work.   Did I mention it won't work without the pull up resistors?

= HARDWARE =

== SD CARD tabs ==

The SD card tabs are the little gold contacts on the SD card.  Some folks call these pins but they are not pins. At least they don't look like pins to me, so I will call them TABS.  I will use PINS to refer to the I/O pins p0 through p31 on the propeller chip.  

== SD card connections ==

Set up an SD card or SD adapter per

http://code.google.com/p/propforth/wiki/PropToSDconnection

I'm using a full size SD adaptor as a card slot for microsd cards.

Looking at the bottom of the Full size SD adaptor with the gold tabs facing up and at the top of the card, the truncated corner is at the upper left. This is DAT2 and is usually numbered TAB9

== SD Card Tabs ==

Solder wires or pin headers to the SD adapter (or directly to the SD card if you are sure of yourself).

Remember, you need pull up resistors on the lines pointed out below, or it won't work. I use 10k ohm to 3.3 volt Vdd for my pull ups.  I happend to have a bag of 10k resistor packs, these work nicely. 

|| Prop Pin || TAB  || SPI function ||  description || Pull Up resistor? ||
|| Px|| tab9 || nc ||  not used in SPI mode || Pull Up resistor optional ||
|| Px|| tab1 || CS ||  Chip Select || Pull Up resistor- YES ||
|| Px|| tab2 || DI/MOSI || description || Pull Up resistor - YES ||
|| P-Vss || tab3 || Vss1 ||  GND ground || Pull Up resistor- no ||
|| P-Vdd || tab4 || Vdd ||  3.3 volts ||Pull Up resistor - (YES) ||
|| Px|| tab5 || Sclk ||  Serial Clock || Pull Up resistor - no ||
|| P-Vss || tab6 || Vss2 ||  GND ground || Pull Up resistor - no ||
|| Px|| tab7 || Do/MISO ||  description || Pull Up resistor - YES ||
|| Px|| tab8 || nc || not used in SPI mode  || Pull Up resistor optional ||

Notice:  If you use a resistor pack for the pull ups, you can connect the Vdd to the common on the resistor pack.  I usually bend up the pins on the resistor pack for the connections that do not take a pull up.  wasting a pins on a resistor pack is cheaper and easier than soldering individual resistors. 


== Spineret (standard) Pinout ==

Spineret was the first board we received that had an SD adapter on it, so we tried to use that as standard. 

|| Prop Pin || TAB  || SPI function ||  description || Pull Up resistor? ||
|| P16|| tab7 || Do/MISO ||  description || Pull Up resistor - YES ||
|| P17|| tab8 || nc || not used in SPI mode  || Pull Up resistor optional ||
|| P18|| tab9 || nc ||  not used in SPI mode || Pull Up resistor optional ||
|| P19|| tab1 || CS ||  Chip Select || Pull Up resistor- YES ||
|| P20|| tab2 || DI/MOSI || description || Pull Up resistor - YES ||
|| P21|| tab5 || Sclk ||  Serial Clock || Pull Up resistor - no ||
|| P-Vdd || tab4 || Vdd ||  3.3 volts ||Pull Up resistor - (YES) ||
|| P-Vss || tab3 || Vss1 ||  GND ground || Pull Up resistor- no ||
|| P-Vss || tab6 || Vss2 ||  GND ground || Pull Up resistor - no ||

== Demoboard ==

The Prop demo board only has  pins 0 through 7 available, so we move the pins accordingly

|| Prop Pin || TAB  || SPI function ||  description || Pull Up resistor? ||
|| P0|| tab7 || Do/MISO ||  description || Pull Up resistor - YES ||
|| P1|| tab8 || nc || not used in SPI mode  || Pull Up resistor optional ||
|| P2|| tab9 || nc ||  not used in SPI mode || Pull Up resistor optional ||
|| P3|| tab1 || CS ||  Chip Select || Pull Up resistor- YES ||
|| P4|| tab2 || DI/MOSI || description || Pull Up resistor - YES ||
|| P5|| tab5 || Sclk ||  Serial Clock || Pull Up resistor - no ||
|| P-Vdd || tab4 || Vdd ||  3.3 volts ||Pull Up resistor - (YES) ||
|| P-Vss || tab3 || Vss1 ||  GND ground || Pull Up resistor- no ||
|| P-Vss || tab6 || Vss2 ||  GND ground || Pull Up resistor - no ||

You don't have to start at pin 0. But you do have to end by pin 7.

== Quickstart ==

The quickstart has a double row of connectors, so we have to alternate pins.  Unfortunately, there are only 4 pins in a row, and we need six.  Do I have to make a special connector for the quickstart, or can we share? 

We can use the unassigned pins 8 through 14 or pins 9 through 15. If we can use all even or all odd pins, we can use the same connector from above on the quickstart. 

Pins 16 and 18 or 17 and 19 are physically connected to LEDs, those are connected to ground. So maybe we should use these.

Pins 4 and 6 or 5 and 7 are connected to resistive pad buttons.  If we don't touch the buttons, maybe these will work.

ALMOST, but no cigar.  We can't plug a regular straight-header-pin-to-adapter hack to the quickstart.  Since the Quickstart has Vin next to Vss, and my conneector is built for Vdd nest to Vss, I can't directly use my standard SD adapter  connector for the quickstart. Should have thought of this first.

No worries, I'll just use a bread board and some jumpers.  pins 8 to 15 are available, we have plenty and some to spare. 

|| Prop Pin || TAB  || SPI function ||  description || Pull Up resistor? ||
|| P08|| tab7 || Do/MISO ||  description || Pull Up resistor - YES ||
|| P09 || tab8 || nc || not used in SPI mode  || Pull Up resistor optional ||
|| P10 || tab9 || nc ||  not used in SPI mode || Pull Up resistor optional ||
|| P11 || tab1 || CS ||  Chip Select || Pull Up resistor- YES ||
|| P12 || tab2 || DI/MOSI || description || Pull Up resistor - YES ||
|| P13 || tab5 || Sclk ||  Serial Clock || Pull Up resistor - no ||
|| P-Vdd || tab4 || Vdd ||  3.3 volts ||Pull Up resistor - (YES) ||
|| P-Vss || tab3 || Vss1 ||  GND ground || Pull Up resistor- no ||
|| P-Vss || tab6 || Vss2 ||  GND ground || Pull Up resistor - no ||


Testing....

NOTE: Quickstart boards do NOT ship with propforth in EEPROM.  This is why I spent the last 20 minutes trying to figure out why it wouldn't boot....


= Load the SD kernel =

In my case the path to the SD kernel is
{{{
C:\Documents and Settings\Braino\My Documents\Go-files\mygo\V5.3\CurrentRelease\PropForthSD
}}}
and the file is
{{{
PropForthSDFastSerialKernel.spin
}}}

This should be the same for v5.03 and 5.0.   The "GO" stuff in the path is an artifact from other testing, and you do not need any Go Language support installed for the SD support to run.

Use the SPIN TOOL to open the  SD kernel source file 
{{{
PropForthSDFastSerialKernel.spin
}}}

EDIT lines '125 through 128' to match your hardware.  This is the prop pins where you put the SD card.  By default, we use 16, 17, 18, 19, 20, 21 per the spineret SD card pin allocation.  Pins 17 and 18 are not used in SPI mode, but we advise keeping the physical connections in place just in case (until there is a valid reason to change). 

I'm using Quickstart with the SD on pins 8, 9, 10, 11, 12, 13.

So I change   
{{{
  dlrS_sd_cs = 19           ' $S_sd_cs forth word
  dlrS_sd_di = 20           ' $S_sd_di forth word
  dlrS_sd_clk = 21          ' $S_sd_clk forth word
  dlrS_sd_do = 16           ' $S_sd_do forth word
}}}
to
{{{
  dlrS_sd_cs  = 11           ' $S_sd_cs forth word
  dlrS_sd_di  = 12           ' $S_sd_di forth word
  dlrS_sd_clk = 13           ' $S_sd_clk forth word
  dlrS_sd_do  =  8           ' $S_sd_do forth word
}}}


into prop EEPROM.  Whe the firmware is loaded, power cycle and start teraterm.

Use the SPIN TOOL to install the SD kernel into prop EEPROM.  Whe the firmware is loaded, power cycle and start teraterm.

= Start Teraterm =

Start teraterm, you should see the propforth command line prompt.

== Load sd_scripts.f ==

In the same directory as above

`C:\Documents and Settings\Braino\My Documents\Go-files\mygo\V5.3\CurrentRelease\PropForthSD`

find two files: 

`GettingStartedPropForthSD.txt`

`sd_scripts.f`

`GettingStartedPropForthSD.txt` is the instructions for running SD.  Read this.  You'd be surprised how many folks don't read it, then ask questions that are answered in the file. 

`sd_scripts.f` initializes the SD card.

To load the sd_scripts.f SD card initialization script:
 # open sd_scripts.f in you favorite editor
 # select all the text in the file (ctl-A)
 # copy all the selected text in the file (ctl-S)
 # In the teraterm window (running the propforth command prompt), paste the file

=== Negative Test Case ===

You might see:

{{{ 
Prop0 Cog6 ok
fl
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
sd_init
Prop0 Cog6 ok

CON:Prop0 Cog5 RESET - last status: 166 UNKNOWN ERROR
}}}

This means:
 # cog 6 was running normally
 # you pasted the source correctly into the terminal (`fl`  is the fast load command)
 # cog 6 gave the input stream to cog 5
 # cog 5 did what ever the script told it to do
 # cog 5ran the `sd_init` routine
 # cog 5 returned control to the console (cog 6)
 # cog 6 displayed an error message
 # 166 is the number of the message, but there isn't an extension that defines the text for this error (this is so new the paint isn't dry)   
 # error 166 mean "SD card not found"

And guess what?  I didn't put the micro SD in the slot yet.  So this is good, we can detect and error if the hardware isn't right.

=== Positive test case ===

This time , put an SD card in the adapter slot. 

Digging around in my desk.... Here's a 4 gig micro SD that says ubuntu 11.4 Natty Narwal.  Don't need that at the moment, so the narwal gets it.

When I power up the quickstart, the firmware tries to autoboot.  Before I can start teraterm, it has done its thing, and has end up in a frozen state.  Perhaps Minnesota?  So I hit the reset button on the Quickstart, and see this message: 

{{{
CON:Prop0 Cog0 RESET - last status: 0 ok

CON:Prop0 Cog1 RESET - last status: 0 ok

CON:Prop0 Cog2 RESET - last status: 0 ok

CON:Prop0 Cog3 RESET - last status: 0 ok

CON:Prop0 Cog4 RESET - last status: 0 ok

CON:Prop0 Cog5 RESET - last status: 0 ok

CON:Prop0 Cog6 RESET - last status: 172 UNKNOWN ERROR

CON:Prop0 Cog5 RESET - last status: 7 LOCK TIMEOUT

Prop0 Cog5 RESET - last status: 7 LOCK TIMEOUT
Prop0 Cog5 ok

}}}

Each time it comes back from 'LOCK TIMEOUT', any character causes another lock.  So, something is not going as expected. Probably it started automatically loading something, that turned out to be garbage, and it didn't like it. 

Looking in the 'GettingStartedPropForthSD.txt' told me I can use the ESC key to disable the autoboot routine.  Maybe that will help?

Hit the reset key, and hold the ESC key while it comes up.....

This time when it comes up, it says 

{{{
CON:Prop0 Cog0 RESET - last status: 0 ok

CON:Prop0 Cog1 RESET - last status: 0 ok

CON:Prop0 Cog2 RESET - last status: 0 ok

CON:Prop0 Cog3 RESET - last status: 0 ok

CON:Prop0 Cog4 RESET - last status: 0 ok

CON:Prop0 Cog5 RESET - last status: 0 ok

CON:Prop0 Cog6 RESET - last status: 0 ok

Prop0 Cog6 RESET - last status: 0 ok
Prop0 Cog6 ok

}}}

and the cursor is advancing across the bottom of the screen.  Bacause I am still holding down the ESC key! 

Release ESC and hit enter a couple times.  SUCCESS! We have the command prompt back!

NOW we can load the initialization script, as before.

Select the contents of `sd_init.f`, and paste it into the teraterm window.

NOW something happens different!

==== FIRST time initialization =====

When the init script runs we see some activity, a slight pause (I'll break the printout below to show that word) and the rest of the scrip.  It goes by pretty fast, and you only get to see it when you initialize a new card, so here it is:

{{{
Prop0 Cog6 ok
fl
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
sd_init
Prop0 Cog5 ok

Prop0 Cog5 ok
1 constant _sysstart
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
: _sd_CrEaTe
sd_cogbuf h80 bounds
do
h20202020 i COG!
loop
h20202F01 dup sd_cogbuf COG!
sd_cogbuf h20 + COG!
h10000 sd_cogbuf h2A + COG!
h81 sd_cogbuf h2B + COG!
over sd_cogbuf h2E + COG!
over sd_cogbuf h2F + COG!
over sd_cogbuf h32 + COG!
sd_cogbuf h33 + COG!
dup h81 + sd_cogbuf h36 + COG!
sd_lock dup sd_blockwrite
_sd_initdir
sd_unlock
;
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
h10000 _sysstart + constant _sysblocks
Prop0 Cog5 ok

Prop0 Cog5 ok
_sd_maxblock L@ constant _usrend
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart _sysblocks _sd_CrEaTe
Prop0 Cog5 ok
_sysstart _sysblocks + _usrend _sd_CrEaTe
}}}

At this point there is a slight delay. The word `_sd_CrEaTe` is executing, and setting up the card. It only takes a few seconds.  When this happens, I usually say, "great, it crashed again, better write a bug report" but before I can get my hand to the rest button, it starts going again. 

The text scrolls by very fast, but remember, the display of the text is the slowest part. Even at 230400 baud.

Any who, the remainder of the text that scroll by is the following:

{{{
Prop0 Cog5 ok
_sysstart _sysblocks _sd_CrEaTe
Prop0 Cog5 ok
_sysstart _sysblocks + _usrend _sd_CrEaTe

Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart sd_mount
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
h2 fwrite .sdcardinfo

SDCard size:Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
_sd_maxblock L@ 2/ _nf C@++
Prop0 Cog5 ok
c" .sdcardinfo" sd_append
Prop0 Cog5 ok
c"  Kbytes~h0D~h0D" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" File System: sys~h0D                      Start Block:" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart _nf C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" ~h0D                        End Block:" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart _sysblocks + _nf C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" ~h0D        File System Size (blocks):" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysblocks _nf C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" ~h0D        File System Size  (bytes):" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysblocks 2/ _nf C@++
Prop0 Cog5 ok
c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c"  Kbytes~h0D~h0D" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
c" File System: usr~h0D                      Start Block:" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart _sysblocks + _nf C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" ~h0D                        End Block:" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok
_usrend _nf C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" ~h0D        File System Size (blocks):" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok
_usrend _sysstart _sysblocks + - _nf C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" ~h0D        File System Size  (bytes):" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_usrend _sysstart _sysblocks + - 2/ _nf C@++
Prop0 Cog5 ok
c" .sdcardinfo" sd_append
Prop0 Cog5 ok
c"  Kbytes~h0D~h0D" C@++ c" .sdcardinfo" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok
h100 fwrite sdboot.f

hA state orC!  c" ~h1B[1A~h1B[20D~h1B[K~h0D~h0D" .cstr

c" sdboot.f  -  initializing~h0D~h0D" .cstr
1 sd_mount

[ifndef mountsys : mountsys sd_init Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart <# # # # # # # # # # # #> C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c"  sd_mount ; ]~h0D" C@++  c" sdboot.f"  sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" \ mountusr ( -- ) mount the user disk~h0D[ifndef mountusr : mountusr sd_init " C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart _sysblocks + <# #s #> C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c"  sd_mount ; ]~h0D"  C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" c~h22 sdboot.f  -  Loading boot.f~h7Eh0D~h7Eh0D~h22 .cstr~h0D~h0D" C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" fload boot.f~h0D" C@++  c" sdboot.f"  sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
c" c~h22 sdboot.f  -  DONE - PropForth Loaded ~h7Eh0D~h7Eh0D~h22 .cstr~h0D~h0D" C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok
c" hA state andnC!~h0D~h0D" C@++ c" sdboot.f" sd_append
Prop0 Cog5 ok

Prop0 Cog5 ok
100 fwrite boot.f
hA state orC!  c" ~h1B[1A~h1B[20D~h1B[K~h0D~h0D" .cstr

c" boot.f  -  initializing~h0D~h0D" .cstr

1 sd_mount

fread .sdcardinfo

c" boot.f  -  DONE~h0D~h0D" .cstr
hA state andnC!

Prop0 Cog5 ok

Prop0 Cog5 ok
mkdir .partion-sys/
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart _sysblocks + sd_mount
Prop0 Cog5 ok

Prop0 Cog5 ok
mkdir .partion-usr/
Prop0 Cog5 ok

Prop0 Cog5 ok
_sysstart sd_mount
Prop0 Cog5 ok

Prop0 Cog5 ok
forget _sysstart
Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog5 ok

Prop0 Cog6 ok


}}}

At this point, we know:

 * The SD card is good
 * The SD slot we made is good
 * The wiring is good
 * The firmware kernel is good
 * The SD driver is good

== second boot ==

OK we ran the init script,  we should have a prop chip with 4 gig of storage that we can pretend is RAM, maybe.  Let's check:

 * hit the reset button on the propboard
 * watch the teraterm display

It says:

{{{

Prop0 Cog6 ok

CON:Prop0 Cog0 RESET - last status: 0 ok

CON:Prop0 Cog1 RESET - last status: 0 ok

CON:Prop0 Cog2 RESET - last status: 0 ok

CON:Prop0 Cog3 RESET - last status: 0 ok

CON:Prop0 Cog4 RESET - last status: 0 ok

CON:Prop0 Cog5 RESET - last status: 0 ok
Prop0 Cog5 ok


sdboot.f  -  initializing

sdboot.f  -  Loading boot.f


boot.f  -  initializing


SDCard size:      3,858,435 Kbytes

File System: sys
                      Start Block:              1
                        End Block:         65,538
        File System Size (blocks):         65,537
        File System Size  (bytes):         32,765 Kbytes

File System: usr
                      Start Block:         65,538
                        End Block:      7,716,864
        File System Size (blocks):      7,651,326
        File System Size  (bytes):      3,825,665 Kbytes

boot.f  -  DONE

Prop0 Cog4 ok

Prop0 Cog4 ok

sdboot.f  -  DONE - PropForth Loaded

Prop0 Cog5 ok

Prop0 Cog5 ok


CON:Prop0 Cog6 RESET - last status: 0 ok

Prop0 Cog6 RESET - last status: 0 ok
Prop0 Cog6 ok

}}}

== sdboot.f ==

sdboot.f is a file that is auto loaded at kernel start.

`SDCard size:      3,858,435 Kbytes` shows its a 4 gig card

`File System: sys` is the propforth system partition. Its about 65 thousand blocks long.  About like my walk to work.  I guess its about 32 meg, or 32 thousand pages of text, if you were to use the forth blocks raw disk sectors as pages.  You don't, you can set these sectors up as files and treat them as files as usual, internal to forth.

One might load propforth development extension script here.  Also perhaps diagnostic extensions.  Maybe even application development experiment. 

`File System: usr` is the user application extension. It starts at the end of the development partition, and goes to the end of the card. 

This is for logging, application data, whatever. At 3.8 gig of storage, its still practically the whole card.


== autoboot.f ==

You can put anything you want in this file.  You should make sure its some thing that you want to execute, maybe your final application, or a list of the development extension you want to load from the SD. If you load a program the makes the system crash, you can use the ESC key during boot to abort the autoload process as before. 

= mounting a partition =

This is little different, this is NOT an OS file system the command is

The command to mount the user partition is:
{{{
mountusr
}}}

The command to mount the system partition is:
{{{
mountsys
}}}

Notice that this is a single word, NOT 'mount system' 

This might be what was messin' you up,  this got me the first couple of time I tried it, I hadn't wrapped my head around it properly. 

= FILES on SD =

To write a source text file to the SD use the 'fwrite' command:

`100 fwrite myfile`

100 is the number of sectors to allocate for the file? (look at the source for fwrite tomorrow?)

To load a file from a mounted SD us `fload` command:

`fload myfile`

to list the files in the SD use `fsls` command:

`fsls`

to continuously write to a log file


D





= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages