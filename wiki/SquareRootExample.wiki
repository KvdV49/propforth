#summary heater's square root routine, converted from C to propforth.

= Some example code for doing squareroot in forth =

There was a discussion about ANSI standard forth and whether forth code was portable across various implementations.  We came away with these examples.

Basically, it seems that forth is not usually COMPLETELY compatible, that is, there are always at least some minor differences. Also, it seems that the minor differences can be identied easily (the words that don't exist in the target get flagged as UNKNOWN IDENTIFIER, etc), and the offending words can easily be replaced with valid words. 

Your mileage may vary.

= heater's squareroot examples =

from http://forums.parallax.com/showthread.php?144414-The-Forth-Dimension.&p=1148471&viewfull=1#post1148471

I think he started in gforth (GNU forth on the PC)

NOTE:  On Propforth values over h_7FFF_FFF decimal 2,147,483,647 are negative.  That is h_8000_000 decimal 2,147,483,648 and above, show up a negative numbers because of the sign bit. Negative numbers are not handled, they make the routine wander off forever.  

{{{
: sqrtiloop
    begin
        dup 0=  if exit then
        swap over or
        swap rot rot 2dup swap <=
        if
            swap over -
            swap rot swap over +
        else
            rot swap over -
        then
        1 rshift
        swap 2 rshift
    again
;


\ Integer square root ( i -- s )
: sqrti
   0 1 30 lshift sqrtiloop drop swap drop                         
;


." Square root of 1000000 = "
1000000 sqrti . cr
}}}

{{{
: sqrtiloop
    begin
        dup 0=                            
                                     ( i s t flag )
        if
            exit
        then
                                     ( i s t ) 


    \ s |= t
        swap                         ( i t s ) 
        over                         ( i t s t )
        or                           ( i t s )                                 
 
        \ if (s <= i)                             
        swap                         ( i s t )
        rot                          ( s t i )
        rot                          ( t i s ) 
        2dup                         ( t i s i s )  
        swap                         ( t i s s i )  
        <=                           ( t i s f ) 
        if
            \ i = i - s
            swap                     ( t s i )   
            over                     ( t s i s )   
            -
                                     ( t s i ) 
            \ s = s + t
            swap                     ( t i s )
            rot                      ( i s t ) 
            swap                     ( i t s ) 
            over                     ( i t s t ) 
            +                        ( i t s )            
        else
            \ s = s - t
            rot                      ( i s t )    
            swap                     ( i t s )    
            over                     ( i t s t )    
            -                        ( i t s )    
        then
        
        \ s = s >> 1
        1 rshift                     ( i t s )           
        \ t = t >> 2   
        swap                         ( i s t )    
        2 rshift                     ( i s t )    
    again
;


\ Integer square root   ( i -- s )
: sqrti
   0                                 ( i s )
   1 30 lshift                       ( i s t )
   sqrtiloop                         ( i s t )
   drop                              ( i s )
   swap                              ( s i )
   drop                              ( s )
;


}}}

= Braino Square Root Example for propforth =

I couldn't figure out what heater was doing, so I just found the first example from google, and converted it to propforth. 

From http://jasonwoof.org/sqrt.fs

tweaked to run on propforth

{{{
: sqrt-closer \ ( square guess -- square guess adjustment) 
              2dup \ take the target and the last guess
              /    \ divide the target by the guess
              over \ get the previous guess
              -    \ subtract the previous guess from the intermediate value
              2    \ divide this  
              /    \ in half, to make the adjustment
;


: sqrt \ ( square -- root )   start with our number on the stack 

       1             \ first guess is 1 
       0             \  first adjustment is zero
       begin 
             +           \ add the previous adjustment to our guess
             sqrt-closer \ target guess - target guess adjustment
      \       st?         \ comment this out when done
             dup         \ test the adjustment
             0=          \ if result not zero do it again
       until             \ if result not zero do it again
       drop           \ get rid of guess as we are done at this point

       nip  \        get rid of old target
       \ .              \ print the result  (instead of nip)
       \ drop           \ get rid of  the old target (instead of nip)            
   ;

: sqrt-test 2000000000 1 do i dup . sqrt . cr loop ;
: test 20 1 do i dup .  cr loop ;

}}}

end of page