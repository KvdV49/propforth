#summary i2c_utility

= Introduction =

This is awesome.  It figures out the addresses of all I2C devices present. 

How cool is that? 

== i2c log ==

{{{

Prop0 Cog6 ok
i2c_detect
     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
00: 00 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: 20 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- 48 -- -- -- -- -- -- --
50: 50 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- 68 -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
i2c_device:5


Prop0 Cog6 ok

00 ADT7410
20 PCF8574
48 ADT7410
50 eeprom
68 MPU6050

}}}



= code =

{{{

fl

{
i2c_utility
PropForth5.5

2014/04/06 14:19:02
}


\ Modified _eewrite ( c1 -- t/f ) write c1 to the eeprom, true if there was an error
\ Received acknowledge from i2c-device during scl is high
\ scl/sda use pull-up resistor at hi
\ clock:400kHz
lockdict create _eewrite forthentry
$C_a_lxasm w, h12C  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WyPW8 l, z1YVPQ0 l, z1rixnd l, z1Sy\C] l, z1[ixne l, z1Sy\C] l, z1bixne l, zfyPO1 l,
z3[yP[K l, z1[ixnd l, z1Sy\C] l, z1[ixne l, z1Sy\C] l, z1YF\Nl l, z1viPR6 l, z1bixne l,
z1Sy\C] l, z1bixnd l, z1SV01X l, z2WyPc7 l, z20iPik l, z3ryPb0 l, z1SV000 l, zW0000 l,
zG0000 l,
freedict


\ _eeread ( t/f -- c1 ) flag should be true is this is the last read
\ scl/sda use pull-up resistor at hi
\ clock:400kHz
lockdict create _eeread forthentry
$C_a_lxasm w, h12D  h113  1- tuck - h9 lshift or here W@ alignl h10 lshift or l,
z2WiPZB l, z2WyPO0 l, z1[ixne l, z2WyPj8 l, z1Sy\Ka l, z1[ixnf l, z1Sy\Ka l, z1XF\Vl l,
znyPO1 l, z1bixnf l, z3[yPnN l, z26VPW0 l, z1rixne l, z1Sy\Ka l, z1[ixnf l, z1Sy\Ka l,
z1bixnf l, z1bixne l, z1Sy\Ka l, z1SV01X l, z2WyPc3 l, z20iPik l, z3ryPb0 l, z1SV000 l,
zW0000 l, zG0000 l,
freedict


: err_msg ." I2C error" ;
\ If error, print message
\ ( n1 -- )   n1:t/f
: err? if err_msg cr then ;

\ Start i2c-commnication 
\ ( -- )
: _eestart
_sdal _sdao              \ Set sda to lo 
_scll _sclo              \ Set scl to lo
;

\ Repeated Start
\ ( -- )
: Sr
_sdai                    \ Release sda 
_scli                    \ Release scl 
\ begin d28 px? until     \ wait until scl is hi
_sdao                    \ Set sda to lo
_sclo                    \ Set sda to lo
;

\ Stop i2c-commnication 
\ ( -- )
: _eestop
_scli                    \ Release scl 
_sdai                    \ Release sda
;

\ Write data to register in i2c_device
\ ( n1 n2 n3 -- t/f )  n1:data  n2:register  n3:slave_address  t/f:true if there was an error
: i2c_wr
\ Start I2C 
_eestart
\ Write slave address[wr], then receive Acknowledge-bit(ACK:Lo  NACK:Hi) 
_eewrite                      \ ( n1 n2 t/f )
\ Write register
swap _eewrite or              \ ( n1 t/f )
\ Write data   
swap _eewrite or              \ ( t/f )   
\ Stop I2C
_eestop 
;

\ Write series data to register in i2c_device
\ ( n1..nn n2 n3 n4 -- t/f )   n1..nn:data  n2:number  n3:register  n4:slave_address   t/f:true if there was an error
: i2c_wr_multi
\ Start I2C 
_eestart
\ Write slave address[wr], then receive Acknowledge-bit(ACK:Lo  NACK:Hi) 
_eewrite                                \ ( n1..nn n2 n3 t/f )
\ Write register                   
swap _eewrite or                        \ ( n1..nn n2 t/f )
swap                                    \ ( n1..nn t/f n2 )
\ Read n2 byte
dup 1 >
if                                      \ ( n1..nn t/f n2 )                 
     0 do                               \ ( n1..nn t/f )
          swap _eewrite or              \ ( n1.. nn t/f ) 
     loop
else                                    \ ( n1 t/f n2 )     
     drop swap _eewrite or              \ ( t/f )
then               
\ Stop I2C
_eestop 
;

\ Read data from register in i2c_device
\ ( n1 n2 -- n3 t/f )  n1:register  n2:slave_address  n3:data  t/f:true if there was an error
: i2c_rd
\ Start I2C 
_eestart
\ Write slave address[wr], then receive Acknowledge-bit(ACK:Lo  NACK:Hi)   
tuck _eewrite                 \ ( n2 n1 t/f )
\ Write register
swap _eewrite or              \ ( n2 t/f )
swap                          \ ( t/f n2 )
\ Start read_process
Sr
\ Write slave address[rd], then receive Acknowledge-bit(ACK:Lo  NACK:Hi)
1 or _eewrite or              \ ( t/f )
\ Read 1byte ,then set sda to Hi(NACK:master->slave)
-1 _eeread             
\ Stop I2C
_eestop                                         
swap                         \ (n3 t/f )
;

\ Read sereis data from series register in i2c_device
\ ( n1 n2 n3 -- n4 . . nn t/f )  n1:number  n2:register  n3:slave_address  n4..nn:series data  t/f:true if there was an error
: i2c_rd_multi
\ Start I2C 
_eestart
\ Write slave address[wr], then receive Acknowledge-bit(ACK:Lo  NACK:Hi)  
tuck _eewrite                 \ ( n1 n3 n2 t/f )
\ Write register
swap _eewrite or              \ ( n1 n3 t/f )
swap                          \ ( n1 t/f n3 )
\ Repeated Start read_process
Sr
\ Write slave address[rd], then receive Acknowledge-bit(ACK:Lo  NACK:Hi)
1 or 
_eewrite or                   \ ( n1 t/f )
\ Read (n1-1)bytes
>r                            \ Push flag  ( n1 )
dup 1 > 
if 
     1 - 0 do 
          0 _eeread           \ ( n4..nn-1 )
     loop
else
     drop
then
\ Read 1byte ,then set sda to Hi(NACK:master->slave)
-1 _eeread                    \ ( n4..nn )
r>                            \ Pop flag   ( n4..nn t/f )
\ Stop I2C
_eestop                                         
;


\ Display connected i2c-device's slave-address
\ ( -- )
: i2c_detect
hex
\ Print lower
."      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F" cr
\ ( n1 n2 ) n1:reserve address 's count n2:i2c_device's count n3:i2c_address
0 0 0 
8 0 do
     \ Print 1-line
     dup .byte h3A emit space           
     d16 0 do
          \ Start I2C 
          _eestart
          \ Write slave address[wr], then receive Acknowledge-bit(ACK:Lo  NACK:Hi)   
          dup i + 1 lshift _eewrite 0=                      
          if                                 \ there is ACK 
               dup i + dup .byte             \ Get slave-addres
               dup 7 > swap h78 < and        \ 0 to 7 and h78 to h7F
               if 
                    swap 1+ swap             \ Count up device (eliminate reserve number)
               else 
                    rot 1+ rot2
               then     
          else 
               ." --" 
          then 
          space 
          \ Stop I2C
          _eestop                                       
     loop
     cr
     \ next line
     d16 +                                                      
loop
drop
decimal
." i2c_device:" . cr  
0> if ." [0 - 7] and [h78 - h7F] are reserve-address" then cr
cr
;

\ When SDA-line is stuck LOW, master should send nine clock-pulse.
\ ( -- )
: bus_clr d10 0 do _scll _sclo _scli loop ;


{
\ -------------------------------------------------------------------
\  Modified _eewrite
\ -------------------------------------------------------------------

\ Modified _eewrite ( c1 -- t/f ) write c1 to the eeprom, true if there was an error
\ Received acknowledge from i2c-device during scl is high
\ scl/sda use pull-up resistor at hi
\ clock:400kHz

fl
build_BootOpt :rasm
		mov     $C_treg1 , # h8
\ --- Start tranmit 8bits
__1
          \ Set data-bit to sda
		test    $C_stTOS , # h80	wz
		muxz    dira , __sda
		\ Wait 88ticks
		jmpret  __delayret , # __delay
		
          \ Set scl to input(Hi)
		andn    dira , __scl
		\ Wait 88ticks
		jmpret  __delayret , # __delay

          \ Set scl to output(lo)
		or      dira , __scl
		
		\ Shift data-bit
		shl     $C_stTOS , # 1
          \ Finish 8bit?
		djnz    $C_treg1 , # __1
\ --- Finish transmit 8bits

          \ Set sda to input(floating)
		andn    dira , __sda
		\ Wait 88ticks
		jmpret  __delayret , # __delay

          \ Set scl to input(Hi)
		andn    dira , __scl
		\ Wait 88ticks
		jmpret  __delayret , # __delay
		\ Input sda from slave,  Read ACK
		test    __sda , ina	wz
		muxnz   $C_stTOS , $C_fLongMask   

          \ Set scl to lo
		or      dira , __scl

		\ Wait 88ticks
		jmpret  __delayret , # __delay
		
		\ Set sda to lo and output
		or      dira , __sda

		jexit

\ this delay makes for a 84ticks on an 80 Mhz prop   [Xtal:5MHz]
__delay
          mov       $C_treg2 , # d71
		add       $C_treg2 , cnt
          waitcnt   $C_treg2 , # 0                               
__delayret
		ret
				
__sda
		h20000000
__scl
		h10000000

;asm _eewrite

\ ------------------------------------------------------------------------------------------
\  Modified _eeread
\ ------------------------------------------------------------------------------------------
\ _eeread ( t/f -- c1 ) flag should be true is this is the last read
\ scl/sda use pull-up resistor at hi
\ clock:400kHz
fl
build_BootOpt :rasm
		mov     $C_treg1 , $C_stTOS 
		mov     $C_stTOS , # 0
          \ Set sda to input(floating)
		andn    dira , __sda
		mov     $C_treg3 , # h8
\ --- Start tranmit 8bits
__1
          \ Wait 1.25usec(100ticks)
		jmpret  __delayret , # __delay
          \ Set scl to input(Hi)
          andn    dira , __scl
          \ Wait 84ticks          
		jmpret  __delayret , # __delay

		test    __sda , ina	wc
		rcl     $C_stTOS , # 1

          \ Set scl to output(lo)
          or      dira , __scl          

		djnz    $C_treg3 , # __1
\ --- Finish transmit 8bits
				          
		cmp     $C_treg1 , # 0 wz
		
          \ Set sda to hi if $C_treg is not 0
		muxz    dira , __sda
          \ Wait 84ticks
		jmpret  __delayret , # __delay

          \ Set scl to input(Hi)
          andn    dira , __scl
          \ Wait 84ticks
		jmpret  __delayret , # __delay

          \ Set scl to output(lo)
	     or      dira , __scl
	     
          \ Set sda to output(lo)
          or      dira , __sda
          \ Wait 84ticks
		jmpret  __delayret , # __delay

		jexit

\ this delay makes for a 80ticks on an 80 Mhz prop   [Xtal:5MHz]
__delay
          mov       $C_treg2 , # d67
		add       $C_treg2 , cnt
          waitcnt   $C_treg2 , # 0                               
__delayret
		ret

__sda
		h20000000
__scl
		h10000000

;asm _eeread
}


}}}