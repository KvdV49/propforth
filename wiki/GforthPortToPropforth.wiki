#summary Porting Gforth source code to Propforth

= Introduction =

Martin_h notes on porting Gforth source code to Propforth

Thanks Martin!

= notes =

FYI Here are my notes on moving from Gforth to Propforth.

Propforth is a dialect of Forth and doesn’t support all of the words you would find in an ANS compliant dialect. This is because the authors of Propforth designed it to straddle the line between a 32 bits Forth (e.g. GForth) and 16 bits version (e.g. AmForth  http://amforth.sourceforge.net/). 

So they didn’t define an implicit storage unit and words like ! and @, or cell and cells are unimplemented as they require one. 

Instead the authors expected users to always specify the storage unit with the L or W prefix.

_editors note: The Cog Ram is 32 bit longs, while Hub Ram and EEPROM 16 bit words.  So we opted to play it same and explicitly state the size every time.  This meant there would be no default cell size untime dteremined by the user, as done in Martin's example that follows__

In practice this means code like the following won’t compile

{{{
variable servo_pins 2 cells allot
1 servo_pin !
}}}
As a user you can either embrace their thinking or rebel. I chose the latter and defined these Gforth compatibility words:

{{{
4 constant cell
: cells cell * ;
: -rot rot rot ;
: ! L! ;
: @ L@ ;
}}}

These words will allow 32 bit Gforth code to compile, although at some loss of efficiency.

_editor's note: The above is exactly what we had in mind  :)_

Another difference is that most Forths have a construct called create does> to allocate storage and define runtime behavior. 

While Propforth has the create word, it is missing the does> keyword. While the authors of Propforth have their reasons for this, this is problematic because does> is used to define arrays as follows:

{{{
\ Used to allocate an array of cells of the desired size passed on stack
: array ( n -- addr )
create
cells \ converts count into size in bytes
here over erase \ clear the buffer and
allot \ allocate space
Does>
swap cells + ; \ run time gives address of cell at index

2 array servo_pins
}}}


You would then use “1 0 servo_pins !” to store 1 in the 0th array element. To work around the absence of does> you can define the storage and the runtime behavior with two words as follows:

{{{
variable servo_pins 2 cells allot
: servo_pin() cells servo_pin + ;
}}}

Now use “1 0 servo_pin() !” does the same as the above code.


_editor's note: propforth's create does not leave an entry in the dictionary by itself (different from other forths).  So the does> would not work in any way that one would expect.  We decide to simply have the user define a separate words for the compile time behavior and the run time behavior. While there is a cost being one definition more work during development, there is an enduring net saving in dictionary space_ 

A few rapid fire differences:

• .s is not supported, use st? to dump the stack instead.

• Recursion via the recurse keyword is not supported.

• Gforth strings are defined using s” hello world” and deposit an address and count on the stack while Propforth uses c” hello world” that creates a string with a count in the first byte. It’s a minor difference, but can trip you up when porting code. 

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages