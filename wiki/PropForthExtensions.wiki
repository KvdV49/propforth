#summary Extensions to the PropForth Kernel
#labels v4.5,v5.0

= Introduction =

These are the !PropForth Extensions.  A section is to be added explaining  each extension listed.  Typically a given application will not need all extensions.  The user/developer chooses the extensions suitable for the application, and only those need to be added.  This saves on memory footprint, and program complexity.  This is roughly analogous to other environments where only the necessary functions are selected at compile time to be compiled into the application; the difference is that in FORTH the user plays a greater role in selecting the functions and at what point a given extension is added. 

 * [PropForthExtensions#Kernel_Extensions Kernel Extensions]
   * [PropForthExtensions#Boot_Kernel Boot Kernel]
   * [PropForthExtensions#Development_Kernel Development Kernel]
 * [PropForthExtensions#EEPROM_Extensions EEPROM Extensions]
    * [PropForthExtensions#EEPROM_READ-WRITE_File_system EEPROM READ-WRITE File system]
    * [PropForthExtensions#EERPOM_READ-Only_File_System EERPOM READ-Only File System]
    * [PropForthExtensions#Temporary_Write_Capability_for_Read_Only_File_System Temporary Write Capability for Read Only File System]
 * [PropForthExtensions#Software_Logic_Analyzer_Extension Software Logic Analyzer Extension]
 * [PropForthExtensions#Prop_Assembler_Extension Prop Assembler Extension]
 * [PropForthExtensions#servo_extension servo extension]
 * [PropForthExtensions#Auxiliary_Serial_Terminal_Extension Auxiliary Serial Terminal Extension]
 * [PropForthExtensions#buffered_I/O_extension buffered I/O extension]
 * [PropForthExtensions#case_statement_extensions case statement extensions]
 * [PropForthExtensions#Fast-Hartley_Transform_(FHT)_extension Fast-Hartley Transform (FHT) extension]
 * [PropForthExtensions#OnBoot_Extension_(Change_Boot-Time behavior) OnBoot Extension (Change Boot-Time behavior)]
 * [PropForthExtensions#Optimizer_Extension Optimizer Extension]
 * [PropForthExtensions#Peep-hole_Assembler_Extension Peep-hole Assembler Extension]
 * [PropForthExtensions#Disassembler_Extension Disassembler Extension]
 * [PropForthExtensions#Secure_Digital_Card_(SD)_Extensions Secure Digital Card (SD) Extensions]
 * [PropForthExtensions#Spinneret_Extensions Spinneret Extensions]
   * [PropForthExtensions#IP_Extension IP Extension]
   * [PropForthExtensions#Telnet_Server_Extension Telnet Server Extension]
   * [PropForthExtensions#NTP_Client_Extensions NTP Client Extensions]
   * [PropForthExtensions#HTTP_Server_Extension HTTP Server Extension]
 * [PropForthExtensions#Real_Time_Clock_(RTC)_Extensions Real Time Clock (RTC) Extensions]
 * [PropForthExtensions#ROM-Less_Extension ROM-Less Extension]
 * [PropForthExtensions#MultiChannel_High_Speed_Synchronous_Serial_Channel_(MCS)_Extension MultiChannel High Speed Synchronous Serial Channel (MCS) Extension]
 * [PropForthExtensions#MultiProp_Extension MultiProp Extension]

* These extensions exist but have not been brought forward to the current release *
 
 * [PropForthExtensions#VGA_Extensions VGA Extensions]
 * [PropForthExtensions#aarez aarez]

* These extensions exist but have not been added to the download archive (note please add more hours to the day) *

 * [PropForthExtensions#Multi-Line Character_LCD_Panel_Extension Multi-Line Character LCD Panel Extension] (caskaz)
 * [PropForthExtensions#Floating_Point_Coprocessor_(FPU)_Extension Floating Point Coprocessor (FPU) Extension] (nglordi)
 * [PropForthExtensions#Analog_Computer_Simulator Analog Computer Simulator] (nglordi)

* The extensions are on the list but have not seen any code presented to the public.  As you can see, most extensions beyond the kernel are only plans at this point (20110710).  When the kernel is complete, adding support for a given hardware should be a simple matter of reading the datasheet and writing the driver. *

 * [PropForthExtensions#Electronic_Speed_Controller_(ESC)_Extension Electronic Speed Controller (ESC) Extension]
 * [PropForthExtensions#Stepper_Motor_Extension Stepper Motor Extension]
 * [PropForthExtensions#RCTime_Extension RCTime Extension]
 * [PropForthExtensions#GPS_Extension GPS Extension]
 * [PropForthExtensions#Accelerometer_Extension Accelerometer Extension]
 * [PropForthExtensions#Gas_Sensor_Extension Gas Sensor Extension]
 * [PropForthExtensions#Gyro_Extension Gyro Extension]
 * [PropForthExtensions#Pressure_Sensor_Extension Pressure Sensor Extension]
 * [PropForthExtensions#PING))_Extension PING)) Extension]
 * [PropForthExtensions#Xband_Motion_Extension Xband Motion Extension]
 * [PropForthExtensions#Load_Sensor_Extension Load Sensor Extension]
 * [PropForthExtensions#A/D_Extensions A/D Extensions]
 * [PropForthExtensions#D/A_extension D/A extension]

----

* The documentation is to include a section for each heading above.  New Sections will be added as they are completed and/or available. *

For each section, add archive directory, file name, regression test ID.

= Kernel Extensions =

The user/developer is encouraged to alter/modify the forth kernel according to application/project needs.  While any alternation are permitted (you can do whatever you want), the further you go from the release, the more difficult it becomes to diagnose issues and provide support.  

Usually, the kernel is left intact, a set of extensions are selected, and an application built on top of that.  

The other extreme is the basic kernel is reworked and compile from scratch, and everything on top of it is custom.  

The former case is easier to support, the latter case is usually less than easy to even get handle on what's what. 

  == Boot Kernel ==

  The Boot Kernel is the bare Forth Kernel.  Sometimes the bare kernel is defined as the smallest unit of Forth that can read an write memory.  In PropForth, the bare kernel is defined as the smallest unit that is able to re-generate the !Propforth.spin file. 

 The Boot Kernel is generally used AFTER development is complete (all the applications code is finalized).  This is typically in stand alone turnkey applications that do NOT need the interactive forth command prompt included in the final application. 
  
  == Development Kernel ==

  The development kernel is an interactive command line interface to the !PropForth kernel.  It contains developer extensions that are most commonly used in experiments and application development.  For example, the following words (forth routines) are included by default to aid in development:

  * words - display all the words (forth routines) currently in the forth dictionary
  * st? - displays the contents of the stack, 32bit longs in hex
  * decimal - converts the cogs number base to decimal
  * (add more examples here) 

  Also, sparse and verbose diagnostic messages are included for common functions.   Examples are:

  * cogs reset messages   
  * stack underflow messages
  * stack overflow messages
  * divide by zero messages

  Many internal functions do NOT include error code displays by default, handling these are the responsibility of the developer.
 
  * Memory range violations
  
  Best practice is to write extensions such that they operate in the development kernel, but do not require development kernel functions.  This way, extension can be used with the BOOT KERNEL in turnkey final applications (that do not include the forth development environment). 

  Extensions that are for development should be identified as * development extensions * and dependencies noted.  The reason is that is development and final extensions are mixed during development, there is a risk that something will break when the app is finalized. Generally, there is little time for these error at the end of the project, it is best to address this earlier when their is sufficient time to understand and correct problems. 

=  EEPROM Extensions =

The EEPROM is one of the few pieces of external hardware required by a forth system.  The default kernels provide support for reading and writing EEPROM as individual bytes, and as pages (see datasheet).  

Currently the Demo Board comes stock with a 32k EEPROM, which is entirely used to hold the prop boot image.  This minimum 32KEEPROM cannot be used to store additional data on a prop application that is to be rebooted (writing to EEPROM will step on the boot image and that causes problems).  The prop protoboard and most other include stock or upgradeable 64k EEPROM.  The additional storage can be used to store additional data beyond the boot image.  !PropForth includes extensions to use the additional EEPROM as a rudimentary "file storage system". 

    == EEPROM READ-WRITE File system ==

  The Read-Write File system allows the developer to put files into EEPROM memory and access them.      The EEPROM file system allow read, write, delete of text files and data.

    ==  EEPROM READ-Only File System ==

  After the EEPROM memory is loaded, often it is desirable to "protect" the files in EEPROM memory. Loading the lower 32k with a kernel and READ-ONLY EEPROM file system gives a degree of confidence that the EEPROM image will not be affected by inadvertent file operations.  HOWEVER, since the default kernel does have support to modify individual byte/pages of EEPROM, the possibility remains (which usually means you have a bug in your code). 

    == Temporary Write Capability for Read Only File System ==

  During development, it is often necessary to modify the contents of the READ ONLY files system until it becomes stable.  In this case, usually the READ-Only files extensions are added to the kernel, and the kernel image is saved to prop lower 32k (saveforth).  The temporary write extensional are added to the dictionary, the files are written, and the prop is rebooted.  This allow changes to the READ Only file system contents in a more controlled manner.  

= Software Logic Analyzer Extension =

The software Logic Analyzer (LAC) is is a tool for sampling and displaying the state of the Propeller chips 32 I/O pins.  

The sample rate is controlled by setting the LAC props sample frequency. 

There are three main LAC configurations:


 * Sample at every 1 clock to COG memory using 4 cogs 
 * Sample every 4 clocks minimum to cog memory using 1 cog 
 * Sample every 40+ clocks to HUB memory using 1 cog 

Sampling to cog memory is faster, but only allows 2K max of data sampling.  Using 4 cogs, samples can be taken at clock speed, but the cog memory fills up quickly.

Sampling to Hub memory is slower,  maximum 2 million sample per second;  but allows a maximum of 32K of sample data.

Sampling may trigger on rising edge, falling edge, or middle of clock.

LAC may be configured for sampling to trigger based on a pin state.

LAC may be configured for sampling to trigger based on a complex set of pin states. 

= Prop Assembler Extension =

The prop assembler is used to examine the assembler level code generated by the forth compile for forth routine.  The assembler routine can be extracted and optimized, and the optimized code loaded directly into cog memory as a sequence of bytes (grouped in longs) for fast execution.  

The method for doing this is changing from version 4.x to v5.x.

Full details will be supplied in version 5.0 when released.

= servo extension =

The servo extensions use to cog internal counters (ctra, ctrb) to generate servo control pulses.  Recall that hobby servos use a control pulse every 20 milliseconds of 0.5 to 2.5 milliseconds, with 1.5 ms pulse representing "center".  Using 2.5 ms pulse as maximum, a single ctr can control 8 servos.  One cog can control 18 servo (8 each on counters A and B), so two cogs could control 32 servos.  However, 32 servos would consume all 32 IO pins, so additional hardware would be needed.  Since this is a simple driver, support is left as 32 servos on 2 cogs, and the user can modify this as the application hardware requires. 

Cheap hobby servos have been found to operate less than 180 degrees of swing, and generally cannot go all the way to 0.5 ms and 2.5 ms positions.  By default, the limits have been set back a bit.  At least one user "hit the stops" during the calibration routine (one time too many with too much voltage) and broke through the stops. (Thus modifying the servo into a continuous rotation servo by accident).

Caution: Users are encourages to change the limits and defaults when calibrating servos, be aware you can command it to do thing is might not like.  You have been warned. (Queue mad scientist laugh: Muhoohahahaha!)

= Auxiliary Serial Terminal Extension =

Any I/O pin can be configured as an asynchronous serial port.  See the snet.f extension.  The user is responsible for level shifting (MAX232 etc) if needed.  A 3.3 volt micro I/O pin can be connected to another 3.3 volt micro I/O pin via a 220 ohm resistor as shown in the examples.  The 220 ohm resistor is not needed in most cases but is included in case a software error causes one micro to drive it's end high when the other micro is driving it's end low. 

= buffered I/O extension =

  (from the file comments) iobuf buffers up to 128 characters in an io channel, very useful when you want to run a series of synchronous commands asynchronously

  Normally, the PAD character input buffer is 80 characters.  Greater than 80 character in a single line causes a buffer overrun and characters are lost.  

  (Does this need a tutorial or example?)

= case statement extensions =

The case extension demo compares the use defining new immediate words for case: 

   {{{ case ... of ... endof }}}

versus using a construct that does the same thing with existing words:

   {{{ over ... if ... else  }}}

= Fast-Hartley Transform (FHT) extension =

Nick Lordi shares his Fast Hartley Transform with us.   This is like the Fast Fourier Transform (FFT) difference being it does not use complex numbers (real+imaginary).  Also it uses scaled integer (very usual in forth) instead of float.  

Fast Hartley Transform is a nice fit with forth on a micro controller.

Consider using FHT where FFT is asked for in non-micro controller applications.

  (check with Nick if this is stated properly)

----


= !OnBoot Extension (Change Boot-Time behavior) =

Change the boot time behavior of the `onboot` function. 

`onbold` is the "old definition of onboot" (Sal likes to to make short, easy to type but hard to remember labels; versus long names which are harder to type but easy to tell what it does). 

This function causes an automatic boot script to run, and allow the user to hit the escape key to stop the boot script.  Very handy in development with complex setup that sometimes need to be tweaked.

= Optimizer Extension =

Functions used in assembler optimization.  Needs to be re-examined in v5.0, possibly a new tutorial.

= Peep-hole Assembler Extension =

This is the name of the optimization method to be used in v5.0. It many be the same as Optimizer.f

= Disassembler Extension =

(what goes here?)

= Secure Digital Card (SD) Extensions =

The SD extensions are the focus of the v5.0 development model.  The Secure Digital card provides a large chunk of solid state memory.  The memory is used as mass storage, like a hard disk.  It also is used as expanded memory, like a swap file.  

To maximize speed, a traditional forth "blocks" file system is implemented for SD.  One SD card is accessed at a time.  One partition is accessed at a time.  One file is open at a time.  The last file accesses is the current file until explicitly set otherwise.  It is the user's responsibility to keep track of who is looking at what file.

To reduce overhead of dictionary footprint and impact to execution speed, FAT support is not included by default.  The SD card is treated as "internal to forth".  An interaction with the SD card is done through the forth interface.  Full FAT support for SD may be added later (when implemented by a user) but is not in the kernel development path at this time. 

At present, SPI is the transfer mode implemented. Users may opt to implement there own 1 bit or four bit transfers.  The current scheme is very fast.  The transfer rate is (....).  However, the transfer is serial and large transfer can take significant time.  It is the user's responsibility to structure the application to best use the memory and transfer abilities of the system, and adjust as needed.

=  Spinneret Extensions =

The Parallax Propeller Spinneret is the (planned) basis of the new regression test bed.  The Spinneret allow up to four concurrent Telnet sessions each running a forth interpreter, in addition to the serial terminal interface.  This means the Spinneret can allow a development window into a running system _without affecting the running system_. This is kind of a cool thing, which could potentially find some use.   

  ==  IP Extension ==

  The IP extensions allow the Spinneret to exist on a Ethernet network.  The user is responsible for configuring the network parameters as described in ip_config.f

  == Telnet Server Extension ==

  The telnet server extension allows the Spinneret run up to four concurrent Telnet sessions each running a forth interpreter, in addition to the serial terminal interface. 

  == NTP Client Extensions ==

  The NTP client permits time synchronization with an NTP server over internet.  The local timezone must be specified by the user, or else you end up in Vancouver.  Time may be specified in local time or UTC. 

  == HTTP Server Extension ==

  The HTTP serve extensions allow the Spinneret to host web pages.  The HTTP pages can execute forth scripts. This allows functionality perhaps in some ways similar to java without a full java implementation. 

  == Real Time Clock (RTC) Extensions ==

  The default RTC driver is for the real time clock on the Spinneret.  Support includes setting the clock, and displaying the clock in human readable form.

= ROM-Less Extension =

  The ROM-less extension allow one prop to emulate ROM for another (slave) prop.  This way, a single master can boot additional props without needing additional hardware beyond the props themselves.

= !MultiChannel High Speed Synchronous Serial Channel (MCS) Extension =

  The High Speed Multi Channel Synchronous Serial includes the transfer protocol.  One cog is used for bi-directional communication with a cog on another prop chip.  (Can be on the same prop chip for loop back tests).   Each cog can support eight channels.  MCS transmits and receives continuous stream of 96 bit packets.   The user/application drops a string of text onto the channel, and the protocol sends it, transparent tot he user/applications.  Very nice!

= !MultiProp Extension =

  The !MultiProp extension combine the ROM-less slave and the MCS.  Additional props added to a MASTER become resources available to the MASTER.  Three resistors and one capacitor are required on the seven connections between the master and each slave.  The user must account for additional time needed for transfer on the MCS.  

The MASTER has cog7 reserved for serial communications, and cog6 reserved for the forth command line interface, leaving six cogs (cogs 0-5) available for applications.  MCS consumes 1 cog and 2 I/O pins.  
This leaves 5 free cogs on the master, and 7 free cogs on the slave.
Master + 1 Slave yields 12 free cogs (in addition to the forth propmt on copg6).  Adding another slave gives 18 (11+7) free cogs. Pins are 28 (master) + 30 (slave1) + 30 (slave 2)for a total of 88. 

There has not been a complete analysis of available cog and hub memory as the kernel optimization has not be completed yet.  To date there are 179 cog long free after the development kernel is loaded.

----


* These extensions exist but have not been brought forward to the current release* 
 
= VGA Extensions =

  The VGA function require special treatment.  Due to special hardware (the VGA resistor network) and timing (and front porch lines, etc) the VGA support is handled differently than other extensions. 

  The High Resolution VGA as found in the v3.6 Jupiter ACE High Resolution is added directly to the propforth.spin file.  This requires special porting to v5.0

  The Low Resolution VGA (!JupiterACE.f extension) also requires special porting but is not added to the propforth.spin file, it is handled as a forth code extension.  This is targeted for v5.0

= aarez=

  Add other functions to be brought forward here. 

----

* These extensions exist but have not been added to the download archive (note please add more hours to the day) *

= !Multi-Line Character LCD Panel Extension = 

(caskaz)

Caskaz has produced support for LCD modules based on the Hitachi xxxx.

This requires additional hardware that I have not built yet, so I have not tested it or added it to the package yet.

= Floating Point Coprocessor (FPU) Extension] = 

(nglordi)

Nick Lordi has produced support for the xxx Floating point hardware coprocessor.

This requires additional hardware that I have not built yet, so I have not tested it or added it to the package yet.

= Analog Computer Simulator = (nglordi)

Nick Lordi has produced support for an analog computer simulator.  This is a little beyond me at this time so I have not had a a chance to use it yet, and have not added it to the package yet. 

----

The extensions are on the list but have not seen any code presented to the public.  As you can see, most extensions beyond the kernel are only plans at this point (20110710).  When the kernel is complete, adding support for a given hardware should be a simple matter of reading the datasheet and writing the driver (should be, we'll see).  Users are encouraged to contribute to these when developed to their projects.  Contributed code will be added to the download archive. 

= Electronic Speed Controller (ESC) Extension =

I have a hobby RC car ESC that I plan to use for Robo Magelan.

= Stepper Motor Extension =

Stepper motor is planned for a forth driver for CNC (mill, 3D printer, etc)

= RCTime Extension =

Planned for a sensor glove project

= GPS Extension =

Forth support for GPS for the Robo Magelan
GPS device is:

= Accelerometer Extension =

Forth support for Accelerometer
Accelerometer device is:

= Gas Sensor Extension =

Forth support for Gas Sensor
Gas Sensor device is:

= Gyro Extension= 
= Pressure Sensor Extension =
= PING)) Extension =
= !Xband Motion Extension =
= Load Sensor Extension =
= A/D Extensions =
= D/A extension =


----
Add your content here.


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages