#summary Setup PropForth 6.0 prototype. For PropForth Team only, still in development
#labels PF6.0

<wiki:toc max_depth="9" />

= Introduction =

These are the instructions for setting up PropForth 6.0 on a windows PC.

PropForth 6.0 is available to team members.  Contact braino if you want a copy of the zip file.  This is not ready for public release. 

-----

= Windows PC =

For the time being, windows PC is required. We need PROPELLANT to compile the SPIN source files.  Linux support will be included as the tools become available. 

-----

= Set Up GO language =

Set up Go Language according to the instructions.

If you are upgrading from a previous configuration (e.g. from PropForth 5.5) 

In START -> Settings -> Control Panel -> System:
i
Advanced -> Environment Variables -> System Variables:

Edit or create the environment variable as follows.

== HOME ==

Create an environment variable HOME.  If there was an environment variable HOME in the USER VARIABLES section (I  think this was per the pf5.5 instructions), remove the definittion from USER VARAIBLES and create a HOME environment variable in System Variable. 

HOME is the location of the Go source files.  My original path may have been created by the Go install, it was in My Documents and had a crazy long path.  These tend to choke if they are too long, so I made my Propforth directory 

C:\PropForth6.0

and the therefore the definition for HOME is

{{{
HOME  C:\PropForth6.0\
}}}

Simply create this directory of C:, and unzip the 'PropForth' 6.0 archive.

== GOROOT ==

GOROOT is the location of the GO language source files. 

Minie is instlled at 
i
C:\go

so the definition for the GOROOT environment variable is

{{{
GOROOT C:\go
}}}

== PATH ==

The PATH varriable need to include the path to the GO executatbles.  These are in 

C:\go\bin on my rig.  

{{{
PATH %systemroot%\system32\; < a bunch of other junk> ; C:\go\bin
}}}

-----

= Unzip 2013-xx-xx-mygozip.file =

Our email won't let us send executable files.  So we renamed the zip archive from 

2013-12-15-mygo.zip  

to

2013-12-15-mygozip.file

and we were able to send this via email.  Simply rename this file back from 

2013-12-22--07_00mygozip.file ~~2013-12-15-mygozip.file~~

to

2013-12-22--07_00mygo.zip ~~2013-12-15-mygo.zip~~

Extract the contents of this file to youur newly created 

C:\PropForth6.0

directory

-----

= Run goshell.bat =

Navigate to the Propforth 6.0 directory. 

Look at the contents of goshell.bat with MORE or using a text editor such as notepad, etc.

Notice the line 

{{{
 set PROPFLOWCONTROL=1
}}}

FLOWCONTROL MUST BE ON for the build process.  You can change it so flow control is OFF for other purposes, but you would have to use fl to loading source code files.  So leave flow control on for now, we'll cover turning it off and defining fl elsewhere if it comes up (it won't).

Double click goshell.bat to run the configuration script

------

= Test the setup =

The first time through, expect to have to futz with the environment variables.

Also expect to have to recompile a couple programs, this is fairly simple and painless, and only needs to be done once. 

== TEST GO ==

From the command prompt (after running goshell.bat) type go:

{{{
Go is a tool for managing Go Source Code

...
}}}

You should see the 20 lines or so of go prompt.  If you see this Go is set up.  Procede to the next step, of go back nad futz with go installation.

=== goDISTRIBUTEDbinaries ===

C:\Propforth6\mygo\goDISTRIBUTEDbinaries

has the distributed binaries.   There are precompiled for windows machines.

If you have a windows 32 bit or windows 64 (AMD64) bit machine, you can copy the goDISTRIBUTEDbinaries from either 

windows_386

or 

windows_amd64

to

C:\Propforth6\mygo\bin



== Test goterm ==

From the command prompt (after running goshell.bat) type goterm:

You should see the page or so of usage instructions for goterm.  If not (only the first time), recompile goterm.  (By default, the archive is compiled for Sal's 64 bit machine.  If you have a cheap old 32 bit machine 
like me, we recompile). 


=== recompile goterm ===

CD to  C:\PropForth6.0\mygo\pkg\windows_386

{{{
cd C:\PropForth6.0\mygo\pkg\windows_386
}}}

there should be three or fou files that end in .a

Delete all the files there.  

From the command prompt window where goshell.bat was run type:

{{{
go install goterm
}}}

The should be no error message, or any message of any kind, and the prompt should return a few seconds later (or immediately if you have a fast machine). 

Test goterm as above. 

{{{
C:\PropForthv6.0\mygo>goterm
error: %!s(<nil>)
usage: goterm [ipaddr:port | com_port baud flowcontrol[0|1]] [commands]*

Commands - blank lines ignored, buffered input hit <ENTER>, ${environmet_variable} is expanded if defined
Environment variables in the form $XXX are translated to hXXX by SXW (where XXX are valid forth hex characters including _)

...
}}}

If you see the goterm usage instructions, the goterm program is properly compiled.

= Install pF6.0 BootOptimizeKernel.spin =

BootOptimizeKernel.spin

= load PF6.0 boot kernel =

navigate to 

{{{
C:\PropForthv6.0\mygo\V6.0\kernels\MAKE\results\outputFiles
}}}

and click on 

{{{
BootOptimizeKernel.spin
}}}

and load BootOptimizeKernel.spin using the proptool.

Remember, if it say comportnot found, you left teraterm running on the comport. Close teraterm first, then load the kernel using proptool.



== GOPROXYTERM ==

GoProxyterm is the new bit in PropForth 6.0

It uses properly implemented flow control.  This eliminated the need for the fl (fastload) word.  Now, we can use ANY PC capabile of 230400 baud on the serial port. if the PC is slow, the build process will wait.  We no long have to deal with overun on source load. :0

compile goproxyterm.  From the command prompt window where goshell.bat was run type:

{{{
go install goproxyterm
}}}

As withgoterm, the command prompt should return almost immediately with no error message.

=== Test GOPROXYTERM ===

From the command prompt window where goshell.bat was run type:

{{{
goproxyterm
}}}

You shoud\ld see:

{{{
C:\PropForthv6.0\mygo>goproxyterm
Starting: goproxyterm  0 0 100 200 0
2013-12-15 14:43:05.255972 -0600 CST Using 2 CPUs
2013-12-15 14:43:05.255972 -0600 CST error: Incorrect number of arguments
usage: goproxyterm comPort baud rawPort telnetPort debug[0-3]

C:\PropForthv6.0\mygo>
}}}

Spiffy!  OK, this is somethingwe just caught, there is a copy paste in the goproxyterm instructions. it says telnetprot is the fouth arguement. This is not so, and have been corrected for the next iteration.  The telnet port is NOT included as an arguement, it is automatically assumed to be rawport+100.  There is also a debug port which is automatically rawport + 200. Anyway the instruction should look like this:
{{{
usage: goproxyterm comPort baud rawPort debug[0-3]
}}}

Assuming we are using com22 (I have a lot of USB serial devices), we always use 230400 buad these days, we usually use 3000 as rawport, and we want debug on max so we can see everything for the time being.  So we would use:

{{{
goproxyterm com22 230400 3000 3
}}}

This of course is still from the window where goshell.bat was run.

If everything is finally setup, you should seesomething like:

{{{
C:\PropForthv6.0\mygo>goproxyterm com22 230400 3000 3
Starting: goproxyterm com22 230400 3000 3100 3200 3
2013-12-15 14:56:32.427847 -0600 CST Using 2 CPUs
Started:  goproxyterm com22 230400 Raw:3000 Telnet:3100 Debug:3200 3
        [0[1]{02}]
2013-12-15 14:56:32.490347 -0600 CST Listening on 127.0.0.1:3000
2013-12-15 14:56:32.505972 -0600 CST Listening on 192.168.0.235:3000
2013-12-15 14:56:32.505972 -0600 CST Listening on 127.0.0.1:3100
2013-12-15 14:56:32.521597 -0600 CST Listening on 192.168.0.235:3100
2013-12-15 14:56:32.521597 -0600 CST Listening on 127.0.0.1:3200
2013-12-15 14:56:32.521597 -0600 CST Listening on 192.168.0.235:3200
2013-12-15 14:56:32.521597 -0600 CST READY

}}}

Your rig is set up and ready to go.

== 20131221 Note ==

In prototype from 20131221 (2013-12-22--07_00mygozip.file) 

 * copy from C:\PropForthv6.0\mygo\goDISTRIBUTEDbinaries
 * to C:\PropForthv6.0\mygo\bin 

I have 32 bit rig, so I used C:\PropForthv6.0\mygo\goDISTRIBUTEDbinaries\windows_386

Go knows what version it is, so we don't have to recompile. (I don't know, it just works)

= TERATERM local host =

Now we can talk to the propforth command promt using teraterm.

The settings for teraterm are different now that we use flow control.

Start teraterm. 

Connect to the prop using File -> new connection -> TCP/IP ->  Host: 'localhost'

Recall that goproxyterm is already talking on the USB serial virtual comport (com22 in my case).

Note: if you tyr to connect to loacal host and t says connnection refused, then goproxyterm is notlistening.  Close a bunch of windows, rerun goproxyterm with the proper parameters, andtry again after youget the "Listening" message.

NOTiCE that in Teraterm SETUP -> TERMINAL 

must be changed to CR+LF now.

SAVE this in the teraterm default SETUP -> SAVE SETUP ... 

TERATERM.INI

-----

= Test PF6.0 =

PF6.0 is a VERY MINIMAL dictionaryat this time. There is no "words" commnd (with formating, but the is wl for "words list".

type in wl to see the list of forth words

{{{
wl
}}}

Notice that the goproxyterm window also displays the character and additional diagnostics as the words list scrolls by.

= multitasking kernel =

OK, this is way cool.  Load the multitasking kernel;

Navigate to 

{{{
C:\PropForthv6.0\mygo\V6.0\kernels\MAKE\results\outputFiles
}}}

and load the multitsking tool with the proptool:
{{{
mpKernel.spin
}}}

run goproxyterm again as above. In my case

{{{
goproxyterm com22 230400 3000 3
}}}

Connect with teraterm as above, localhost port 3100

use wl to see the minimal word list.

{{{
wl

}}}

== differences ==

In addition to load balanced multitasking, the pF kernel has some differences.

 * The kernel shrunk to 255 longs including stacks.
 * More words are optimized in assembler.
 * the base kernel is slow, number conversion gets optimized in assembler, the optimized kernels are much faster.
 * all the kernels are generated from scratch.  We start with the high level forth souce, and create a base kernel. The base kernel creates the next optimized kernel.
 * the base kernel takes about 15 minutes to build.
 * final optimized kernel takes about 2 minutes to build.
 * the total build time, from first base kernel to final  optimized kernel, is about 37 minutes.

==  the multitasker ==

OK, I got a little exited at this point, and my notes are a little sketchy.

** Remember that goproxyterm must be running on the goshell.bat command line, and we are connected on teraterm to TCP/IP localhost. **

run the mpMon word, ths word is built into themp kernel:

{{{
 MPF0 Cog6 ok
mpMon
lag(us):: max avg: 307492 108 slices/s:: min avg: 3 9241

word_name        dataname:addr mpST maxT(us)    in                in2               out               out2

      mpGC_x       mpGC_d:17500 228 73
     mpMon_x      mpMon_d:17432 228 111

 MPF0 Cog6 ok

}}}

Notice the MP kernel propmt is now MPF0

mpMon is a SNAPSHOT of the machine when it executed.

mpMon tells the MAXIUM and AVERAGE number of slices to get to each task, this time around.

Highlights of the multitasker:

  * mpGC is the multiprop GarageCollector task
  * mpMon is the multirop monitoring tsk.
  * mpST is the multipropstack frame. Each task has to leave the stack exactly as it found it. 
  * each task executes once, then goes back in the queue
  * the next free cog gets the next task from the queue and executes it. Tasks are not assigned a specific cog (except the serial cog for now)
  * when the cogs finishes the task, it goes back in the pool.
  * If a cog gets a slow task (like user keyboard input or writing to SD) that cogs is not not available in the pool for a long time (maybe 100 ms).  The pool processing capacity is diminished by 1/7th.  

== TEST the multitasker ==


navigate to:
{{{
C:\PropForthv6.0\mygo\V6.0\kernels\MAKE\src\optimize\mp
}}}

find *mptest.f*

paste in the whole thing into the teraterm window, we don't need fl

bottom of file find in the comments paste in:

{{{
1 gc

initW

w+

mpMon mpRes

10 10 send 1000 delms mpMon
-10 10 send 1000 delms mpMon

1 gc 5 gc 10 gc 100 gc
}}}

this is the multiprocessor test, it takes a while. 

scroll back up,
 1 gc turn garabeg collection off for 1 ms for debug, then turn it back on.
 
 initw defines 128 tsks, input to a task, out to a task,
 so the output of one task goes into the input of the next task. So it links the bunch of tasks together. 

 w+ adds 128 (0 to 127) tasks to background processing. 
 
 now mpMon should show lots of tasks in background.
 
 inout 128 into q1

So, on mine, it says 696 micro seconds lag. That means if we will hit each task once every 696 micro seconds.  If a task needed to be handled every 500 microseconds, we would be late. But if we only only need to monitor it every 1200 microseconds, we have plenty of time.  In this case we have 128 tasks, ifwe only have one task it would be 696/128, we culd service the task every38 micro seconds.  So we have to make sure we have sufficient time for the nuber of task and our time window..  

HOW often do we need to monitor a pin?  

If we only need to to look at it every 1700 uS we will be fine. till we run out of slots, we can add about 128 slots.
number is variable, as many free cogs, thats how many tasks are running all the time. 
six (or seven) cogs are watching the queue, and it takes about 1700 uS for them to get back around to a given task. 
{{{
-10 10 send 1000 delms mpMon
}}}
send it through, terminal at end.
{{{
1 gc 5 gc 10 gc 100 gc
}}}
allows garbage coolector to clear out tasks'

mpST at zero, means it done processing and terminated, but still in queue,
garbage collector will take it out of the queue,

next time fewer in queue

then ll gone.

garabage collector runs in background.  looks for finished tasks, takes them out of queue.
takes time, but is nice as long as we're not near limit.

LOGGING: 20 or 30 things. start background tasks doing logging.
the only we g=worry about, don't over load, and am I getting suffiecent performance,
then everything just runs, gets attention every once in a while, and 
once in a while it 1.78ms for 128 tasks. 

7 cogs, 128 tasks. worst case 1.7 ms.  One cog, write to SD once in a while. Pull one cog for a long operation.
while cog is running, only 6 cogs running slow it slows down, but only by 1/7  
Long time is like 100 ms.   then it goes back to max.

First thing we run out of memory
with 128 tasks, we used up most of the memory

{{{
here W@ .
30908  MPF0 Cog6 ok
}}}

This is the max we can get out of a prop.

EX Most stuff has been 20-30 tasks for calculation and advanced control. Works well with 20-30 tasks
since April.  
If we get a prop with more memory, we are good to go.

_sorry, the above is just a paste of my notes, I have not have time to clean it up yet_

-----

= Build Automation =

_note: we ran the build automation while we were talking, but I missed some of the notes.  I'll try to recreate it here, otherwise we have to wait till next week_

Tera term must be closed to run the build automation.  GoProxyTerm talks directly to the prop.

== find the build automation output files =

In a file explorer window look in
{{{
C:\PropForthv6.0\mygo\V6.0\kernels\MAKE\results\resultFiles
}}}

Notive the time stamps (first time they are all the time the archive was extracted, after that they are the time build completed)

= launch the automation =

From the window command prompt window where goshell.bat was run:

cd to 

{{{
C:\PropForthv6.0\mygo\V6.0\kernels
}}}

find 
{{{
buildall.bat
}}}

this just calls a bunch of scripts. 

run buildall.bat

notice the result files directory is now empty, and the automation is  running scripts. 

in 37 minutes, the build proces is complete.  WOW! that was easy!

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages