#summary FAQ for Propforth 4.5 Release
#labels Phase-Support,v4.5

= Introduction =

A bit different for this release, I'm going to post all the questions and answers from various locations in one place. This is actually not limited to "frequently" asked questions. 

Newer Topics to be added to the top.

== Question 5 Please Clarify "Multi-Channel Hi Speed Sync Comms" ==

kuroneko (Marko) the clocks and timing guru, asked can you be more clear? Something along the lines of "20 instructions per bit at 80MHz" would be more precise.

Sal said th

-- interrupted by munchkins  --


== Question 4 Additional functions from 3.6 missing ==

Several additional functions that were present up till v3.6 are no longer found in the release package.  for example VGA support, aslicer.f (assembler time slicer, the pause word), cogdbg.f (the debugger/disassembler), maybe some others.

VGA needs assembler support, this must wait till 5.0 (Sorry C3 and demoboard fans).  But it is on the list.

aslicer.f - the assembler time slicer (the pause word) is not deeme worthwhile at this time (Awwww!).  There's already 8 cogs, and more if you add more props.  If a need arises, it can be revisited, or somebody can do it for fun.  Right now there are bigger fish to fry, and only Cliffe Biffle ever used it, and that was in a development test to see how many tasks could be running (doing nothing) at the same time.  The result was something wickedly awesome for a micro-controller,  180 tasks per cog I think,  but it hasn't found a real life application yet.  So its NOT on the list to be brought forward, at least not yet. 

cogdbg.f - cog debugger.  This completely cool and very powerful.  But since the assembler use is being redesigned, this functionality must also conform to the redesign.    Sal will probably include at least some of this in 5.x, but it all depends on where that road takes us. 

There are probably more functions from eariler releases that should be on this list.  They will be added and considered as we notice. 

== Question 3 SD_init regression test is not repeatable ==

The sd_init.f regression test initializes the SD card for use by the forth system. The initialization function sets up the card to run autoboot scripts. But, it does not kill any existing scripts.  So the first time the init is run,  the following step, reboot, returns autoboot not found.  Running the init scrip on an initialized  card ALSO sets up the card to look for an autoboot script, but since the script already exists, the reboot finds the script.  So in reality it skips tfrom the start of the init step to reboot after creating the auotboot file.  

This bring up a critical point.  There is NO DELETE FILE FROM SD function.  If you want to get rid of a file, re-initialize the file.  If a file is too small, rename the old version "backup1" and create a large file with the necessary size, or re-initialize the card and create it bigger.  The design decision was that the speed and compactness outweigh the value of dynamic file size allocation.  Its a micro controller for cryin' out loud, and the SD has 4 gig of space!  Use it!  Or not.  Users are free to implement dynamic file allocation if wanted, support is not targeted for inclusion in the default kernel at this time. 

Anyway, so far only prof_braino and caskaz have had a need to run the regression tests multiple times on the same card.  But I can't leave it at that, the regression tests must be repeatable. 

Prof_braino asked for a WIPE_SD word that specifically sets the card to an "uninitialized state" by wiping EVERYTHING.  Sal does not like this type of word, as it tends to get called by accident, and makes sad faces.  So the idea is to provide a WIPE_SD function, but not include it in default kerrnel support; in fact we will likely "hide" it in the extensions, with warnings like "DO NOT USE" or something. 

== Question 2 Assembler =

The assembler has been evolving later, in particular the usage model has been evolving.  Sal had a particular process in mind in the earlier releases, this turns out to not work as well as had wanted, and so much will be different in v5. Previously, the use was something like:
write a function in forth, extract the assembler (kind of a big process in itself), hard-code this sequence of bytes, load these into cog memory, and manage this process by hand (also an involved process). 

In V5, the design pattern will be along the lines of:
write in forth, translate into assembler (there are new tools but this is still the major task), use as if it were a regular forth word.

As it turns out, we don't have to load the assembler into each cog as before.  Also, each assembler definition (re?)uses the same cog memory space(?).  

Example: Multiply, divide, and dictionary search words.  To use a new word, it gets loaded into the same memory space. The reload slows it down.  BUT the speed gain due to assembler code is far greater, so the net result is significant speed BOOST. (Noticeable to the user).

The impact is the rebuild process now has two steps instead of one. 
There is still a BASE KERNEL, with no assembler definitions. 
User can add the assembler optimization support.
Rebuild the kernek, with optimizations on top. 

So the choice is a) very tiny kernel, or b) boosted interpreter (wheeee!).  COG memory usage is already reduced by 30 longs, V5.x has about 190 longs free, v4.5 has 160 longs free.

As states before, the performance increase is significant, and is noticeable to the user. Sal is hoping this boost will apply well to the multi-cog support.  For Cog to Cog communication, the delay is from accepting I/O into PAD. The new kernel is does this MUCH faster. 

= Question 1 - caskaz SD issues =

caskaz was the original developer on the SD support, starting in v4.0. Now at release 4.5, he is the only one reporting problems.  Since there are already several reports of success by other beyond the development team, we thing the SD code and tests are working according to requirements.

The error messages caskaz is getting are 167 (A7 not A6 as reported in the thread -check if something else is wrong), 172, and 163. 

Sal interprets these as the CARD REPORTS it is not SD V2+.  Could these be old V1 standard, or MMC?  These are not supported, as these were hard to find, and so untestable. 

During development, Sal could not find examples of non v2 cards, the V1 standard was weak and/or not adhered to by manufacturers.  Sal specifically order old parts off of Ebay to try to find examples of the older tech.  But since these were unreliable, apparently folks discarded them. 

After discussion, we have the following options:
1) caskaz get new cards that report SD v2+ at initialization in SD init. Hopefully these work.
2)  caskaz to turn on sd_debug (he did already, I think) and check the output of each word. Deterrmine if the cards are V1 or MMC, and develop support as required.  This is a lot of work for potentially small benefit.  (Is is cheaper to write new support for old card, or can you just buy new cards and be done with it)
3) prof_braino to ship card successfully initialized and formatted with SD_SCRIPT.f to caskaz.  A known working card will verify that cakkaz's hardware is correct or not; but we have confidence in caskaz's ability, so we think this is not required
4) caskaz to ship one or more cards to Sal, for debugging.  (last option)