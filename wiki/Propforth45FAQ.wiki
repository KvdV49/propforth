#summary FAQ for Propforth 4.5 Release
#labels Phase-Support,v4.5

= Introduction =

A bit different for this Propforth V4.5 release, I'm going to post all the questions and answers from various locations in one place. This is actually not limited to "frequently" asked questions.

Newer Topics to be added to the top.

== Question 9 Where are the Requirements listed? ==

Traditional requirements are too expensive for our resources, and are typically too expensive for professional outfits (outside of military and aviation etc where there is contractual/legal obligation).  We are examining taking "requirements based test" one step further to "design based tests".   That is, each design element will be "completed" by a test that verifies the system operates to that design.  (An interesting result of this is that the actual coding happens last, and takes only a small part of the development cycle, and it is difficult to introduce bugs into the result). In this manner, the _regression suite_ performs the roles of design document, requirements, test, requirements  to test traceability, user manual, and tutorial.  The result is descriptively simple, yet seems to be effective. 

== Question 8 Why are the Tests so hard to follow? ==

The test are written with delimiters to allow automation.  Future development process will include running the regression suite after each function is completed to ensure that nothing "broke" during development.

The tests aren't really so hard to follow after you get used to reading the delimiters.  This will be a non-issue after automation is complete. 

== Question 7 Version 5 schedule ==

When will users get to see the version 5 optimizations? 

With the paint not dry on on v4.5, its still a month before v5.x start regression testing.  An actual release may be a month after that, give or take.

  * update 20110626 Possible September release

== Question 6 issue 27 by salsanci: mcs.f - 32 + 1 bits in loop ==

kuroneko (Marko) the clocks and timing guru, asked about the 32 + 1 bits in the mcs.f  (MultiChannel Synchronous Serial) ? 

I'm a bit concerned about the way bits are collected. The loop itself rotates 32 bits into `_treg3` and then one more after leaving the loop. This may be perfectly OK if the first sample is not part of the data (maybe start bit). Could you ask Sal(?) for clarification? Thanks.

Sal's answer:

The way this code should function is:

{{{
\ _treg5 tx reg , _treg3 rx reg
__7trreg
              mov   _treg6 , # 20
__Flp
                test  v_pinin  , ina wc
------>         rcl   _treg3   , # 1     <---------
                shl   _treg5   , # 1 wc
                muxc  outa     , v_pinout
              djnz  _treg6     , # __Flp wz
              test  v_pinin    , ina wc
------->      rcl   _treg3     , # 1    <-------------
__8trregret
              ret

}}}

But remember, we are transmitting and receiving at the same time, and both sides running in sync

This puts the data valid time, to the data read time about 4 cycles apart, and any capacitance on the line could slow down the edge and make this a little tight as could and slight clock differences between props

By sacrificing 2 longs, and 8 cycles / 32 bits we add another 4 cycles for the data to stabilize before it is read by the other prop chip, so in theory we have 8 cycles or about 100 ns on an 80Mhz clock

This should be good enough for most applications.

The raw bit speed is about 20 cycles / bit. However, the protocol stack must be factored.

The goal of this code is not to send 32 bits, but to provide 8 synchronous full duplex channels between props.

== Question 5 Please Clarify "Multi-Channel Hi Speed Sync Comms" ==

kuroneko (Marko) the clocks and timing guru, asked can you be more clear? Something along the lines of "20 cycles/bit" would be more precise, which boils down to 4Mb/s @80MHz

Sal said the "20 cycles per bit" doesn't really tell us what we need, as it does not include the overhead for the protocol.  (Although prof_braino uses 4Mb/s since its easy to remember and type).

Sal will did up the original development tests, and bring them forward to 4.5.  He did not recall the exact details, so the following may be incorrect, but is posted here as a ballpark estimate.
  * Test covers 8 channels
  * Full duplex frames / 1 character slot per frame
  * Send an receive 1 character (simultaneously)over 8 channels
  * Plus protocol 'Did you get an error? No, I did not get an error, can you send the next character? Sure, here's another character...`

The real throughout is around (?) 50-60K (?) on each channel in both directions.  

Analysis of the actual tests to follow when they are brought up to v4.5

== Question 4 Additional functions from 3.6 missing ==

Several additional functions that were present up till v3.6 are no longer found in the release package.  for example VGA support, aslicer.f (assembler time slicer, the pause word), cogdbg.f (the debugger/disassembler), maybe some others.

VGA needs assembler support, this must wait till 5.0 (Sorry C3 and demoboard fans).  But it is on the list.

aslicer.f - the assembler time slicer (the pause word) is not deeme worthwhile at this time (Awwww!).  There's already 8 cogs, and more if you add more props.  If a need arises, it can be revisited, or somebody can do it for fun.  Right now there are bigger fish to fry, and only Cliffe Biffle ever used it, and that was in a development test to see how many tasks could be running (doing nothing) at the same time.  The result was something wickedly awesome for a micro-controller,  180 tasks per cog I think,  but it hasn't found a real life application yet.  So its NOT on the list to be brought forward, at least not yet. 

cogdbg.f - cog debugger.  This completely cool and very powerful.  But since the assembler use is being redesigned, this functionality must also conform to the redesign.    Sal will probably include at least some of this in 5.x, but it all depends on where that road takes us. 

There are probably more functions from eariler releases that should be on this list.  They will be added and considered as we notice. 

== Question 3 SD_init regression test is not repeatable ==

The sd_init.f regression test initializes the SD card for use by the forth system. The initialization function sets up the card to run autoboot scripts. But, it does not kill any existing scripts.  So the first time the init is run,  the following step, reboot, returns autoboot not found.  Running the init scrip on an initialized  card ALSO sets up the card to look for an autoboot script, but since the script already exists, the reboot finds the script.  So in reality it skips tfrom the start of the init step to reboot after creating the auotboot file.  

This bring up a critical point.  There is NO DELETE FILE FROM SD function.  If you want to get rid of a file, re-initialize the file.  If a file is too small, rename the old version "backup1" and create a large file with the necessary size, or re-initialize the card and create it bigger.  The design decision was that the speed and compactness outweigh the value of dynamic file size allocation.  Its a micro controller for cryin' out loud, and the SD has 4 gig of space!  Use it!  Or not.  Users are free to implement dynamic file allocation if wanted, support is not targeted for inclusion in the default kernel at this time. 

Anyway, so far only prof_braino and caskaz have had a need to run the regression tests multiple times on the same card.  But I can't leave it at that, the regression tests must be repeatable. 

Prof_braino asked for a WIPE_SD word that specifically sets the card to an "uninitialized state" by wiping EVERYTHING.  Sal does not like this type of word, as it tends to get called by accident, and makes sad faces.  So the idea is to provide a WIPE_SD function, but not include it in default kerrnel support; in fact we will likely "hide" it in the extensions, with warnings like "DO NOT USE" or something. 

== Question 2 Assembler =

The assembler has been evolving later, in particular the usage model has been evolving.  Sal had a particular process in mind in the earlier releases, this turns out to not work as well as had wanted, and so much will be different in v5. Previously, the use was something like:
write a function in forth, extract the assembler (kind of a big process in itself), hard-code this sequence of bytes, load these into cog memory, and manage this process by hand (also an involved process). 

In V5, the design pattern will be along the lines of:
write in forth, translate into assembler (there are new tools but this is still the major task), use as if it were a regular forth word.

As it turns out, we don't have to load the assembler into each cog as before.  Also, each assembler definition (re?)uses the same cog memory space(?).  

Example: Multiply, divide, and dictionary search words.  To use a new word, it gets loaded into the same memory space. The reload slows it down.  BUT the speed gain due to assembler code is far greater, so the net result is significant speed BOOST. (Noticeable to the user).

The impact is the rebuild process now has two steps instead of one. 
There is still a BASE KERNEL, with no assembler definitions. 
User can add the assembler optimization support.
Rebuild the kernek, with optimizations on top. 

So the choice is a) very tiny kernel, or b) boosted interpreter (wheeee!).  COG memory usage is already reduced by 30 longs, V5.x has about 190 longs free, v4.5 has 160 longs free.

As states before, the performance increase is significant, and is noticeable to the user. Sal is hoping this boost will apply well to the multi-cog support.  For Cog to Cog communication, the delay is from accepting I/O into PAD. The new kernel is does this MUCH faster. 

= Question 1 - caskaz SD issues =

caskaz was the original developer on the SD support, starting in v4.0. Now at release 4.5, he is the only one reporting problems.  Since there are already several reports of success by other beyond the development team, we thing the SD code and tests are working according to requirements.  The question is whether there is something hardware related we can identify. 

The error messages caskaz is getting are 167 (A7 not A6 as reported in the thread -check if something else is wrong), 172, and 163. 

Sal interprets these as "the CARD REPORTS it is not SD V2+".  Could these be old V1 standard, or MMC?  These are not supported, as these were hard to find, and so untestable. 

During development, Sal could not find examples of non v2 cards, the V1 standard was weak and/or not adhered to by manufacturers.  Sal specifically order old parts off of Ebay to try to find examples of the older tech.  But since these were unreliable, apparently folks discarded them. 

After discussion, we have the following options:
  #) caskaz get new cards that report SD v2+ at initialization in SD init. Hopefully these work.
  #)  caskaz to turn on sd_debug (he did already, I think) and check the output of each word. Deterrmine if the cards are V1 or MMC, and develop support as required.  This is a lot of work for potentially small benefit.  (Is is cheaper to write new support for old card, or can you just buy new cards and be done with it)
  #) prof_braino to ship card successfully initialized and formatted with SD_SCRIPT.f to caskaz.  A known working card will verify that cakkaz's hardware is correct or not; but we have confidence in caskaz's ability, so we think this is not required
  #) caskaz to ship one or more cards to Sal, for debugging.  (last option)