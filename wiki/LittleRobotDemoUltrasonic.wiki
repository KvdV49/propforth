#summary Driver for SR04 unltrasonic rangefinder
#labels LittleRobot,Ultrasonic,SR04,v5.5,demo

<wiki:toc max_depth="9" />

= Introduction =

The SR04 Ultrasonic Rangefinder driver

There are two SR04 versions in the propforth download:
  * The SR04 driver program for testing SR04.F
  * The SR04 section from the LittleRobotDemoProgram BOT.F

For the workshop, we modified the BOT.F program to use a different pin configuration.

See the LittleRobotQSbotProgram page

= Stand-Alone SR04 =

The following a stand alone driver for testing the SR04 on its own.  It uses the same pin configuration as described in LittleRobotQSbotProgram

START with the stand alone drive to prove that the sensor is set up correctly, and operates properly. 


Paste the following from the *`fl`*  to the *`...`*  into your text editor.  NOTE:  The brwoser may render the page with non-printable characters, and/or may cut off the end of long lines of code, etc.  You really should paste the source code into you editor and work from there. 

{{{

fl

\ 20130626 Quickstart LEDs represent the distance measured

fswrite ansi.f

\ ascii code for red text      " ESC[31m "
\ hex character codes            1b 5b 33 31 6d
\ forth code for ascii red text v4.0: 1b emit 5b emit 33 emit 31 emit 6d emit          
\ forth code for ascii red text v5.0: h_1B emit h_5B emit h_33 emit h_31 emit h_6D emit          

\ ascii escape sequence start with ESC

\ second char of two character is 64 to 95   (@ to _)  40h to 5Fh
\ multi char are esc + [ + (@ to ~) 64 to 126  40h to  7Eh
\ next is [   5Bh
\ m is for graphics mode colors attributes
{ : to57 csi ." 5;7f" ;  : to2010 csi ." 20;10f" ; }
\ f is for position, needs character not value           

: esc h_1B emit ;
: csi esc h_5B emit ;
: m ." m" ;    
: smallf ." f" ; 
: K ." K" ;
: semicolon ." ;" ;

\ v>c convert a value ( 0-9 ) for a digit character for emit 
: v>c h_30 + emit ;
\ .digits ( n -  ." emit as DECIMAL characters" ) for AT  convert 0-99 for emit
: .digits 
          dup h_9 > if h_0A u/mod v>c then \ greater than 9 mod decimal 10
          v>c ;
\ AT  ( x y - ) put cursor at x,y
: AT csi .digits semicolon .digits smallf ;

: home       csi ." 1;1f" ;
: clear      csi ." 2J" ; 
: preclear   csi ." 1J" ;
: postclear  csi ." 0J" ;
: cls home clear  ;


...

fswrite sr04-testbed.f

1 wconstant build_sr04
24 wconstant _sr04_trig
25 wconstant _sr04_echo

variable _sr04_distance

: _sr04_measure
               c" MEASURE" cds W!
               4 state andnC!

  _sr04_trig pinlo _sr04_trig pinout
  _sr04_echo >m
  _sr04_trig >m
begin
      dup _maskouthi dup dup dup dup drop drop drop _maskoutlo
      over dup dup dup
      waitpeq
      cnt COG@
      rot2

      waitpne
      cnt COG@ swap -
      d_170_000 clkfreq */

      _sr04_distance L!
      d_60 delms
0 until
;

: sr04_test
  clear \ clear the screen
  0 9 AT cog?
  begin
       home st?   
       _sr04_distance L@  dup
      5 3 AT ."  SR04 measurement = "  .  ." millimeters               "
      5 7 AT ."  LED pattern " 20 / 2 base W! . decimal ."             "
      80 delms
      fkey? nip
 until
;

: sr04_display
c" LED" cds W!
4 state andnC!

  8 0 do i 16 + pinout  loop

  clear
  begin
        home st?   
        _sr04_distance L@ 
\ 16 is sr04 echo 
\    dup 50 125 between if 17 pinhi else 17 pinlo then 
\    dup 125 250 between if 18 pinhi else 18 pinlo then 
\    dup 250 500 between if 19 pinhi else 19 pinlo then 
\    dup 500 1000 between if 20 pinhi else 20 pinlo then 
\    dup 1000 2000 between if 21 pinhi else 21 pinlo then 
\    dup 2000 4000 between if 22 pinhi else 22 pinlo then 
\    4000 >  if 23 pinhi else 23 pinlo then 
\    
\ max is 4000 mm (datasheet) 
 
        dup 
        4000 > if drop 255 else 20 / then   \ 20 or 16


      16 lshift \ slide it up to the LED bits 16-23
      0 >m _maskoutlo  \ turn out all LEDs 
      \ >m _maskouthi    \ display value on LEDs
      outa COG!

      20 delms     \ wait so they can light

                fkey? nip
\    80 delms
        until
;



: d
_sr04_distance L@ . cr
;


\ ===== SR04 diagnostic ===============
\ sr04_sample 
\ 1) need 100 samples 
\ 2) valid is 3 to 4200,  display and toss rejects
\ 3) save highest and lowest. Display and toss these at the end.  
\ So collect 102 valid sample and keep 100
\ 4) identify the highest and lowest of remaining values.
\ 5) average the samples
\ 6) final display:
\  attempts low-toss high-toss low high delta average cr
\ turns out we don't need to toss highest and lowest, 
\ as we filter 3 4200 per data sheet

wvariable valids
        : valids+1 1 valids W+! ;
       : @valids valids W@  ;
       : .valids @valids . ;

wvariable attempts
        : attempts+1 1 attempts W+! ;
       : @attempts attempts W@  ;
       : .attempts @attempts . ;

variable low  : @low  low  L@ ; : !low  low  L! ;
variable high : @high high L@ ; : !high high L! ;
variable SUM  : @SUM  SUM  L@ ; : !SUM  SUM  L! ;

: @average @SUM @valids / ;

: .result \ st?
."  reading attempted: " .attempts  
."  valid readings  " .valids   
."  lowest  "  @low .  
."   highest " @high . 
."  delta +"  @high  @average - . ." / " @low @average - .   
."  average " @average . 
\ cr
;

: valid_reading? \ ( - reading t/f )
     _sr04_distance L@      \ get a sample
     dup 3 4200 between 
; 

: valid_reading \ ( - reading )
  0 
  begin drop
        attempts+1  
        valid_reading? 
  until
; \ this goes forever if SR04 disconnected

: lowest? \ ( dist -  ) 
  dup @low <    if !low else drop then
;

: highest? \ ( dist - ) 
  dup @high >   if !high else drop  then
;

: sr04_init
  0 valids W!
  0 attempts W!
  0 !SUM
  valid_reading dup !low dup !high drop
;

\ ----------------------------------------
: sr04_sample
  sr04_init \ load first value
begin
     valid_reading
\   st?
       valids+1   
       dup lowest?
       dup highest?
     @SUM  + !SUM
\     2 delms
     @valids 10000 < 0= until 
    .result 
;


: s sr04_sample ;
\ ==========================================

...



fswrite boot.f

hA state orC! version W@ .cstr cr cr cr
: findEETOP
0
h100000 h8000
do
i t0 2 eereadpage
if
leave
else
i h7FFE + t0 3 eereadpage
if
leave
else
drop i h8000 +
then
then
h8000 +loop
;

c" boot.f - Finding top of eeprom, " .cstr findEETOP ' fstop 2+ alignl L! forget findEETOP c" Top of eeprom at: " .cstr fstop . cr
c" boot.f - Loading bot.f~h0D~h0D" .cstr hA state andnC!
cr cr cr 


c" boot.f - Loading ansi.f~h0D~h0D" .cstr hA state andnC!
fsload  ansi.f
c" boot.f - Loaded ansi.f~h0D~h0D" .cstr hA state andnC!

cr cr
c" boot.f - Loading sr04-testbed.f~h0D~h0D" .cstr hA state andnC!
fsload  sr04-testbed.f
c" boot.f - Loaded sr04-testbed.f~h0D~h0D" .cstr hA state andnC!

cr cr
c" boot.f - DONE PropForth Loaded~h0D~h0D" .cstr hA state andnC!

: onreset6
fkey? and fkey? and or h1B <>
if
\ c" 23 dup pinout pinhi" 1 cogx
\ cogid >con
c" _sr04_measure" 2 cogx
c" sr04_display" 3 cogx


then

c" onreset6" (forget)
sr04_test
;

...


cr

}}}

The final cr is added to ensure a newline is after *`...`* when pasted from the browser 
 

=== START the SR04 driver ===

Reboot after the above has been pasted into the terminal window.

autoboot.f will load the test driver. 

*EXPLANATION*

After the test display prgram is loaded launch it by tyoping:

{{{
c" _sr04_measure" 2 cogx
}}}

This line starts the SR04 measuring on cog 2

=== This is the test program that runs on you terminal display ===

{{{
 sr04_test
}}}


= VERIFY THE SENSOR ACCURACY =

USE A  RULER:

 # how consistent are the numbers?
 # how accuracte are the numbers?
 # What is the SMALLEST distance it reports?
 # What's the BIGGEST distance it reports?

RUN sr04_sample:

Key any key to stop the default automatic and return control to the command line.

Use the sr04_sample routine to test the consistency of reads at various distances.

The sor04_sample routine can also be launched using the s command, this is an abbreviation for the same program, just shorter to type. 

{{{
: s sr04_sample ;
sr04_sampe
s
}}}

Place the unit a known distance from an object, and run the sr04_sample routine. 

The sr04_sample routing will  collect 10,000 samples, and ignore any values outside the sr04 valid range as given on the sr04 datasheet. 

The routine will display the number of sample the highest and lowest valid values, the average of the 10,000 sample, and the delta for the range of samples.

When the readings are withing 1% of the actual distance, they can be considered "very good".  

When the readings are withing 5% of the actual distance, they can be considered "ok".  

When the readings are withing 20% of the actual distance, they can be considered "usable" for some purposes.  







= Experiment =

Now the real fun begins!

  # how can you "trick" of "fool" the sensor into reporting the wrong value?
  # how can you determine if the sensor is reporting a good value or a bad value?