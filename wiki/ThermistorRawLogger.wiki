#summary Collect data fo thermistor calibration.

= Overview =

Each batch of thermistors is different.  Within a batch there can be variation. After we add the wires and connect to the final circuit, a given part can end up different from its siblings from the same batch. 

The should help with collecting data for calibrating thermistors.

At least one thermistor needs to be calibrated from each batch.

Possibly each thermistor should be calibrated when in its final circuit configuration. 

-----

= Module Subsystem Requirements =

The thermistor raw data collection package has a bunch of parts:
 # thermistor driver - 
   # read the sensor, 
   # store the data to RAM memory.  
   # Runs on its own cog, in the background
 # logger - write records to SD card memory
   # fetch the actual temperature (as written to RAM)
   # fetch the last sensor reading (as stored to RAM)
   # format the record,  write to SD
   # Runs on its own cog, in the background
 # UI (user Interface) - 
   # prompt the user for input (temperature the thermistor is experiencing)
   # collect input from the operator, store to RAM memory 
   # display the status of the process (temperature, reading, in-progress, READY)
   # launched by user
   # runs on the cog6, the user cog, in the foreground
 # Boot routine
   # this load the other source files
   # this launches the routines on the other cogs
   # this switched user input to bluetooth by deafult
   # this allow the user to interview, and prevent the input switch to bluetooth.  This is needed so we can run connected to the PC if desired. 
 # time
   # this is optional
   # we don't need to know or track the time. but its often handy to have timestamps
   # time needs double math (doublemath.f)
   # time needs the 64 bit time calculations and formatting (time.f)

-----

== Thermistor driver ==

This source code is loaded first.  It sets up: 
  * the thermistor PIN 
  * the thermistor HUB RAM memory location
  * the thermistor driver routine

== GUI ==

This source code is loaded second.  It sets up: 
  * the temperature variable location HUB RAM memory location
  * the temperature prompt ("Please enter Temp C:")
The gui routine asks the user for current temperature the thermistor is experiencing.  This is typically from a known good instrument, such as lab thermometer or a bench thermometer.   Other sources of known temperature are:
  * boiling water (100C)
  * icewater (0C). Use crushed ice in an insulated mug etc.
Boiling and freezing are the high and low points for my data range, so far

My Centech P37772 multi meter with probe and digital temperature display only reached 3C fro ice water, and 91C for boiling water.  I need to retest after this logger is complete. 

== logger == 

This code is loaded third. The logger routine:
  * defines the logger routine
  * needs to have the LOGGED variable defined
The logger sits in a continuous loop.  When it detects that a numeric value has been entered and stored in the HUB RAM location, it begins logging.

The logger logs:
 * a text label for temperature 
 * the temperature in degrees C as entered by the user
 * a text label for readings
 * one or more reading from the thermistor
 * a carriage return (so the flog file displays properly)

After the thermistor record has been logged,  the logger routine sets the temperature value to 'NULL' or something (that won't be interpreted as a temperature).  The logger then waits until the next temperature is entered.

== boot routine  ==

The boot routine:
 * loads the source code files from SD, in the proper order
 * launches the background tasks on available cogs
 * switches to bluetooth by default
 * optional stays connected to the PC (terminal emulator program)
 * launches the GUI routine

When the GUI routine is launched, it prompts the operator for the first temperature

-----

= Source Code =

The source code will be posted on the Downloads section of this wiki as a single file containing several routines. (link here)

The individual snippets will be listed here for explanation.  If you try to paste these into the terminal window, remember that you have to hit <enter> after the last line loads.  (Copy and paste from this web page via browser does not terminate the last line).

== therm-driver.f ==

{{{
fl

100 fwrite therm-driver.f


\ therm-driver.f 2013-11-10 braino based on Sal's example
\ just log the RAW therm data.

\ using 10k (cheapest) thermistor
\ needs 0.1uF capacitor
\ uses 1 prop pin
\ connect thermistor to 3.3v and to pin;
\ connect capacitor to ground and pin
\ 3.3v -----/\/\/\/\/\/\----+-----||---------- gnd
\                           |
\ pin-----------------------
 
27 wconstant _therm_pin

variable _therm_reading   \ store current reading here

\  _temp? ( pin# -- count)
: _temp?
         dup pinlo dup pinout
         1 delms  
         cnt COG@ over pinin
         swap >m dup waitpeq
         cnt COG@ swap -
;

\ NOTE that _temp? does NOT read the temperature or resistance from the thermistor
\ _temp? returns the number of ticks for the capacitor to discharge through the thermistor

...

}}}


== therm-ui.f ==

{{{
fl

100 fwrite therm-ui.f

variable _meter_display \ type in the number displayed on the VOM digital temperature probe

\ meter! stores the degrees C entered by the user

: meter! \ ( degrees - )
         _meter_display L!   
;

\ meter@ fetches the degrees C entered by the user and leaves it on the top of stack

: meter@ \ ( - degrees )
    _meter_display L@
;  

...

}}}


== therm-logger.f ==


{{{

fl

100 fwrite therm-logger.f


lockdict wvariable logBuffer 256 allot freedict

: logdata
\	getLocalTime formatTime logBuffer ccopy  \ Start by logging the time
\       Log data for all thermistors.

	c"  METER-displayed: " logBuffer cappend
        meter@ <# d#s #> logBuffer cappend 

\ collect ten reading for each meter temperature entered
\ adjust this to control the number of sample logged 

        c"  Therm-readings: " logBuffer cappend
 
        10 0 do 
                 temp@ <# d#s #> logBuffer cappend 
                 c"  " logBuffer cappend
        loop 

\ end each record with CR so it displays on the terminal

        c" ~h0D" logBuffer cappend  
	logBuffer                  \ return the address of this buffer
;

\ log when new meter reading is entered

: logger
	4 state andnC!
	c" LOGGER" cds W!
	mountusr
	begin
                meter@   hDEADBEEF = 0=                  \ temperature? 
                if                                       \ if degrees is set...
		logdata C@++ c" log" 7 lock sd_append 7 unlock   \ log a record
                hDEADBEEF meter!                         \ turn the logger off
                then
        0 until 
;

\ user can enter ClearLog to erase the entire contents of the log file

: ClearLog
	mountusr
	7 lock 0 c" log" sd_trunc 7 unlock
;


...

}}}

== usrboot.f ==

Remeber, the autoboot routine for SD is named usrboot.f

usrboot.f is the the default name for automatic boot time behavior.

if usrboot.f is present on SD,  the propforthSD kernel will call and run this script 


{{{

fl

mountsys 
100 fwrite usrboot.f
version W@  .cstr cr
c" usrboot.f  -  initializing~h0D~h0D" .cstr
1 sd_mount
\
\ Begin config parameters
\
[ifndef timeZoneHours
-6 constant timeZoneHours
]
[ifndef timeZoneMinutes
0 constant timeZoneMinutes
]
[ifndef doubleTimerCog
0 wconstant doubleTimerCog
]
\
\ End config parameters
\

\ fload DoubleMath.f
\ fload time.f
 fload therm-driver.f
 fload therm-driver.f
 fload therm-driver.f
 fload therm-driver.f
 fload therm-driver.f












fread .sdcardinfo      \ display the previously recorded card info file

c" 

c" logger" nfcog cogx  \ launch logger on next free cog



c" usrboot.f  -  DONE~h0D~h0D" .cstr



}}}


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages