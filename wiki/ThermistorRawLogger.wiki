#summary Collect data fo thermistor calibration.

= Overview =

Each batch of thermistors is different.  Within a batch there can be variation. After we add the wires and connect to the final circuit, a given part can end up different from its siblings from the same batch. 

The should help with collecting data for calibrating thermistors.

At least one thermistor needs to be calibrated from each batch.

Possibly each thermistor should be calibrated when in its final circuit configuration. 

-----

= Module Subsystem Requirements =

The thermistor raw data collection package has a bunch of parts:
 # thermistor driver - 
   # read the sensor, 
   # store the data to RAM memory.  
   # Runs on its own cog, in the background
 # logger - write records to SD card memory
   # fetch the actual temperature (as written to RAM)
   # fetch the last sensor reading (as stored to RAM)
   # format the record,  write to SD
   # Runs on its own cog, in the background
 # UI (user Interface) - 
   # prompt the user for input (temperature the thermistor is experiencing)
   # collect input from the operator, store to RAM memory 
   # display the status of the process (temperature, reading, in-progress, READY)
   # launched by user
   # runs on the cog6, the user cog, in the foreground
 # Boot routine
   # this load the other source files
   # this launches the routines on the other cogs
   # this switched user input to bluetooth by deafult
   # this allow the user to interview, and prevent the input switch to bluetooth.  This is needed so we can run connected to the PC if desired. 
 # time
   # this is optional
   # we don't need to know or track the time. but its often handy to have timestamps
   # time needs double math (doublemath.f)
   # time needs the 64 bit time calculations and formatting (time.f)

-----

== Thermistor driver ==

This source code is loaded first.  It sets up: 
  * the thermistor PIN 
  * the thermistor HUB RAM memory location
  * the thermistor driver routine

== GUI ==

This source code is loaded second.  It sets up: 
  * the temperature variable location HUB RAM memory location
  * the temperature prompt ("Please enter Temp C:")
The gui routine asks the user for current temperature the thermistor is experiencing.  This is typically from a known good instrument, such as lab thermometer or a bench thermometer.   Other sources of known temperature are:
  * boiling water (100C)
  * icewater (0C). Use crushed ice in an insulated mug etc.
Boiling and freezing are the high and low points for my data range, so far

My Centech P37772 multi meter with probe and digital temperature display only reached 3C fro ice water, and 91C for boiling water.  I need to retest after this logger is complete. 

== logger == 

This code is loaded third. The logger routine:
  * defines the logger routine
  * needs to have the LOGGED variable defined
The logger sits in a continuous loop.  When it detects that a numeric value has been entered and stored in the HUB RAM location, it begins logging.

The logger logs:
 * a text label for temperature 
 * the temperature in degrees C as entered by the user
 * a text label for readings
 * one or more reading from the thermistor
 * a carriage return (so the flog file displays properly)

After the thermistor record has been logged,  the logger routine sets the temperature value to 'NULL' or something (that won't be interpreted as a temperature).  The logger then waits until the next temperature is entered.

== boot routine  ==

The boot routine:
 * loads the source code files from SD, in the proper order
 * launches the background tasks on available cogs
 * switches to bluetooth by default
 * optional stays connected to the PC (terminal emulator program)
 * launches the GUI routine

When the GUI routine is launched, it prompts the operator for the first temperature

-----

= Source Code =

The source code will be posted on the Downloads section of this wiki as a single file containing several routines. (link here)

The individual snippets will be listed here for explanation.  If you try to paste these into the terminal window, remember that you have to hit <enter> after the last line loads.  (Copy and paste from this web page via browser does not terminate the last line).

== clear the files from the SD card ==

the SD init script is in the propforthSD kernel directory.

During development, we can re-initalize the SD to wipe it clean and start over using the SD init script `sdfsInitScript.f`

{{{
sdfsInitScript.f
}}}

Open the file and paste its contents into the editor.  You should see the dispaly pause when the initiaiaztion word executes: 

`_sd_CrEaTe`

After the initialization word, the ls should show the SD to contain only

on "partion" mountsys

{{{
Prop0 Cog6 ok
mountsys
Prop0 Cog6 ok
ls
390 usrboot.f
491 .partion-sys/
130 .sdcardinfo
133 sdboot.f
Prop0 Cog6 ok
}}}

on "partion" mountusr

{{{
Prop0 Cog6 ok
mountusr
Prop0 Cog6 ok
ls
65667 .partion-usr/
Prop0 Cog6 ok

}}}

== create the logfile "log" ==

The logfile is named `log`

The logfile `log` is 50 meg by default, that is 1000 diskblocks in size.  Recall that SD disk blocks are 512 bytes.  2 blocks make 1 K.  2000 pairs of 512 byte blocks makes 1 meg. 100,000 blocks make 50 meg. 

this is a forth script named `Log-INIT.f`

I think maybe  we should differentiatte between source code definitions files versus scripts, but we don't do tat yet.  Anyway, this is a script, it executes as it is loaded, then its done. 

`fstat log` shows the status of the file log

{{{

mountusr
\ create a 50 Mbyte logfile
100_000 fcreate log

mountusr
fstat log

}}}


== therm-driver.f ==

{{{
fl

 100 fwrite therm-driver.f

\ therm-driver.f 2013-11-10 braino based on Sal's example
\ just log the RAW therm data.

\ using 10k (cheapest) thermistor        cnt COG@ clkfreq +

\ needs 0.1uF capacitor
\ uses 1 prop pin
\ connect thermistor to 3.3v and to pin;
\ connect capacitor to ground and pin
\ 3.3v -----/\/\/\/\/\/\----+-----||---------- gnd
\                           |
\ pin-----------------------
 
27 wconstant _therm_pin

variable _therm_reading   \ store current reading here

\ NOTE that _temp? does NOT read the temperature or resistance from the thermistor
\ _temp? returns the number of ticks for the capacitor to discharge through the thermistor. 
\ I should change this when it works

\  _temp? ( pin# -- count)
: _temp?
         dup pinlo dup pinout
         1 delms  
         cnt COG@ over pinin
         swap >m dup waitpeq
         cnt COG@ swap -
;

: temp! 
        _therm_pin _temp? 
        _therm_reading  L!       
;

: temp@   \ ( - therm value )
        _therm_reading  L@ 
;

: therm-scan
        4 state andnC!
        c" THERM" cds W!
        begin
             temp!
        0 until
;
 
...

}}}


== therm-ui.f ==

{{{


fl

100 fwrite therm-ui.f

variable _meter_display \ type in the number displayed on the VOM digital temperature probe

\ meter! stores the degrees C entered by the user
: meter! \ ( degrees - )
         _meter_display L!   
;

\ meter@ fetches the degrees C entered by the user and leaves it on the top of stack
: meter@ \ ( - degrees )
    _meter_display L@
;  

hDEADBEEF meter! \ initialize the flag

wvariable flag
: !flag flag W! ;
: @flag flag W@ ;

: get_METER 
            
            ." Enter the temp from the digital thermometer: " 
            interpret  
            ."  logging data for " 
            dup . ."  degrees Centigrade "  
            cr
            dup h1B = !flag
            meter!      
;

: SCAN 
      begin
           get_METER
           
      @flag until
;

...

}}}


== therm-logger.f ==


{{{


fl

100 fwrite therm-logger.f

lockdict wvariable logBuffer 256 allot freedict

: logdata
        c"  METER-degrees-C: " logBuffer ccopy
        meter@ <# #s #> logBuffer cappend 

\ collect ten reading for each meter temperature entered
\ adjust this to control the number of sample logged 

        c"  Therm-readings: " logBuffer cappend
        10 0 do 
                  temp@ <# #s #> logBuffer cappend 
                  c"  " logBuffer cappend
        loop 

\ end each record with CR so it displays on the terminal

        c" ~h0D" logBuffer cappend  
        logBuffer                  \ return the address of this buffer
;

\ log when new meter reading is entered
: logger-body
               meter@   hDEADBEEF = 0=                  \ temperature? 
                if                                       \ if degrees is set
                logdata C@++ c" log" 7 lock sd_append 7 unlock   \ log a record
                hDEADBEEF meter!                         \ turn the logger off
                then
;

: logger
        4 state andnC!
        c" LOGGER" cds W!
        mountusr
        begin
               logger-body 
                1 delms \ is this needed?
        0 until 
;

\ user can enter ClearLog to erase the entire contents of the log file
: ClearLog
        mountusr
        7 lock 0 c" log" sd_trunc 7 unlock
;

...

}}}

== usrboot.f ==

Remeber, the autoboot routine for SD is named usrboot.f

usrboot.f is the the default name for automatic boot time behavior.

if usrboot.f is present on SD,  the propforthSD kernel will call and run this script 


{{{

fl

mountsys 
100 fwrite usrboot.f

version W@  .cstr cr
c" usrboot.f  -  initializing~h0D~h0D" .cstr
1 sd_mount

 fload therm-driver.f   
 fload therm-ui.f
 fload therm-logger.f

fread .sdcardinfo      \ display the previously recorded card info file

c" logger" nfcog cogx  \ launch logger on next free cog
c" therm-scan" nfcog cogx  \ launch therm monitor on next free cog

c" usrboot.f  -  DONE~h0D~h0D" .cstr


...


}}}


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages