#summary Check timing and execution speed of a piece of code
#labels v5.5,speed

<wiki:toc max_depth="9" />

-----


= a Speed Test =

Sometime we want to know how long a chunk of code takes to execute.  Here is a way to count the clock cycles using a cnt register

= speed.f =

speed.f is in the downloads section of this wiki.

http://code.google.com/p/propforth/downloads/detail?name=speed.f

The code is below for reference, BUT copy and paste it to your editor before pasting it to the TeraTerm terminal window (the browser can truncate line or add non printable character codes or other weird stuff).

{{{
\ overhead test
: speedtest1
   	cnt COG@

 \ put word to be timed in here

	cnt COG@
	swap - . cr 
;


\ a looptest   \ for short items, subtract ovwerhead, about 120 H 288 decimal clock cycles (per speed test 1 )
: speedtest2
	cnt COG@
	100 0 do
		2000 0 do
		loop
	loop
	cnt COG@
	swap -  dup . ." total clocks" cr
	100 u/ 2000 u/ . ." per loop" cr
;
}}}

= Expanation =

The way this one works is to
 * get cnt
 * execute the code snippet for the action a whole bunch of times,
 * get cnt again
 * figure the delta between the start and end cnt's
 * divide by the number of times the code snippet was executed
 * get an average of how long the execution took

That way OVERHEAD of starting and stopping the test gets smaller compared to the thing you are testing. But you have to remember, after we figure how long the event itself takes, we still have to be aware of the time required to start and stop the action.

So you want to be aware of the value when you take one measurement; and the value you get when you take the average of a few thousand measurements. The difference between these will be some th9ing to look for, in case your end result is different from what you expect. 

= VERY SHORT INTERVAL & MEASUREMENT =

ALSO - For the SR04 (ultrasonic range finder) it needs a 10uS pulse.  To do this, Sal inserted and extra "DUP DROP", and checked it with an oscilloscope.  Then he added additional "DUP DROP" pairs until he got the required interval of just over 10uS.

*From SR04.F*

{{{
	_sr04_trig pinlo _sr04_trig pinout \ make trigger output
	_sr04_echo >m                      \ convert pin number to bit mask  
	_sr04_trig >m                      \ convert pin number to bit mask
	begin
		dup _maskouthi dup dup drop dup drop _maskoutlo \ this is the timing code

\ 1. dup _maskouthi - make trigger pin go hi
\ 2. dup _maskoutlo - make trigger pin go low
\ Notice the extra dup drop before the pin goes lo
\ this is just enough to make the pulse long enough to trigger the SR04

		over dup dup dup

		waitpeq   \ wait till the echo pin goes hig
		cnt COG@  \ get the cnt
		rot2     

		waitpne   \ wait till echo goes lo
		cnt COG@ swap -       \ find the delta between counts
		d_170_000 clkfreq */  \ divide by speed of sound in meters.  
                                      \ Notice 340m/s  is pre-divided by 2, 
                                      \ since its the two way round trip


		_sr04_distance L!
		
		100 delms
	0 until

}}}
Since the interval usually must be associated with something (like triggering and external part) you might want to figure this into your test.  The raw execution time of the kernel itself may mislead and not reflect the useful application of timing an external interaction. 


= end =