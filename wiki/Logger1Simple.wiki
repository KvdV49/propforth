#summary Micro-second time stamps, logging to SD.
#labels v5.5,Logger

<wiki:toc max_depth="9" />


= Introduction =

This page presents an inital logging package for propforth v5.5

The logger logs to SD.  It provides a date - time stamp, bases on the count of microseconds since system startup. 

This package does not include queues

The logger package is available as a downloadable archive in the downloads section of this site.

http://code.google.com/p/propforth/downloads/detail?name=Logger-2013-05-12.zip

= Braino's Note =

This logging package seems like it might be kind of important.  Its very simple, very accurate, and very high resolution. It does not require any special hardware or circuitry, aside from the SD slot.

This is on the list as the center an activity after Little Robot get stabilized.  I think the logging package is going to be really big in terms of popularity and usefulness.  Get started now!

= Requirements =

To use the logger, all that is needed are:

  * a prop board with an SD slot
  * an SD card - see
    * http://code.google.com/p/propforth/wiki/PropToSDconnection
    * http://code.google.com/p/propforth/wiki/SDsetupREVISITED
  * the propforth SD file system kernel (SDKernel.spin in the propforth download)
  * some data to log

= the sections =  

The logger is presented in four modules.

  * Double Math
  * Time
  * Logger Init
  * Logger Boot

Paste each of these into the terminal window in turn.

== Logger init ==

Logger Init just creates a big file on the SD.  The the log file is name  `log` and is on the user partition.

Mount the user parition with the command `mountusr`

{{{
mountusr
}}}

List the contents of the directory with the `ls` command (similar in function to the linux ls command line command, but without the fancy stuff).

{{{
ls
}}}

== Logger Boot ==

Logger Boot creates a new version of `usrboot.f` on the SD.  Remember, the kernel looks for a file name sdboot.f and if found, runs this script at boot time.  The default sdboot.f file runs usrboot.f 

The version of usrboot.f that Logger Boot  creates loads the Double Math and Time support, and starts the microsecond timer on cog 0.

== Double Math ==

Double Math is loaded first.  The time module needs double math, as time uses 64 bit counter values.  The boot script usrboot.f calls the source code files in the proper order, so they can be written to the SD in any physical order.  

== TIME ==

Time uses doble math, so time.f must be loaded after doblemath.f.  Load order is performed in the usrboot.f script. 

Here are the comments for the time module

{{{

\
\ 2012-Feb-04 Status: Alpha
\
\ Provides a high resolution long time system timer by using one cog
\ to update a 64-bit counter as rapidly as possible. The main word is
\ _tickCounter ( addr_dticks _timelock -- ) 
\
\ When this words starts it sets the default time zone,
\ Sets the default time to 2012-01-01_12:00:00 UTC,
\ and adjusts the parameters to the current clkfreq 
\
\ This word will be run on one cog at system startup.
\
\ Counts system clock cycles (ticks) since system startup as an
\ unsigned double long.
\
\ Update read cycle is approximately 1 - 2 microseconds on an
\ 80 Mhz system.
\
\ This is because we have to use a lock, to update, or to read the
\ 2 longs that make up the double counter.
\
\ The words which update the double counter, and which read the
\ double counter, are written in assembler to ensure maximum resolution.
\ 
\ This provides a range of about 7,311 years at 80 Mhz
\ 2^64 / 80,000,000 / 60 / 60 / 24 / 365
\
\ The range will vary if the clock frequency changes, the design point
\ on this was an 80 Mhz system
\
\ Time is then calculated as ticks since 1970-Jan-01_00:00:00
\ only unsigned counts are considered, so minimum date is 1970-Jan-01_00:00:00
\
\ So for the unix people, you can generate a unix time stamp easily
\
\ NOTE: UTC -> local timezone conversion can cause an underflow. 
\
\ setTimeZone ( h m -- ) - sets the time zone h and m can be positive or negative
\
\ setTime ( y m d h m s -- ) sets the UTC time
\
\ setLocalTime ( y m d h m s -- ) subtracts the time zone, then sets UTC time
\
\ getTime ( -- y m d h m s ticks -- ) gets UTC time
\
\ getLocalTime ( -- y m d h m s ticks -- ) gets local time
\ 
\ formatTime ( -- y m d h m s ticks -- cstr) formats a to a printable sortable string
\
\ getTimeStr( -- cstr) get the current UTC time as a string
\
\ getLocalTimeStr( -- cstr) get the current local time as a string
\
\ time ( -- ) print the local time
\
\ setDriftCorrection ( n1 -- ) sets the time correction to n1 ticks per day
\
\ utc ( -- ) print the utc time
\
\ timeStamp ( -- lo hi) gets a number which is the time stamp in microseconds (UTC)
\                       the number of microseconds since 1970-01-01_00:00:00
\                       print with d. or the double format words 
\
\ unixTimeStamp ( -- lo hi) gets a number which is the time stamp in seconds (UTC)
\                           the number of seconds since 1970-01-01_00:00:00
\                           print with d. or the double format words
\
}}}

= RUNNING the Logger example =

Load the PropForth SD Kernel.  I used a Quickstart and the default pin assignments from spinneret. 

http://code.google.com/p/propforth/wiki/SDsetupREVISITED#Spineret_%28standard%29_Pinout

This is  kind is kind of neat in that Quickstart LEDs flash each time a record is written.

== test the SD kernel ==

Reboot the quickstart.   If you have no SD plugged in the slot, or you have an un-initialize SD card, you should get the cryptic error message.

Run the CrEatE_SD script if you have not already done so.

Reboot the Quickstat again.  When the SD is initialized and plugged in correctly, you should be the boot message sdispalying the SD size etc.


{{{

Prop0 Cog4 ok
fread .sdcardinfo

SDCard size:      3,858,435 Kbytes

File System: sys
                      Start Block:              1
                        End Block:         65,538
        File System Size (blocks):         65,537
        File System Size  (bytes):         32,765 Kbytes

File System: usr
                      Start Block:         65,538
                        End Block:      7,716,864
        File System Size (blocks):      7,651,326
        File System Size  (bytes):      3,825,665 Kbytes

Prop0 Cog4 ok

Prop0 Cog4 ok
c" braino rules 2X !!!usrboot.f  -  DONE~h0D~h0D" .cstr
braino rules 2X !!!usrboot.f  -  DONE

Prop0 Cog4 ok

sdboot.f  -  DONE - PropForth Loaded

Prop0 Cog5 ok

Prop0 Cog5 ok


CON:Prop0 Cog6 RESET - last status: 0 ok

Prop0 Cog6 RESET - last status: 0 ok
Prop0 Cog6 ok

Prop0 Cog6 ok

Prop0 Cog6 ok


}}}

NOTE: the goofy message `braino rules 2X !!!usrboot.f  -  DONE`  is present to demonstarte that the script is running, and that it took my modifications.


== Load Logger example code ==

Open the Logger zipfile you downloaded. 

Open each of the files in turn in your editor, and paste these into the terminal emulator as normal.

I did:

 * DoubleMath.f
 * time.f  - I modified this to time-cst.f, changing the timezone from Vancouver to Chicago.
 * LoggerBoot.f
 * Loggerinit.f

Notice that the first three files create source code files on the mountsys partition.  You can display these to verify their contents using:

{{{
mountsys

ls

fread DoubleMath.f
fread  time.f  
fread LoggerBoot.f
}}}


Notice that the last one LoggerInit.f creates a file `log` on the mountusr partion.   You can display the contents of this using:

{{{
mountusr

ls 

fread log
}}}

Notice the log is empty when you first start out.

== Reboot to automatically start the logger ==

Reboot

Notice the Quickstart LED's start flashing about EXACTLY every second. (They are not really exactly every second yet, you did not do calibration yet; but its purdy durn close).

AFter several seconds, dispaly the contenct of the log file agian


{{{
mountusr

ls 

fread log
}}}

Notice the log has data


{{{

Prop0 Cog6 ok
mountusr
Prop0 Cog6 ok
ls
65667 .partion-usr/
65796 log
Prop0 Cog6 ok
fread log
2012-01-01_05:00:01.366692 CNT REGISTER: F78FED11 timeStamp: 1325419201384406 unixTimeStamp: 1325419201
2012-01-01_05:00:02.366693 CNT REGISTER: FC54A111 timeStamp: 1325419202384402 unixTimeStamp: 1325419202
2012-01-01_05:00:03.366692 CNT REGISTER: 11954F1 timeStamp: 1325419203384126 unixTimeStamp: 1325419203
2012-01-01_05:00:04.366692 CNT REGISTER: 5DE08B1 timeStamp: 1325419204384134 unixTimeStamp: 1325419204
2012-01-01_05:00:05.366692 CNT REGISTER: AA2BCD1 timeStamp: 1325419205384142 unixTimeStamp: 1325419205
2012-01-01_05:00:06.366693 CNT REGISTER: F677141 timeStamp: 1325419206384126 unixTimeStamp: 1325419206
2012-01-01_05:00:07.366692 CNT REGISTER: 142C2511 timeStamp: 1325419207384395 unixTimeStamp: 1325419207
2012-01-01_05:00:08.366693 CNT REGISTER: 18F0D901 timeStamp: 1325419208384398 unixTimeStamp: 1325419208
2012-01-01_05:00:09.366693 CNT REGISTER: 1DB58CF1 timeStamp: 1325419209384406 unixTimeStamp: 1325419209

Prop0 Cog6 ok

}}}

== clear the log ==

While I've been typing this, the log has been filling up with data that say its from 2012-01-01 5 AM.  
{{{
fread log
}}}

Notice that even at 230400 baud, it takes a little time to print out the records. It took me 21 second to print data for 32 minutes worth of log.

Clear the log using:

{{{
ClearLog
}}}

Check that new data is in the log:

{{{
fread log
}}}

== Set the time ==

We can do any operation without stopping the logger.   This include  reading the log, and setting the time.  The logger cog takes care of it. 

To set the time we use the setLocalTime finction defined in the time.f file, which is autoloaded on boot.

{{{

\ setLocalTime ( y m d h m s -- ) subtracts the time zone, then sets UTC time
: setLocalTime
	ymdhms>t _dsetLocaltime
;

}}}

Notice that we can put the time in in UTC using setTime.  * Should this be renamed setUTCtime ? *

In my case I'm at CST (UTC -7), so I have to add 7 hours to the local time.

It was 2013 Sept 4 15:09:30 so I set up to put in the correct time at exactly 15:10:11, which is 22:10:11 UTC

{{{
Prop0 Cog6 ok
2013 09 04 22 10 11 setTime
Prop0 Cog6 ok
}}}

When the second on my clock rolled over to 11, I hit enter. 

== Check the time = 

Use the time command to dispaly the current time

{{{
Prop0 Cog6 ok
time
2013-09-05_14:07:00.509498
Prop0 Cog6 ok

}}}

If you wait till the minute rolls over at 59 seconds, you should be able to hit the enter key within a faction of a second.

== Clear the Log  again ==

After you are satisfied the time is set correctly, clear the log one more time.

{{{
ClearLog
}}}

The logger will log the correct time once per second.

== Calibrate ==

After 24 hours or longer, check the time.  Determine if it has drifted (is the clock running fast or slow?)

Determine the offset from the last displayed time and the current time.  This offset is in clock ticks.

After the clock has been left to run for some amount of time, for example a day or a week, determine the difference between the time displayed and the actual time. 

Divide the delta between the two times by the number of (days, hours?) of the time interval.  Use this value for the drift correction.

== setDriftCorrection ==

Calculate the value (number of ticks) difference between the displayed time and the actual time. Divide this delta by the time interval the clock was run.

Enter this offset using the word:
{{{
setDriftCorrection
}}}

Issue 205:  Is this per pay, or per hour?  The source says different in two places - opened issue 205

After about a day, the clock seemed to be slow by about a second. Should this be added to the count? So I tried setting the drift correction to 1 second worth of ticks. 

{{{
80_000_000 setDriftCorrection
}}}


A few hours later I tried checking the time at exactly 20:19:00

I got:
{{{
Prop0 Cog6 ok
time
2013-09-05_20:19:06.310991
Prop0 Cog6 ok
}}}

Ok, I'll try -80,000,000

Note: I still haven't determined if this is tick per hour, or ticks per day.  I suppose if I were smart I would trace through the code...

==  second try ==

After messing with the drift correction value, I reset it to zero, reset the clock, cleared the log, and let is run over night. 

The time when I set the clock was exactly when the seconds rolled over to 2013-09-05_22:00:00, thus I set the UTC time using `2013 9 6 5 0 0 setTime`

{{{
Prop0 Cog6 ok
2013 9 6 5 0 0 setTime ClearLog
Prop0 Cog6 ok
fread log
2013-09-05_22:00:00.417800 CNT REGISTER: 8BF2A614 timeStamp: 1378443600435353 unixTimeStamp: 1378443600
2013-09-05_22:00:01.417800 CNT REGISTER: 90B75A44 timeStamp: 1378443601435349 unixTimeStamp: 1378443601
Prop0 Cog6 ok
}}}

Next morning, I checked it 5:09 AM

{{{
Prop0 Cog6 ok
time
2013-09-06_05:09:00.125509
Prop0 Cog6 ok
time
2013-09-06_05:10:00.275570
Prop0 Cog6 ok
}}}

Looks like no drift this time!  Maybe there was an error when I set the clock the first tie.  I'm going to leave it go until this evening to let it run a full 24 hours. 

...

== setDriftCorrection is correct ==

If you figured the correction right, it should be dead on after 24 hours.  

Check it again in a week if you want to get REALLY close.  Bu after a certain point it doesn't really help much, the error setting the correct time (hitting `enter` EXACTLY when the second roll over) plus the error of reading the time (hitting `enter` EXACTLY when the second roll over) is greater than the number of ticks you are correcting.  

The crystal drifts with temperature.  If the unit is in a controlled environment (in the basement shop) the temperature does not drift much.  If it is in an variable environment (the garage) it tends to drift in as the day heats up, and out again as the night cools off.  But it tends to average out over time.  

== temperature compensation ==

IF you are planning to use the device in an extreme environment (temperate to polar in direct sunlight) it may be desirable to temperature compensate using a thermistor.  But this is an extra expense that we don't particularly need at theis time, so it is not included in this demo.   If you go to the trouble of rigging something up, please share it with us. 

= Next Version of Logger =

Next version will be a bit better than Simple Logger.

 * The system will detect the day roll over, and create a new file for each day. This should help control file size, and make offloading data a bit more  manageable.
 *multiple events (30?) can be logged simultaneously.  While time stamp collisions are possible, they should not be very likely.

Possible changes:
  * Since the time stamp does not roll over for 7000 years, why do we need to start at 1970?  We could just as easily (and transparently) start when the calendar starts. 

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages