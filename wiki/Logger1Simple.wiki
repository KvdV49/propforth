#summary Micro-second time stamps, logging to SD.
#labels v5.5,Logger

= Introduction =

This page presents an inital logging package for propforth v5.5

The logger logs to SD.  It provides a date - time stamp, bases on the count of microseconds since system startup. 

This package does not include queues

The logger package is available as a downloadable archive in the downloads section of this site.

http://code.google.com/p/propforth/downloads/detail?name=Logger-2013-05-12.zip

= the sections =  

The logger is presented in four modules.

  * Double Math
  * Time
  * Logger Init
  * Logger Boot

== Logger init ==

Logger init just creates a big file on the SD

== Logger Boot ==

Logger Boot loads the Double Math and Time support, and starts the microsecond timer. 

== Double Math ==

The time module needs double math, as it tracks 64 bit counts

== TIME ==

Here are the comments for the time module

{{{

\
\ 2012-Feb-04 Status: Alpha
\
\ Provides a high resolution long time system timer by using one cog
\ to update a 64-bit counter as rapidly as possible. The main word is
\ _tickCounter ( addr_dticks _timelock -- ) 
\
\ When this words starts it sets the default time zone,
\ Sets the default time to 2012-01-01_12:00:00 UTC,
\ and adjusts the parameters to the current clkfreq 
\
\ This word will be run on one cog at system startup.
\
\ Counts system clock cycles (ticks) since system startup as an
\ unsigned double long.
\
\ Update read cycle is approximately 1 - 2 microseconds on an
\ 80 Mhz system.
\
\ This is because we have to use a lock, to update, or to read the
\ 2 longs that make up the double counter.
\
\ The words which update the double counter, and which read the
\ double counter, are written in assembler to ensure maximum resolution.
\ 
\ This provides a range of about 7,311 years at 80 Mhz
\ 2^64 / 80,000,000 / 60 / 60 / 24 / 365
\
\ The range will vary if the clock frequency changes, the design point
\ on this was an 80 Mhz system
\
\ Time is then calculated as ticks since 1970-Jan-01_00:00:00
\ only unsigned counts are considered, so minimum date is 1970-Jan-01_00:00:00
\
\ So for the unix people, you can generate a unix time stamp easily
\
\ NOTE: UTC -> local timezone conversion can cause an underflow. 
\
\ setTimeZone ( h m -- ) - sets the time zone h and m can be positive or negative
\
\ setTime ( y m d h m s -- ) sets the UTC time
\
\ setLocalTime ( y m d h m s -- ) subtracts the time zone, then sets UTC time
\
\ getTime ( -- y m d h m s ticks -- ) gets UTC time
\
\ getLocalTime ( -- y m d h m s ticks -- ) gets local time
\ 
\ formatTime ( -- y m d h m s ticks -- cstr) formats a to a printable sortable string
\
\ getTimeStr( -- cstr) get the current UTC time as a string
\
\ getLocalTimeStr( -- cstr) get the current local time as a string
\
\ time ( -- ) print the local time
\
\ setDriftCorrection ( n1 -- ) sets the time correction to n1 ticks per day
\
\ utc ( -- ) print the utc time
\
\ timeStamp ( -- lo hi) gets a number which is the time stamp in microseconds (UTC)
\                       the number of microseconds since 1970-01-01_00:00:00
\                       print with d. or the double format words 
\
\ unixTimeStamp ( -- lo hi) gets a number which is the time stamp in seconds (UTC)
\                           the number of seconds since 1970-01-01_00:00:00
\                           print with d. or the double format words
\
}}}

= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages