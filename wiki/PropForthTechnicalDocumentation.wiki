#summary Technical Documentation for the PropForth kernel and utilities.
#labels Phase-Design,In-progress20100705

= Introduction =

PropForth provides an interactive development environment for the Parallax Propeller micro controller.

PropForth consists of a Forth Kernel and a set of utilities that are optional extensions to the kernel.

= The PropForth Kernel =

* The [http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin] source code file

PropForth Kernel source code is found in the file [http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin]. 
[http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin] is loaded into the Propeller chip EEPROM using the Parallax Propeller Tool software.  When the Propeller is power cycled or rebooted, the spin interpreter (an assembler program) running in cog0 launches the PropForth environment (another assembler program).  

* the PropForth development environment

The PropForth environment consists of a Serial driver running in cog7 and the forth kernel running on other cogs.  

* The [http://code.google.com/p/propforth/downloads/detail?name=DeluxeSerialMonitor.f&can=2&q=#makechanges PropForth serial driver]

The serial driver is an instance of the forth kernel running a serial driver application.  The function of the serial driver application is to manage communications between forth kernel instances running in the other cogs and the users terminal program (teraterm4.65 is used throughout this documentation).  

* PropForth command prompt

The users terminal [http://code.google.com/p/propforth/wiki/TeraTerm (teraterm)] displays the command prompt of the cog running the users forth development environment, which is usually cog 6 by default.

* Nitty Gritty:  Serial Communication Mechanism 

To the user, it appears that the terminal application is talking directly to cog 6.  In fact, the terminal application is talking to the cog 7 serial driver, and the cog7 serial driver is talking to the forth kernel running in cog6.  This communication is transparent to the user, but is an important distinction further on.  


* Inside the [http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin] File

The [http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin] file can be approached as  having two sections:

1) the Propeller Assembly implementation of the Forth Dictionary and inner interpreter;

2) the forth definitions of the forth words.

The Propeller Assembly implementation of the Forth Dictionary and inner interpreter is all the spin and assembly code before ForthDictStart in the [http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin] file.

The forth definitions of the forth words is all the code between ForthDictStart and ForthMemEnd, which is the remainder of the file. 

* Propeller Assembly implementation of the Forth Dictionary and inner interpreter

The author of PropForth developed the assembler implementation of the forth dictionary and inner interpreter based on previous knowledge of forth and of the propeller architecture and the propeller assembly.   This section generally does not change much.  If you wish to make changes you are free to do so, but understand that this can affect the design of the kernel. 

Routines that are used in the infrastructure of the dictionary and inner interpreter include routines that are not called from user applications.  The words that are internal to infrastructure contain an underscore character. {{{  a_ v_ c_ $C_ $H_ }}}

{{{ 
c_ a_ v_ prefixes are ONLY used by the assembler. These reside in COG MEMORY.

c_cogResidentCode (subroutine?)
a_cogResidentAssebler
v_cogResidentVariable

$C_ and $H_ are a special class -  these designate a constant that is an address of a spin label.

$C_ is a hub memory address - the spin label occurred in the HUB

$H_ is cog memory address - the spin label occurred in the COG

}}}

{{{ $C_ $H_ }}} These words are entries in the forth dictionary to access the assembler labels.  An example using the assembler VGA driver will be presented at a later date.  A simple example using the serial driver is also planned but is not ready to be posted as of this writing. 

* The spin definitions of the forth words

The second section of [http://code.google.com/p/propforth/downloads/detail?name=PropForth.spin&can=2&q=#makechanges PropForth.spin] is the section between ForthDictStart and ForthMemEnd.  

This section consists of spin code generated by the extension word spinmaker.  The source code for this word is found in spinmaker.f which may be split into two parts [http://code.google.com/p/propforth/downloads/detail?name=spinmakerPart1.f&can=2&q=#makechanges spinmakerPart1.f] and [http://code.google.com/p/propforth/downloads/detail?name=spinmakerPart2.f&can=2&q=#makechanges spinmakerpart2.f] due to size limits.

spinmaker reads the current dictionary, and generates spin assembler code to that will produce the same executable image.  

When spinmaker is executed, code is generated that will produce whatever forth environment is running. 


* The forth definitions of the forth words

Once the inner interpreter and dictionary are established in assembler, the remainder of the kernel can be defined using forth source code.  The forth source code is in two parts, PropForthPart1.f and PropForthPart2.f.  This is done due to the size of the forth source code text; there is more text than the propeller can handle in a single text file.

When the two files PropForthPart1.f and PropForthPart2.f are loaded into the propeller, those definitions are added to the forth dictionary.  The most recent definition for a given word is the only definition visible to the forth interpreter, so old definitions are hidden.  When spinmaker is executed, only the most recent definition is used. 

* Propeller specific HAL words

The Hardware Abstraction Layer (HAL) words are prefixed with an underscore. The implementation of the forth kernel for the propeller involves issues due to the unique nature of the propeller hardware.   The {{{ _HALword }}} words are propeller - specific words that support the user - callable standard forth words. 

Propeller - specific issues were addressed using 

{{{ _aWord }}}  dictionary entries that are prefixed with an underscore are regular forth words, but are HAL words implemented in support of standard forth words.  These words are not expected to be called by a user application. For example, the word {{{ _sttop }}} is a storage location that holds the address of the top of the data stack.  The word {{{ _stbot }}} is a storage location that holds the address of the bottom of the data stack.  The word {{{_rstop }}} is a storage location that holds the address of the top of the return stack. The word {{{ _rsbot }}} is a storage location that holds the address of the bottom of the return stack.

= Memory Access words =

The basic memory access words in FORTH are fetch, designated with an "at" sign "@" and store, designated by the exclamation point "!".  

From the propeller manual, we know that there are several differnet ways to access the various memory types used in the propeller.  The propeller has 32k bytes of RAM, 32k bytes of ROM, and registers.  These memory types can be accessed in in some combination of character (1 byte), word (2 byte), and long (4 byte).  Additionally, the default hardware usually includes 32k or 64k of EEPROM, which can be accessed as character (1 byte), word (2 byte), and long (4 byte), or 32 or 64 byte pages.  

== HUB Memory ==

HUB (main) Memeory is accessed with the following words:

{{{
C@ - character (1 byte) fetch

C! - character (1 byte) store

W@ - word (2 byte) fetch

W! - word (2 byte) store

L@ - long (4 byte) fetch

L! - long (4 byte) store
}}}

These words use capital letters for readability due to confusion between the lowercase "L" and the number "1".

== HUB Register memory? ==

NOTE:  This is where I get a little hazy, this section on HUB registers might not be anywhere near correct.  

Cog Registers vs HUB registers (am I saying this correctly?)

Configuration register - softres, pllena, oscena, oscmode, clksel

CLK register IS the system clock configuration register.  Its bits are reset, pplena, oscena, oscmod1, oscmod0, clksel2, clksel1, clksel0 as described in Table 1-5 of the propeller manual page 28. 

Ok, but what are the propforth word that control this, and and do they automagically take care of {{{ byte[4] }}} of main memory, and {{{ long[0] }}} of main memory?  Question is:  Are propforth words implemented to handle HUB register functions, or is this done in the Propeller tool at compile time?  

== Cog Memory ==

The cog memory or cog RAM is actually 512 registers of 32 bits. 

COG memory is always addressed as LONG.  Since cog memory access is a special case, the COG LONG memory access was given special names

{{{
COG@ - long (4 byte) fetch to cog memory

COG! - long (4 byte) store to cog memory
}}}

== Cog Register Memory ==

 The last 16 locations of Cog Memory $1F0 to $1FF are special purpose registers par, cnt, ina, outa, dira ctra, ctrb, frqa, frqb, phsa, phsb, vcfg, vscl and are documented in the propeller manual. PropForth uses the these same names as do the spin and propeller assembler. 

The words !source !instruction and !destination store a value (bit pattern) to the appropriate bits in the specified register. 

{{{
!source 

!instruction 

!destination
}}}

see  {{{ _execasm2>0 _execasm2>1 _execasm1>1 }}}

Alternately, if the entire bit pattern has been constructed into a 32 bit value, the 32 bit value can be stored into a special purpose register using !COG.

== EEPROM Memory ==

The EEPROM is addressable by byte, words, long, or page.  Depending on the part, the page access can be 32 bytes or 64 bytes.  The 32k parts on the stock demo board support 32 byte pages, the 64k parts on the proto board support 64 byte pages AND 32 byte pages. PropForth uses 32 byte page writes for consistency, although it is possible modify the kernel to allow 64 byte access or auto detection.  Auto detection of EEPROM capability is not implemented in the kernel at this time in PropForth version 3.2.
 
The words to access EEPROM meory are:

{{{
EC@ - fetch EEPROM byte

EW@ - fetch EEPROM word

EW! - store EEPROM word

eewritepage - write a 32 byte page to EEPROM

eereadpage  - read a 32 byte page from EEPROM
}}}

Notice that a word to STORE a BYTE to EEPROM has NOT been implemented

Notice that a word to STORE a LONG to EEPROM has NOT been implemented

Notice that a word to FETCH a LONG to EEPROM has NOT been implemented

It has been determined that while this looks inconsistent, in practice one only wants to read a byte, read or store a word, or build and write an entire 32 byte page, or read an entire 32 byte page.  Of course, the user is free to implement words to store a byte, store a long, fetch a long, read a 64 byte page, and write a 64 byte page to EEPROM, if needed. 

= Naming Convention Summary =

{{{ 
lowercase - all standard forth words implemented

lowercase - all spin words implemented in propforth

lowercase - all prop assembler labels implemented in propforth

_underscore prefix - HAL words, prop specific words used internally by propforth to implement user - callable words.  (Don't call any underscore prefixed words unless you know what you are doing).

c_ prefix acts as a directive to the prop assembler indicating this is cog resident assembler code, NOT callable by forth

a_ prefix acts as a directive to the prop assembler indicating this is cog resident assembler code (that IS callable by forth?)

v_ prefix acts as a directive to the prop assembler indicating this is cog resident variable (that IS callable by forth?)

[or are these all only used internally by the assembler and not usable by forth?]

$C_ is a hub memory address - the spin label occurred in the HUB

$H_ is cog memory address - the spin label occurred in the COG

(SomeWord) - an internal implementation for user callable SomeWord

}}}

Examples: 
(forget) - when a word like *forget* call some internal word that does the prop-specific actions that implement the word on the prop, the "internal" part of the definition is in parenthesis.   Thus the word *forget* calls the word *(forget)*.   

(find) - the word *find* is the standard forth word that searches the dictionary for the string that follows.  *find* calls the word *(find)* which does something internal which is the bulk of the work of *find*. 

= WORK IN PROGRESS 20100705 =
= This page has not been reviewed and may contain errors =